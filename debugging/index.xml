<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The Debugging Process on Nuevo Foundation Workshops</title><link>https://nuevofoundation.github.io/workshops/debugging/</link><description>Recent content in The Debugging Process on Nuevo Foundation Workshops</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 13 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://nuevofoundation.github.io/workshops/debugging/index.xml" rel="self" type="application/rss+xml"/><item><title>An Overview of Debugging</title><link>https://nuevofoundation.github.io/workshops/debugging/01-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/01-overview/</guid><description>There are many different ways to debug a program. In this guide, we’ll start off with some general steps so that you don’t get lost when you debug a program. There are 3 basic steps to debugging a program:
Identify the problem. In this step, your goal is to identify what is causing the bug. This involves finding the conditions that led to the bug. Being able to reproduce the bug gives you some of the information you need, which lets you narrow down the problem and perhaps helps you understand why the bug is occurring in the first place.</description></item><item><title>Step 1 - Finding the problem (Part 1)</title><link>https://nuevofoundation.github.io/workshops/debugging/02-identify-the-problem1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/02-identify-the-problem1/</guid><description>Compiler Errors Let’s start and take a look at one of the first daunting problems a novice programmer faces: reading and understanding errors.
There are two kinds of errors: compiler and runtime errors.
A compiler error usually indicates a problem with your syntax. Perhaps you wanted to express an idea in the program but didn&amp;rsquo;t adhere to the rules of the programming language. These are caught when you compile your program.</description></item><item><title>Step 1 - Finding the problem (Part 2)</title><link>https://nuevofoundation.github.io/workshops/debugging/03-identify-the-problem2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/03-identify-the-problem2/</guid><description>Print Statements Compiler errors are one thing, but runtime errors and bugs are another. While the compiler can easily tell you where to look, runtime bugs are caused by how your program executes. We need to understand what the program is doing when the bug happens:
What variables are being used? Which instruction is being called? Is there a missing statement we needed? In smaller applications, we can use print statements in the code to quickly figure out the program’s running state.</description></item><item><title>Step 1 - Finding the problem (Part 3)</title><link>https://nuevofoundation.github.io/workshops/debugging/04-identify-the-problem3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/04-identify-the-problem3/</guid><description>Debuggers Debugging code is such a widespread, common problem that people have built entire programs designed to help other programmers debug more efficiently. These are suitably named debuggers, and there are plenty of debuggers that work for the C programming language. Let&amp;rsquo;s take a look at gdb, a common debugger used with the command line.
For our examples, we will make use of the Quicksort algorithm.
Quicksort is an algorithm that sorts an array by first selecting an element in the array as a pivot.</description></item><item><title>Step 2 - Fixing the problem</title><link>https://nuevofoundation.github.io/workshops/debugging/05-fixing-the-problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/05-fixing-the-problem/</guid><description>Once you’ve figured out what’s causing the bug, you can start thinking about how to fix the bug. Compiler errors are easy enough - most of the time, the compiler gives you plenty of hints on how to fix it, and during times you can’t figure it out by compiler output alone, you can turn to the web. Chances are, someone ran into the same problem as you years ago and asked the question already on a forum such as StackOverflow.</description></item><item><title>Step 3 - Testing</title><link>https://nuevofoundation.github.io/workshops/debugging/06-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/06-testing/</guid><description>You’ve implemented the fix(es) for your bug(s). Naturally, the first thing you do is recompile your code and run it. If it looks right, you’ve fixed the bug! For smaller projects, this works relatively well. Larger projects might be more difficult since it takes much longer to compile. Typically, they have have automated tests that are run automatically after updates are made to the codebase so programmers don&amp;rsquo;t even need to worry too much about this step (except for the programmers making the tests!</description></item><item><title>Exercise 1 - Binary Tree Implementation</title><link>https://nuevofoundation.github.io/workshops/debugging/e1-binary-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/e1-binary-tree/</guid><description>The binary tree is one of the simplest data structures in computer science and the ideas it uses are very useful. It stores sortable data and boasts an optimal runtime of O(log n) for searching, adding, and removing elements. However, this performance depends heavily on the order in which elements are added or removed, which limits its use to academic discussion.
The Theory A binary tree consists of many nodes that are linked together.</description></item><item><title>Exercise 2 - Binary Heap Implementation</title><link>https://nuevofoundation.github.io/workshops/debugging/e2-binary-heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/e2-binary-heap/</guid><description>A binary heap is an important data structure used most often to implement a data type called a priority queue. It is also used conceptually in sorting algorithm called heapsort. Its distinctive feature is its O(1) query for the largest or smallest value within its contents, depending on what kind of heap we are talking about.
The Theory The binary heap is conceptually a complete binary tree. This means that nodes are added to the tree in level order, and the depth of the tree increases only when there is no room the deepest tree level.</description></item><item><title>Exercise 3 - The Burrows-Wheeler Transform</title><link>https://nuevofoundation.github.io/workshops/debugging/e3-burrows-wheeler-transform/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nuevofoundation.github.io/workshops/debugging/e3-burrows-wheeler-transform/</guid><description>The Burrows-Wheeler transform is an algorithm used in data compression. It takes as an input a string, and outputs an encoded string, which usually has similar characters clustered together.
The Theory The algorithm is relatively straightforward and easy to understand.
Take the input string and extract all of its rotational transformations. (See picture). Sort the rotations in lexicographical order, ascending. Take the last column of the sorted transform; this is the output.</description></item></channel></rss>