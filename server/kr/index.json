[
{
	"uri": "/kr/razor/learn-vscode/",
	"title": "Visual Studio Code 알아보기",
	"tags": [],
	"description": "",
	"content": "Visual Studio Code 소개 Visual Studio Code는 코드 편집기입니다. 이 편집기의 사용자 인터페이스와 레이아웃은 다른 많은 코드 편집기와 유사합니다.\n왼쪽 사이드 바(Side Bar): 인터페이스의 왼쪽에는 사이드 바가 있으며, 코드 프로젝트의 파일과 폴더에 접근할 수 있습니다. 오른쪽 편집 영역(Editor Area): 인터페이스의 오른쪽에는 편집 영역이 있습니다. 애플리케이션 파일의 내용을 확인하고 편집할 수 있습니다. Visual Studio Code 사용자 인터페이스의 주요 영역 이해하기 Visual Studio Code의 사용자 인터페이스는 다음의 6가지 주요 섹션으로 구성됩니다. 아래 다이어그램과 설명을 통해 각 섹션의 역할을 이해해봅시다.\nA. 액티비티 바 (Activity Bar)\n위치: 창의 왼쪽 가장자리의 세로로 좁은 막대. 기능: 보기(예: 탐색기(Explorer), 확장 프로그램(Extensions) 등)를 전환하거나, 상황에 따라 필요한 지표를 표시합니다. B. 사이드 바(Side Bar)\n위치: 액티비티 바의 오른쪽.\n기능: 도구와 리소스를 제공하는 다양한 뷰를 포함합니다.\n예: EXPLORER(탐색기) 뷰는 코드 프로젝트를 작업할 때 매우 유용합니다.\nC. 편집기(Editor)\n위치: 창의 중앙 영역.\n기능: 파일을 편집하는 공간입니다.\n여러 편집기를 열어 수직 또는 수평으로 나란히 배치할 수 있습니다.\nD. 패널 영역(Panel Area)\n위치: 편집기 영역 아래쪽. 기능: 출력 정보, 디버그 정보, 오류 및 경고, 통합 터미널 등 다양한 패널을 표시합니다. E. 상태 바(Status Bar)\n위치: 창의 맨 아래쪽 수평 막대. 기능: 열려 있는 프로젝트와 편집 중인 파일에 대한 정보를 제공합니다. F. 메인 메뉴(Main Menu)\n위치: 애플리케이션 창의 맨 위. 기능: 파일 저장, 코드 편집, 실행 등 다양한 작업을 수행할 수 있는 메뉴 옵션을 제공합니다. "
},
{
	"uri": "/kr/java-tictactoe/using-repl-it/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "틱택토 요약 Replit 사용하기 오늘 여러분은 Replit을 사용하여 자바로 코딩하는 방법을 배웁니다.\n시작하기 전에 Replit 계정이 필요합니다. 계정이 없으면 아래 버튼을 눌러 가입하세요. 이미 계정이 있다면, 아래 버튼을 사용하여 로그인하세요.\nReplit 가입하기\n그 다음, 오늘 사용할 Replit 콘솔을 실행하세요. 아래 버튼을 클릭하면 다음과 같은 화면이 나옵니다:\nReplit 실행하기\n이제 Repl \u0026ldquo;포크(Fork)\u0026ldquo;할 것입니다. 포크는 프로그램을 복사하여 자신만의 버전을 만드는 것을 의미합니다. 오른쪽 상단의 \u0026ldquo;Fork Repl\u0026rdquo; 버튼을 클릭하고, 다시 \u0026ldquo;Fork Repl\u0026quot;을 클릭하세요.\nReplit을 포크 한 후에는 아래와 같은 창이 나타납니다:\n\u0026ldquo;Replit 실행하기\u0026rdquo; 버튼을 볼 때마다, 활동을 완료하기 위해 위의 단계를 따라 repl을 포크해야 합니다. repl을 포크하는 데 문제가 있으면 도움을 요청하세요!\n시작하기 전에, 창이 어떻게 작동하는지 먼저 이해해 봅시다. Main.java 파일은 컴퓨터가 실행할 코드, 즉 지침을 포함하고 있습니다. run 버튼을 누르면 컴퓨터에게 코드의 지침을 수행하라고 지시하는 것입니다. 코드를 실행한 결과는 창의 하단 화면에 있는 Console 탭에 표시됩니다.\nRun` 버튼 옆에 있는 Replit에서 열기라는 아이콘을 클릭하세요. 이곳이 TicTacToe 프로그램을 위한 모든 코드를 입력할 창이 될 것입니다. 즐거운 시간 되세요!\n"
},
{
	"uri": "/kr/guidelines/site-architecture/",
	"title": "사이트 구축 방식",
	"tags": [],
	"description": "",
	"content": "사이트 구축 방식 워크숍 서브도메인(subdomain)의 콘텐츠는 Hugo의 DocDock\r테마를 사용하여 구축됩니다. Hugo\r는 여러 장점을 가진 정적 “사이트 생성기(static site generator)”입니다:\n콘텐츠 작성자 는 사이트의 기술 구현이나 CSS/페이지 스타일에 신경 쓰지 않고 Markdown 형식으로 콘텐츠에 집중할 수 있습니다. 워크숍들은 자동으로 왼쪽 목차와 워크숍 홈 페이지에 추가됩니다. Hugo는 로컬 환경, 즉 자체 네트워크상(예: 비행기 안)에서도 잘 작동하며, 가장 빠른 정적 사이트 생성기로서 전체 워크숍 사이트를 2초 이내에 구축할 수 있습니다. 학생들 은 일관된 사용자 경험(UX), 내장된 접근성(built-in accessibility), 로컬라이제이션(localization), 모바일부터 데스크톱까지 지원하는 반응형 디자인의 혜택을 누릴 수 있습니다. 또한 “GitHub” 저장소로의 자동 링크와 “Azure CDN”을 통한 빠른 글로벌 사이트 성능을 제공합니다. Nuevo 개발 팀 은 워크숍 페이지를 구축하고 사용자화할 수 있는 기능을 통해 다양한 이점을 누립니다. 여기에는 사용자화 페이지 템플릿(custom page templates), 알림(alerts), 메모(notes), 버튼(buttons), 경고(warnings) 등을 위한 내장 페이지 컨트롤(built-in page controls)\r, Nuevo 헤더(Nuevo header)와 같은 사용자화 컨트롤(custom controls), iframe 상호작용(iframe interactivity), 커스텀 메타데이터(custom metadata), 자동 페이지 링크 연결(automated cross-page linking), 페이지 테마 지정(page theming), 자동 사이트맵 생성(automated site map creation), 내장 아이콘(built-in icons), 그리고 GitHub Actions 및 Azure DevOps를 사용하는 빌드/배포 자동화(built-in automation using GitHub Actions and Azure DevOps for build/deployment)가 포함됩니다. "
},
{
	"uri": "/kr/secret-messages/using-repl-it/",
	"title": "Repl.It 사용하기",
	"tags": [],
	"description": "",
	"content": "\n왕과 왕비를 돕기 위해, 우리는 C++이라는 프로그래밍 언어로 프로그램을 개발할 것입니다. 이 프로그램을 사용하면 메시지를 입력하고, 프로그램이 메세지를 비밀 메시지로 변환할 수 있습니다.\nRepl.It 사용법 오늘 우리는 Repl.It을 사용할 것입니다. 시작하기 전에, Repl.It 계정이 없다면 먼저 가입해야 합니다. 아래 버튼을 클릭하여 Repl.It 계정을 생성하세요. 가입하려면 이메일 계정이 필요합니다. 이미 Repl.It 계정이 있다면, 아래 버튼을 사용해 로그인할 수 있습니다.\nReplit 가입 하기\n다음으로, Repl.It 콘솔을 사용하려고 하는데, 이를 실행하려면 아래 버튼을 클릭하세요. 다음과 같은 화면이 나타날 것입니다.\nReplit 실행하기\n이제 \u0026ldquo;Fork Repl\u0026rdquo; 버튼을 클릭하여 Repl을 포크합니다. 포크란 프로그램의 사본을 만들어 우리가 수정할 수 있도록 하는 과정입니다. 오른쪽 상단의 “Fork Repl” 버튼을 클릭하고, 다시 “Fork Repl” 버튼을 누르세요.\nRepl을 포크한 후에는 아래와 유사한 창이 나타날 것입니다.\n매번 “Launch Replit” 버튼을 볼 때마다 위 단계를 따라 Repl을 포크하여 활동을 완료해야 합니다. 포크하는 과정에서 문제가 있다면 도움을 요청하세요.\n먼저, 이 창이 어떻게 작동하는지 알아봅시다. main.cpp 파일은 컴퓨터가 이해하고 실행할 명령어, 즉 코드가 포함된 파일입니다. Run 버튼을 클릭하면 컴퓨터가 해당 파일에 있는 명령어를 실행합니다. 결과는 Repl 하단의 콘솔 탭에서 확인할 수 있습니다. 다음으로, main.cpp에 작성된 코드를 설명하겠습니다.\n라이브러리와 #include main.cpp의 시작 부분으로 이동하면, 다음과 같은 줄이 있을 것입니다:\n#include \u0026lt;iostream\u0026gt; 이 명령어는 iostream라이브러리를 참조합니다. 라이브러리는 특정 공통 문제나 주제와 관련된 C++ 함수들이 모여 있는 공간입니다. 예를 들어, 그림 그리기, 인터넷 연결 관리, 수학 연산 등을 수행하는 라이브러리가 있습니다. iostream은 매우 기본적인 라이브러리로, 콘솔에서 메시지를 주고받을 수 있게 해줍니다.\n주석(Comment) main.cpp에 회색으로 표시된 줄은 //로 시작하며, 이것을 주석이라고 합니다. 주석은 C++ 프로그램을 더 잘 문서화하고 명령어의 목표를 자세히 설명하는 데 유용합니다. 주석은 명령어가 아니며, 컴퓨터는 이를 무시합니다.\n네임스페이스 규격(namespace std) 네임스페이스 규격 사용하기(using namespace std); 이 특정 명령어는 몇 가지 미리 예약된 C++ 단어에 접근할 수 있도록 합니다. 예약된 단어는 특정 의미를 가진 단어로, 다른 목적으로 사용할 수 없습니다. 여기서 std라는 예약된 단어를 참조하여 C++ 표준 라이브러리의 코드를 사용합니다. using namespace std는 표준 네임스페이스를 참조하겠다는 뜻입니다.\n메인 함수 (Main Function) int main(){\rreturn 0;\r} main 은 모든 C++ 프로그램에서 필수적인 함수입니다. 프로그램의 진입점(entry point) 역할을 합니다. 중괄호 { … } 안에 우리가 실행하려는 모든 명령어를 작성합니다. Run 버튼을 클릭하면 컴퓨터가 이 명령어를 실행합니다. return 0; ;은 프로그램이 성공적으로 실행을 마쳤음을 나타냅니다. 만약 이 줄 이후에 명령어가 있다면, 컴퓨터는 이를 실행하지 않습니다.\n모든 C++ 명령어는 세미콜론 ;으로 끝나야 합니다. semicolon ;\r"
},
{
	"uri": "/kr/microbit-distance-checker/what-is-microbit/",
	"title": "마이크로빗이란?",
	"tags": [],
	"description": "",
	"content": "마이크로빗이란? 마이크로빗은 프로그래밍 마이크로컨트롤러입니다! JavaScript, Python, Scratch, Blocks와 같은 다양한 언어를 사용하여 웹 브라우저에서 코딩할 수 있습니다. 이번 세션에서는 MakeCode Blocks를 사용합니다.\n마이크로빗에는 다음과 같이 다양한 동작이 가능한 기능과 센서가 포함되어 있습니다:\n25개의 개별적으로 제어 가능한 LED 2개의 물리적 버튼 2개의 입력/출력(IO) 핀 자력계 센서 가속도계(모션 센서) 블루투스 마이크로빗의 개별 구성 요소와 기능에 대해 모두 알고 싶다면 여기\r에서 확인할 수 있습니다.\n이제 가방에서 마이크로빗과 나머지 구성품을 꺼내 보세요. 마이크로빗 1개, 배터리 2개, 마이크로 USB 케이블, 그리고 배터리 홀더(빨간색과 검은색 와이어가 나오는 검은색 박스)가 있어야 합니다. 빠진 것이 있거나 도움이 필요하면 강사 중 한 명에게 요청하세요!\n시뮬레이터 사용 실제 하드웨어를 사용하는 것만큼 재미있지는 않지만, 시뮬레이터를 사용해 코드가 작동하는 것을 확인할 수 있습니다. 화면 왼쪽에서 마이크로빗 이미지들을 찾아보세요. 보이지 않는 경우, 왼쪽에 있는 “\u0026gt;” 기호를 클릭하여 시뮬레이터를 표시하세요. 시뮬레이터의 마이크로빗에서 블루투스 라디오 안테나를 찾아보세요. 노란색의 사각형 파형 모양입니다.\n안테나 위에 마우스 커서를 올리면 실제 신호 강도가 표시됩니다. 그런 다음 안테나를 클릭하고 마우스 커서를 왼쪽으로 드래그하여 신호 강도를 줄이거나, 오른쪽으로 드래그하여 강도를 높일 수 있습니다. 신호가 일정 강도를 넘으면 (강도 \u0026gt; -67), 다른 마이크로빗이 찡그린 표정을 짓습니다. 신호를 다시 약하게 하면 마이크로빗이 웃는 얼굴로 바뀝니다.\n자, 이제 코딩을 시작해 봅시다!\n"
},
{
	"uri": "/kr/javascript-blocks-earsketch/music-basics/",
	"title": "음악의 기본 요소",
	"tags": [],
	"description": "",
	"content": "먼저 기본적인 음악 개념을 알아봅시다. 음악이란 무엇인가요? 음악\r은 소리를 시간적으로 조직화한 것입니다. 즉, 특정한 소리를 특정한 시간에 배치하여 선율, 리듬, 화성이 조화를 이루도록 만드는 것입니다. 가장 기본적인 개념은 소리를 제때 맞추는 것입니다. 이 개념에서 몇 가지 중요한 음악 용어들이 나옵니다: 비트(beat), 리듬(rhythm), 듀레이션(duration) 및 템포(tempo)\n비트(Beat) 는 리듬이 맞춰지는 기준이 되는 규칙적인 박자입니다. 리듬(Rhythm) 은 길거나 짧은 소리, 강하거나 약한 소리 또는 침묵이 반복되는 패턴으로, 메인 비트에 맞춰집니다. 듀레이션(Duration) 은 리듬을 구성하는 음이나 소리, 침묵의 길이입니다. 템포(Tempo) 는 음악이 연주되는 속도를 의미합니다. "
},
{
	"uri": "/kr/ml-machine-learning/01-regression/",
	"title": "‘회귀’란 무엇인가요?",
	"tags": [],
	"description": "컴퓨터가 결과를 예측하게 하는 법 알아보기.",
	"content": "회귀란 무엇인가요? 회귀(Regression)는 어떤 변수(독립 변수/independent variable)가 다른 변수(종속 변수/dependent variable)에 어떤 영향을 미치는지 알아보는 방법입니다. 다시 말해 한 변수의 값이 바뀌면 다른 변수의 값이 어떻게 변하는지 알 수 있도록 관계를 찾아내는 것입니다. 이 방법을 잘 사용하면 앞으로의 결과를 쉽게 예측할 수 있습니다.\n회귀 회귀는 우리가 가진 데이터를 이어주는 선(직선이나 곡선)을 찾아주는 효과적인 수단입니다. 회귀를 사용하면 수학적인 모델\r을 만들어 독립 변수와 종속 변수의 관계를 보여줄 수 있습니다. 수학적인 모델은 우리가 어떤 시스템(예를 들어 날씨, 판매량 등)을 이해하고, 그것을 바탕으로 미래를 예측하는 데 도움을 줍니다. 하지만, 우리가 만든 수학적 모델이 항상 데이터를 잘 데이터의 속성을 잘 반영하지 않을 수도 있습니다. 그러므로 데이터의 패턴을 더 잘 나타낼 수 있는 모델을 찾는 과정이 필수적입니다.\n예제 1: 비가 언제 올 지 어떻게 알 수 있을까요? 날씨 앱을 열거나 뉴스를 보면서 \u0026ldquo;오늘 비 올 가능성이 몇 퍼센트인가요?\u0026ldquo;라고 물어본 적 있나요? 기상학자들은 수학적인 모델을 사용해서 비가 올 가능성을 계산합니다. 그럼 이 수학적 모델에는 어떤 변수(variables)가 필요할까요? 단순히 \u0026ldquo;비 냄새\u0026quot;만으로 충분할까요?\n비가 언제 올지 알기 위해 어떤 변수를 생각해야 할까요?\r온도(temperature): 날씨가 덥나요, 춥나요, 아니면 적당한 온도인가요? 고도(altitude): 고도에 따라 날씨는 더 추워지거나 더워질 수 있습니다. 위치(location): 당신이 어디에 있는 지도 중요합니다. (예: 숲, 해변, 산, 사막 등) 습도(humidity): 공기가 무겁게 느껴지나요? 공기 중에 비가 올만큼의 충분한 수분이 있나요? 계절 (time of the year) : 지금은 몇 월인가요? 어떤 계절인가요? 위 요소 외에도 고려해야 할 것이 많습니다. 결국 \u0026ldquo;비가 올 가능성\u0026quot;은 종속 변수(Dependent Variable)이고, 위에 나열된 것들은 독립 변수(Independent Variables)에 해당합니다. 쉽게 말해 비가 올 가능성은 위 독립 변수들의 값에 따라 달라집니다.\n연습 문제 1: 누군가 도형의 넓이(area)를 보고 그 도형의 종류를 맞추고 싶어 한다고 가정해보겠습니다.\n그것은 가능한가요? 넓이를 보고 도형의 종류를 알 수 있을까요? 답변 보기\r아니요, 도형의 넓이와 종류는 관계가 없습니다.\n예를 들어, 한 변의 길이가 3인 정사각형의 넓이는 9입니다.\n\\[\r3 \\cdot 3 = 9\r\\]\r하지만 너비가 6이고 높이가 3인 삼각형의 넓이도 9입니다.\n\\[\r(6 \\cdot 3)/2 = 9\r\\]\r넓이로는 그것이 어떤 도형인지 알 수 없습니다.\n그렇다면, 도형의 종류를 알기 위해서는 어떤 것들을 알아야 하나요? 답변 보기\r바로 변의 개수(number of sides) 입니다. 변의 개수를 통해 도형의 종류를 알 수 있어요.\n우리는 이 내용을 ‘X = Y’라는 선형 관계(linear Relationship)로 나타낼 수 있어요.\nX → 변의 개수(number of sides) Y → 도형의 종류(type of shape)\n축하해요! 이렇게 첫 번째 머신러닝 모델(Machine Learning Model)을 만들었어요!\n이전 예제에서의 모델(model)은 종속 변수(dependent Variable)와 독립 변수(independent Variables) 간의 관계를 설정하기 위해 만들어진 함수일 뿐입니다. 예를 들어 직선(y = ax + b), 포물선(y = a(x - h)^2), 3차 곡선(y = ax^3 + bx^2 + cx + d)과 같은 함수들이 모델로 사용됩니다. 이 외에도 다양한 함수가 모델로 활용될 수 있습니다.\n우리가 만든 모델이 데이터를 잘 설명하는 지 어떻게 확인할 수 있을까요? 이미 만들어진 머신 러닝 모델을 사용할 때는, 데이터를 잘 대변할 수 있는 모델을 골라야 합니다. 아래 [그림1]을 보면 데이터 포인트들이 포물선 형태를 나타내고 있습니다. 따라서 우리가 사용해야 할 모델은 포물선 모델(parabolic model)일 가능성이 큽니다. 포물선 모델은 다음과 같은 식으로 표현됩니다:\n\\[\ry = a(x -h)^2\r\\]\r포물선 모델을 사용할 때는, 포물선의 꼭지점(vertex)이 어디에 위치할 지를 알아야 새로운 데이터 포인트를 예측할 수 있습니다. 만약 꼭지점을 설정하지 않고 모델을 사용하면 데이터와 잘 맞지 않는 \u0026ldquo;과소적합(Under-fitting)\u0026rdquo; 상태가 될 수 있습니다. 반대로, 꼭지점을 너무 많이 설정하면 데이터에 지나치게 맞추려는 \u0026ldquo;과적합(Over-fitting)\u0026rdquo; 상태가 될 수 있습니다. 우리가 원하는 것은 과소적합이나 과적합 상태가 되지 않은 모델을 만들어서, 기존 데이터뿐만 아니라 새로운 데이터도 잘 예측할 수 있게 하는 것입니다.\n[그림1]: 과소적합(Under-Fitting)과 과적합(Over-Fitting) 모델을 선택할 때는 반드시 그 모델이 여러분의 데이터를 잘 설명할 수 있는지 확인해야 합니다. 그렇지 않으면 다음 두 가지 문제 중 하나가 발생할 수 있습니다:\n과소적합(Under-Fitting)\n과소적합은 주어진 데이터에서 관계를 찾지 못할 때 발생합니다. 주로 사용할 데이터가 부족할 때 이런 문제가 나타납니다.\n과적합(Over-Fitting)\n과적합은 데이터의 모든 값을 지나치게 반영하려 할 때 발생합니다. 이 과정에서 실제로는 의미가 없는 값들, 예를 들어 이상치(outliers) 같은 값들까지 모델에 포함하게 됩니다. 이렇게 하면 현실을 제대로 반영하지 못합니다.\n예를 들어, 변이 1개나 2개인 도형은 논리적으로 말이 안 되는 경우처럼, 실제로 존재하지 않는 값을 반영할 수도 있습니다.\n"
},
{
	"uri": "/kr/adafruit/building-the-dj-station/",
	"title": "DJ 스테이션 만들기",
	"tags": [],
	"description": "",
	"content": "오렌지 연결하기 오렌지와 악어 클립 와이어 하나를 준비하세요. 악어 클립의 아래쪽 절반을 오렌지에 꽂고 클립의 윗부분이 바깥으로 나오게 합니다. 악어클립을 오렌지의 아랫부분 중앙, 껍질을 벗기기 시작하는 부분에 꽂으면 가장 쉽습니다.\n다른 와이어를 사용하여 두 번째 오렌지에도 같은 작업을 반복합니다. 하나의 오렌지는 아다프루트 보드의 A1 포트에 연결합니다. 다른 오렌지는 아다프루트 보드의 A2 포트에 연결합니다. 이제 오렌지를 모두 연결한 모습은 아래 그림과 같이 보일 것입니다!! USB 케이블을 사용하여 양쪽의 플러그 중 더 작은 쪽을 아다프루트 보드에 연결합니다. 작은 쪽 플러그는 은색 포트에 꽂아야 합니다. 컴퓨터에 보드를 연결하기 전에 프로그램을 작성해 봅시다! 시작하기 전에 반드시 컴퓨터의 소리를 음소거(MUTED) 상태로 설정하세요.\n"
},
{
	"uri": "/kr/machine-learning/get-dataset/",
	"title": "Step 1: 데이터셋 가져오기",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "FIFA 2019는 축구 비디오 게임입니다. 이 게임의 모든 선수는 종합 능력치(overall ratings)를 가지고 있으며, 크로스(crossing), 마무리(finishing)와 같은 다양한 속성(attribute)도 갖추고 있습니다.\n우리는 Kaggle이라는 웹사이트에 가서 데이터셋을 가져올 것입니다.\nFIFA19 dataset\r참고: 다운로드 링크를 받기 위해서는 이 웹사이트의 회원가입이 필요할 수도 있습니다. 이 페이지에서는 이 데이터셋에 대한 많은 정보를 찾을 수 있습니다. 시간을 들여 탐색하고 데이터셋에 익숙해지는 것이 좋습니다. 데이터를 다운로드한 후, 압축 파일을 C:\\fifa_dataset\\ 폴더에 압축 해제합니다.\n"
},
{
	"uri": "/kr/security-phishing/bob-goes-fishing/",
	"title": "밥의 낚시 이야기",
	"tags": [],
	"description": "",
	"content": "우리 친구 밥을 소개할게요. 밥은 친절하고 유쾌한 사람이에요. 여행과 낚시를 취미로 즐기죠. 어느 날 저녁, 밥은 \u0026ldquo;바하마 여행 당첨\u0026quot;이라는 이메일을 받았어요. 밥은 너무 기뻐서 당장 링크를 눌러 자신의 정보를 입력했고, 여행 일정이 도착하기를 기다렸어요.\n밥은 여행을 준비하며 새 옷과 새 낚싯대를 샀어요.\n하지만 24시간이 지나도 여행 확인 메시지가 오지 않았어요. 하루가 더 지나도 여전히 아무 소식이 없었죠. 그래서 밥은 친구 앨리스를 만나기로 했어요. 밥은 앨리스에게 이메일과 바하마 여행, 새 옷과 낚싯대 이야기를 하며 여행을 얼마나 기다리고 있는지 말했어요. 비밀 요원인 앨리스는 뭔가 수상하다고 생각하고, 밥에게 이메일을 보여 달라고 했어요.\n이메일을 읽어본 앨리스는 한숨을 쉬며 말했어요. “밥, 너 피싱사기를 당했어!\n"
},
{
	"uri": "/kr/security-fundamentals/what-is-security/",
	"title": "보안이란 무엇일까요?",
	"tags": [],
	"description": "",
	"content": "일반 보안 vs. 사이버 보안 보안은 위험이나 위협으로부터 자유로운 상태를 의미합니다. 사이버 보안도 마찬가지로 위험에서 벗어나 안전한 상태를 만드는 것을 목표로 하지만, 사이버 보안은 사이버 공간에서의 안전을 의미합니다.\n사이버 보안 전문가들은 사용자가 인터넷을 안전하게 이용할 수 있도록 다양한 방법으로 보호 작업을 진행합니다. 어떤 사이버 보안 엔지니어들은 새로운 취약점을 찾아내는 데 주의를 기울이고, 또 다른 엔지니어들은 해커들이 프로그램을 공격하기 전에 이를 방어하는 역할을 합니다.\n사이버 공간이란? 사이버 공간은 컴퓨터 네트워크를 통해 의사소통이 이루어지는 모든 장소를 의미합니다. 소셜 미디어 사이트나 포럼에서 다른 사람들과 상호작용하는 공간뿐 아니라, 인터넷을 통하거나, 가정이나 사무실과 같은 소규모 네트워크 내에서 컴퓨터들끼리 대화하는 경우도 포함됩니다.\n왜 보안이 필요할까요? 보안이 필요한 이유는 해커들이 항상 당신의 정보를 훔치려 하기 때문입니다. 사이버 공간은 사람들이 자신의 정보가 도난당하거나 바이러스와 악성 소프트웨어로 인해 컴퓨터가 위험에 빠질 걱정 없이 방문할 수 있는 공간이어야 합니다.\n사이버 보안 엔지니어들의 역할과 사이버 보안 분야는 매우 중요합니다. 사이버 범죄로 인해 사람들의 데이터, 삶, 혹은 사업이 피해를 입을 수 있기 때문입니다. 또한, 재정적인 손실도 입을 수 있습니다. 2018년 기준으로 국제전략연구소(CSIS)에 따르면 사이버 범죄로 인한 전 세계적 피해는 약 6000억 달러에 달합니다. 일부 보고서에서는 이 수치가 2020년과 2021년에 1조 달러에 이를 것이라고 추정했습니다.\n"
},
{
	"uri": "/kr/security/meeting-alice-bob-eve/",
	"title": "앨리스, 밥, 이브 만나기",
	"tags": [],
	"description": "",
	"content": "\n여기 우리 친구 밥이 있습니다. 그리고 밥은 공유하고 싶지 않은 비밀이 있습니다.\n밥은 그것을 안전하게 지키고 싶어합니다. 그의 비밀을 안전하게 잠가 두었습니다. 오직 밥만이 잠금 장치의 열쇠를 가지고 있어 누구도 그의 비밀에 접근할 수 없습니다.\n성격이 좋지 않은 이브가 있습니다. 이브는 밥의 비밀에 접근하고 싶어합니다.\n이브는 밥의 비밀에 접근하기 위해서 먼저 밥의 잠금을 풀어야 한다는 것을 깨닫습니다. 이브는 잠금 장치를 부술 수는 없지만, 아마도 열쇠를 찾아낼 수는 있을 것입니다. 밥을 잠시 염탐한 후 이브가 깨닫게 된 것은, 밥이 정말로 반려견 맥스를 사랑한다는 것이었습니다. 여기서 이브는 아이디어를 얻게 됩니다.\n이브는 밥이 애완동물을 그렇게 사랑하니, 아마도 맥스를 밥의 잠금 열쇠로 삼았을 것이라고 생각합니다. 그들은 맥스를 통해 시도하기로 하였고, 이브는 밥의 잠금을 열고 비밀을 볼 수 있었습니다.\n밥은 이브가 자신의 잠금을 쉽게 뚫지 못하도록 하기 위해 무엇을 할 수 있었는지 알고 싶어하지만, 어디서부터 시작해야 할지 모릅니다.\n다행히도 밥의 좋은 친구 비밀 요원 앨리스가 도와주러 왔습니다. 엘리스가 어떻게 도와줄 지 봅시다\u0026hellip;\n"
},
{
	"uri": "/kr/razor/activity-1/",
	"title": "활동 1 - Visual Studio Code 탐색하기",
	"tags": [],
	"description": "",
	"content": "활동 1 - Visual Studio Code 탐색하기 Visual Studio Code를 열고 Welcome 페이지를 살펴보세요. Windows 시작 메뉴를 사용하여 Visual Studio Code 열기\nWindows 시작 메뉴를 열면 최근에 추가된 애플리케이션 목록에서 Visual Studio Code를 찾을 수 있습니다. 또는 시작 메뉴를 아래로 스크롤하여 Visual Studio Code를 찾아보세요. 화면 하단의 실행 트레이에 있는 Windows 검색 상자에 \u0026ldquo;Visual Studio Code\u0026quot;를 입력하여 검색할 수도 있습니다.\nVisual Studio Code의 Welcome 페이지 확인하기\nVisual Studio Code를 처음 열면 Welcome 페이지가 나타나며, 몇 가지 링크와 정보가 포함되어 있습니다. 처음 실행할 때 Get Started with VS Code와 같은 유용한 안내 내용이 표시됩니다. 이 안내 내용은 후에 따로 참고해볼 수 있습니다\nWelcome 페이지 닫기\nWelcome 페이지를 닫으려면, 인터페이스에 표시된 닫기 버튼(화면에 X로 표시됨)을 선택해주세요. 편집기(Editor)에서 열려 있는 각 페이지에는 페이지 제목 오른쪽에 닫기 버튼(X)이 있습니다. 페이지 탭은 Visual Studio Code 창의 왼쪽 상단, 메인 메뉴(Main Menu) 아래에 표시됩니다. 마우스 포인터를 닫기 버튼(X) 위에 올리면 \u0026ldquo;Close\u0026quot;라는 단어가 나타납니다.\n액티비티 바와 사이드 바 살펴보기 Visual Studio Code 창의 왼쪽 끝에 있는 세로형 아이콘 목록이 액티비티 바(Activity Bar)입니다. 액티비티 바 오른쪽에 위치한 사이드 바(Side Bar)는 기본적으로 축소된 상태입니다. 사이드 바의 내용은 액티비티 바에서 선택한 항목에 따라 달라집니다.\n마우스 포인터를 액티비티 바 위에 놓고, 각 아이콘 위에 마우스를 올려보세요. 그러면 해당 아이콘의 라벨이 표시됩니다. 액티비티 바의 버튼들은 다음 이미지에서 보여주는 것과 유사하게 나타날 것입니다.\n액티비티 바(Activity bar)의 아이콘을 위에서부터 아래로 살펴보면 다음과 같습니다: 탐색기(Explorer), 검색(Search), 소스 제어(Source Control), 실행 및 디버그(Run and Debug), 확장 프로그램(Extensions), 계정(Accounts), 관리(Manage).\n액티비티 바에서 탐색기(Explorer) 아이콘을 선택합니다. 그러면 사이드 바가 열리고 관련 정보가 표시됩니다.\n사이드 바는 EXPLORER라는 이름으로 표시됩니다. EXPLORER 뷰는 프로젝트 폴더와 코드 파일을 탐색하거나 확인할 때 사용됩니다. Visual Studio Code는 작업 기록을 저장하며, 프로그램을 다시 열 때 가장 최근에 작업했던 파일과 폴더를 자동으로 엽니다. 하지만 처음 열었다면 아직 프로젝트 폴더가 열려 있지 않습니다.\n액티비티 바에서 확장 프로그램(Extensions) 아이콘을 선택합니다.\nN사이드 바가 EXTENSIONS라는 이름으로 표시됩니다.\nEXTENSIONS 뷰의 정보 살펴보기\nEXTENSIONS 뷰에서는 코딩 언어, 디버거, 기타 도구를 추가할 수 있는 확장 프로그램 정보를 제공합니다. 개발 환경을 지원하며, 이 워크숍에서는 나중에 C# 확장 프로그램을 설치할 것입니다.\n액티비티 바에서 다시 확장 프로그램(Extensions) 아이콘을 선택하면 EXTENSIONS 사이드 바가 닫힙니다.\n상단 메뉴 옵션 살펴보기 File 메뉴를 선택하여 파일 메뉴 옵션을 확인합니다.\n파일 메뉴에는 New(새로 만들기), Open(열기), Save(저장), Close(닫기) 옵션이 나열되어 있는 것을 확인합니다.\nEdit(편집) 메뉴 옵션을 잠시 살펴본 후, 상단의 다른 메뉴 항목도 하나씩 살펴봅니다.\n여러 메뉴에 코드와 상호작용하는 옵션이 포함되어 있습니다. 예를 들어,\nEdit(편집) 메뉴에는 찾기, 바꾸기, 코드 주석 전환 옵션과 함께 잘라내기, 복사, 붙여넣기, 실행 취소, 다시 실행과 같은 표준 옵션이 포함되어 있습니다. Selection(선택) 메뉴에는 코드 줄을 선택하고 조작할 수 있는 옵션이 포함되어 있습니다. Run(실행) 메뉴에는 애플리케이션을 실행하고 디버그 할 수 있는 옵션이 포함되어 있습니다. Terminal(터미널) 메뉴에서 New Terminal을 선택합니다.\n터미널 패널의 내용 확인하기\n터미널 패널의 내용을 잠시 살펴봅니다. 탭(PROBLEMS, OUTPUT, DEBUG CONSOLE, TERMINAL) 간에 전환할 수 있으며, 오른쪽 상단의 버튼 위에 마우스를 올리면 버튼 레이블이 표시됩니다.\n터미널 패널에는 명령 프롬프트가 포함되어 있습니다.\n터미널 패널은 명령줄 인터페이스(CLI) 명령을 실행하는 데 사용됩니다.\n터미널 패널의 오른쪽 상단에서 X(닫기) 버튼을 선택하여 패널을 닫습니다.\n보기(View) 메뉴에서 명령 팔레트 선택하기\nView 메뉴에서 Command Palette(명령 팔레트) 를 선택합니다. 명령 팔레트는 다양한 유용한 명령을 찾고 실행하는 데 사용됩니다. 지금은 세부적으로 살펴볼 필요는 없지만, 명령 팔레트의 위치를 알아두는 것이 좋습니다.\n명령 팔레트의 프롬프트에 extensions를 입력합니다.\n입력에 따라 명령 목록이 필터링되는 것을 확인합니다.\nextensions 대신 help를 입력하여 명령 목록을 업데이트합니다.\n필터 된 명령 목록에서 Help: Interactive Editor Playground를 선택합니다.\nEditor Playground 문서가 편집기에 열리며, 대화형 활동 목록이 포함되어 있습니다.\n대화형 활동 목록에서 Formatting(서식 지정)을 선택합니다.\n서식 지정 옵션에 대한 내용을 잠시 읽어봅니다.\nEditor Playground 문서를 닫습니다.\n"
},
{
	"uri": "/kr/java-tictactoe/activity-1/",
	"title": "1. 게임판 설정하기!",
	"tags": [],
	"description": "인쇄 문을 사용하면 게임 규칙과 보드가 표시됩니다",
	"content": "이 활동에서는 게임판과 게임 진행을 출력하는 프로그램을 작성합니다. 아래와 같은 출력이 나와야 합니다:\n\u0026lt;\u0026lt;\u0026lt;~ 틱택토 ~\u0026gt;\u0026gt;\u0026gt;\r* 숫자 1 - 9를 선택하여 말을 놓으세요\r* 플레이어: \u0026#39;X\u0026#39; 컴퓨터: \u0026#39;O\u0026#39;\r1 | 2 | 3 ---+---+---\r4 | 5 | 6 ---+---+---\r7 | 8 | 9 말을 놓을 위치를 선택하세요 (1-9): 2\rO | X | ---+---+---\r| | ---+---+---\r| | 말을 놓을 위치를 선택하세요 (1-9): 메인 클래스와 메인 메서드(method) 시작 코드에서 main()클래스와 main()메서드가 제공되어 있습니다. main() 메서드는 우리가 Run 버튼을 누르면 프로그램이 실행되는 시작점입니다.\npublic class Main { public static void main(String[] args) { } } 출력문 main() 메서드 내에서 print 문을 사용하여 게임의 환영 메시지와 규칙을 출력하세요\n\u0026lt;\u0026lt;\u0026lt;~ 틱택토 ~\u0026gt;\u0026gt;\u0026gt;\r* 숫자 1 - 9를 선택하여 말을 놓으세요\r* 플레이어: \u0026#39;X\u0026#39; 컴퓨터: \u0026#39;O\u0026#39;\r## 변수와 배열\r이 게임에서는 현재 보드의 9가지 위치 각각에 있는 기호를 추적해야 한다는 점에 유의하세요.\r따라서 프로그램에 9개의 데이터를 저장해야 합니다. 크기 9의 배열`array`(데이터 구조)를 사용하여 저장해 보겠습니다.\r규칙에 명시된 바와 같이, 게임 보드에서 \u0026#39;X\u0026#39;는 플레이어의 움직임이고, \u0026#39;O\u0026#39;는 컴퓨터 움직임이며, \u0026#39;\u0026#34;\u0026#34;\u0026#34;는 사용 가능한 위치입니다.\r이를 위해 9개의 모든 위치(즉, \u0026#39;{\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;)에 값을 갖는 배열 \u0026#39;변수\u0026#39;를 선언해 보겠습니다.\r## 게임판 출력하기\rboard 변수에 현재 게임 보드의 기호가 저장되어 있다고 가정합니다. 이제 아래에 표시된 출력처럼 빈 게임 보드를 출력하기 위해 print 문을 사용해 보겠습니다.\r각 게임 보드는 5줄로 구성되어 있으므로, 각 줄을 출력하기 위해 5개의 print 문을 사용하는 것이 합리적입니다.\r9개의 블록 각각은 길이가 3인 문자열(String)로 이루어져 있으며, 가운데 문자는 해당 위치의 board에 저장된 현재 기호입니다.\r이 단계를 완료한 후 아래와 같은 출력을 가지는 프로그램을 작성해야 합니다. \u0026laquo;\u0026lt;~ 틱택토 ~\u0026raquo;\u0026gt;\n숫자 1 - 9를 선택하여 말을 놓으세요\n플레이어: \u0026lsquo;X\u0026rsquo; 컴퓨터: \u0026lsquo;O\u0026rsquo;\n| |\n\u0026mdash;+\u0026mdash;+\u0026mdash; | |\n\u0026mdash;+\u0026mdash;+\u0026mdash; | |\n## 메서드(Methods)\r게임 진행 중 현재 게임 보드를 여러 번 출력해야 할 것이므로, 4단계에서 작성한 코드를 메서드로 분리하는 것이 좋습니다.\r이 메서드는 String[] 배열을 입력으로 받아 현재 보드를 출력하는 역할을 합니다. 이 메서드는 main() 메서드 외부에 작성되어야 한다는 점에 유의하세요.\r다음과 같은 헤더를 가진 메서드를 작성해 보겠습니다:\r```java\rpublic static void printBoard(String[] curBoard); 메서드 호출하기 main() 메서드에서 printBoard() 메서드를 호출하여, 위치가 표시된 초기 게임 보드를 출력하도록 설정하세요. 이를 위해 \u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026hellip;, \u0026ldquo;9\u0026quot;의 내용을 가지는 또 다른 String 배열을 생성하면 됩니다.\n그리고 Enter your move (1-9): 라는 텍스트를 출력하는 코드를 추가하세요.\n출력은 아래와 같이 표시되어야 합니다:\n\u0026laquo;\u0026lt;~ Tic Tac Toe ~\u0026raquo;\u0026gt; 1번 ~ 9번을 선택하여 이동합니다\n플레이어: \u0026lsquo;X\u0026rsquo; 컴퓨터: \u0026lsquo;O\u0026rsquo; 1 | 2 | 3 \u0026mdash;+\u0026mdash;+\u0026mdash; 4 | 5 | 6 \u0026mdash;+\u0026mdash;+\u0026mdash; 7 | 8 | 9 Enter your move (1-9):\n프로그램 실행\n프로그램을 실행했을 때 위와 같은 텍스트가 출력된다면, 다음 단계로 진행할 준비가 완료된 것입니다. 👍\n"
},
{
	"uri": "/kr/supply-chain-analytics/scenario/",
	"title": "상황 설정하기",
	"tags": [],
	"description": "",
	"content": "새로운 Xbox 1000이 출시되었고, 꼭 사고 싶어졌어요. 하지만 돈을 많이 모아야 하죠. 학교 모금 행사에서 엄마가 구워주신 쿠키가 인기를 끌었던 기억이 떠올라서, 엄마와 함께 베이커리를 시작해 수익을 50:50으로 나누자는 멋진 아이디어를 생각해냈어요!\n처음에는 두 가지 종류의 쿠키만 팔기로 했어요. 친구들에게 설문조사를 해보니, 친구들이 가장 좋아하는 두 가지 쿠키는 초코칩 쿠키와 설탕 쿠키였어요.\n한 번에 구워내는 양은 쿠키 12개예요. 초코칩 쿠키 한 판은 $20에 팔 수 있고, 설탕 쿠키 한 판은 $15에 팔 수 있어요.\n쿠키를 만들기 위해서는 재료를 사야 해요. 공급망에서는 이런 재료를 원재료라고 불러요. 계산해보니, 초코칩 쿠키는 설탕 쿠키보다 더 많은 재료가 필요해서, 초코칩 쿠키 한 판당 원재료 비용이 $10이 들고, 설탕 쿠키 한 판은 $7이 들어요.\n쿠키 사업은 경쟁이 치열해요. 사업을 유지하려면 수익을 내야 하고, 이는 버는 돈이 쓰는 돈보다 많아야 한다는 뜻이에요.\n그렇다면 수익을 어떻게 계산할까요?\r수익 = 매출 - 비용\r매출은 쿠키를 팔아서 번 총액이에요. 거기서 쿠키를 만드는 데 사용한 재료비용을 빼면 남는 것이 수익이에요!\r하지만 여기서 문제는, 초코칩 쿠키와 설탕 쿠키를 만드는 데 필수 재료가 한정되어 있다는 거예요. 각 쿠키 한 판마다 필요한 재료의 양이 다르기 때문에 이를 잘 관리해야 해요. 단순하게 설명하기 위해 주된 재료 세 가지(계란, 밀가루, 설탕)만 포함했어요.\n여러분은 가지고 있는 재료를 최대한 활용해서 쿠키를 팔아 가장 많은 수익을 내야 해요. 그렇다면 어떻게 해야 할까요?\n"
},
{
	"uri": "/kr/guidelines/new-workshops/",
	"title": "새 워크숍 가이드라인 (New Workshop Guidelines)",
	"tags": [],
	"description": "",
	"content": "이 문서는 Nuevo Foundation 워크숍 프로젝트\r에 새로운 워크숍을 만드는 방법을 안내하기 위한 것입니다.\n사이트 아키텍처(Site Architecture)\r와 시작하기(Getting Started)\r섹션을 숙지해 주세요.\n"
},
{
	"uri": "/kr/guidelines/getting-started/",
	"title": "시작하기",
	"tags": [],
	"description": "",
	"content": "필수 준비물 Visual Studio Code\rHugo\rGit\r. Git 및 GitHub에 대한 자세한 정보는 Quickstart\r가이드를 참고하세요. 참고 링크 Github 저장소 (Github repo)\r워크숍 웹사이트\r연습 영상 워크숍 GitHub 저장소 개발 사이클\r워크숍 GitHub 저장소 구조\r코드 이 저장소에 대한 작업 기여는 포크(fork) 모델\r을 통해 이루어집니다. 참여자는 워크숍의 자신만의 \u0026ldquo;포크 된\u0026rdquo; 버전에 변경 사항을 적용한 후, 해당 변경 사항을 “풀 리퀘스트(pull request)”로 제출합니다.\n시작하기:\n오른쪽 상단의 Fork를 클릭하여 저장소 를 포크(fork)합니다: git bash에서 다음 명령어를 실행합니다, (replacing [user-name] with your GitHub user name): \\\u0026gt; git clone https://github.com/[user-name]/workshops.git\r\\\u0026gt; cd workshops\r\\workshops\u0026gt; git remote add upstream https://github.com/NuevoFoundation/workshops.git\r\\workshops\u0026gt; git remote set-url --push upstream no_push 위의 마지막 명령어는 “풀 리퀘스트(pull request)”를 거치지 않고 실수로 이 저장소에 업로드(push)되는 것을 방지합니다.\n위 명령을 실행한 후 git remote -v 명령을 실행하면 다음과 유사한 결과가 표시됩니다:\n\\workshops\u0026gt; git remote -v origin https://github.com/dmonroym/workshops.git (fetch)\rorigin https://github.com/dmonroym/workshops.git (push)\rupstream https://github.com/NuevoFoundation/workshops.git (fetch)\rupstream no_push (push) 구축 및 테스트 변경 사항을 구축하고 테스트하려면 Hugo를 사용해야 합니다. 올바른 설치 지침을 따른 경우 Hugo는 PATH에 포함되어 있어야 합니다 (그렇지 않으면 컴퓨터를 재시작하세요).\n\\\u0026gt; cd workshops\r\\workshops\u0026gt; hugo -D server 몇 가지 구축 정보가 출력되겠지만 가장 중요한 라인은 다음과 같습니다: Web Server is available at //localhost:1313/ (bind address 127.0.0.1)\n이제 웹 브라우저를 열고 //localhost:1313/ 에 접속하면 사이트가 표시되는지 확인할 수 있습니다.\n포크(fork) 업데이트 하기 자신의 포크(fork)를 최신 상태로 유지하려면 가능한 한 자주 업데이트하는 것이 좋습니다. 새 브랜치(branch)를 만들기 전에 변경 사항을 가져와 자신의 포크(fork)에 업로드(push)해야 합니다. 방법은 다음과 같습니다. (다른 브랜치(branch)가 필요하다면 master 대신 해당 브랜치를 사용하세요).\n\\workshops\u0026gt; git fetch --all --prune\r\\workshops\u0026gt; git checkout master\r\\workshops\u0026gt; git merge upstream/master\r\\workshops\u0026gt; git push origin master 샘플 워크스루 (Sample Walkthrough) 시나리오: Getting Started 페이지에 단순한 변경을 추가하고 풀 리퀘스트(pull request)를 제출해 봅시다.\n위의 지침을 따르세요. 코드 지침을 완료하면 로컬에 워크숍 저장소 복사본이 생깁니다.\n주제 브랜치(branch) 만들기 포크가 업데이트되었는지 확인한 후 이 작업을 진행하세요:\n\\workshops\u0026gt; git checkout master\r\\workshops\u0026gt; git checkout -b [branch-name]\r\\workshops\u0026gt; git push --set-upstream origin [branch-name] VS Code로 저장소 열기 VS Code를 실행하고 Open Folder를 선택하여 워크숍 폴더로 이동한 후 열기를 클릭합니다.\n파일 탐색 및 수정하기 수정하는 내용에 따라 사이트가 어떻게 구축되는지\r더 잘 이해하고 싶을 것입니다.\n우리의 경우 이 파일을 수정하려고 하므로, content\\english\\guidelines\\getting-started.md로 이동합니다. “Welcome!”이라는 단어에 느낌표 두 개를 추가해 주세요.\n수정 전: Welcome!\n수정 후r: Welcome!!!\n변경 사항 커밋(commit) “git status” 명령을 실행하면 지금까지 한 모든 변경 사항과 모든 파일 이름이 표시됩니다. 그런 다음 git add 명령으로 스테이지(stage)하고 커밋(commit) 및 업로드(push) 명령을 실행합니다. 다음과 같은 명령을 사용합니다:\n\\workshops\u0026gt; git status\r\\workshops\u0026gt; git add content/english/guidelines/getting-started.md\r\\workshops\u0026gt; git commit -m \u0026#34;Added exclamations\u0026#34;\r\\workshops\u0026gt; git push 팁: 모든 파일을 추가하고 한 번에 커밋(commit)하려면 다음 명령을 사용할 수 있습니다:git commit -am \u0026quot;message here\u0026quot; 과 git push\n풀 리퀘스트 생성하기 축하합니다! 이제 모든 필요한 변경 사항을 완료했으며 마지막 단계는 검토를 받고 프로덕션에 반영하는 것입니다.\n포크된 GitHub 저장소로 이동하면 최신 업로드(push)를 기반으로 풀 리퀘스트 생성 제안이 표시됩니다.\n풀 리퀘스트가 표시되지 않으면, Pull Requests -\u0026gt; New pull request로 이동합니다.\n여기서 가장 중요한 점은 브랜치(branch)를 올바르게 선택하는 것입니다 (base와 head).\nCreate pull request 버튼을 누르고, 설명과 제목을 입력한 후 검토자가 승인하여 병합할 수 있도록 기다립니다.\n"
},
{
	"uri": "/kr/jsappybird/load-the-bird/",
	"title": "새 이미지 로드 및 화면 텍스트 변경",
	"tags": [],
	"description": "",
	"content": "먼저 “Flappy”를 로드하고 화면에 배치해 봅시다.\n파일 [File: load-sprites.js] 에 다음 명령을 추가하세요: game.load.image('bird','assets/bird.png');\r함께 해보기 아래 “Replit” 창에서 코드는 game.load.image('bird', 'assets/bird.png');로 시작합니다.\nrun을 누르고 스페이스 바를 누르면, 여러분의 콘솔에 새가 나타나는 것을 볼 수 있습니다:\n화면 텍스트 변경하기 시작 화면 텍스트를 변경해 봅시다:\n파일 [File: start-screen.js] 에 다음 명령을 추가하세요. var text = game.add.text(0, 0, \u0026ldquo;Press Space to Start\u0026rdquo;, textOptions);\n함께 해보기 아래 Replit 창에서 var text = game.add.text(0, 0, \u0026quot;Press Space to Start\u0026quot;, textOptions);로 코드를 시작했습니다.\nrun을 누르면, 여러분의 콘솔에 \u0026ldquo;Press Space to Start\u0026quot;라는 문구가 나타나는 것을 확인할 수 있습니다:\n"
},
{
	"uri": "/kr/secret-messages/activity-1/",
	"title": "Activity 1 - 출력하기t",
	"tags": [],
	"description": "",
	"content": "우리가 비밀 메시지를 생성할 수 있으려면, 먼저 프로그램에 입력할 메시지를 작성해야 합니다.\nReplit 실행하기\n이를 위해, 먼저 메시지가 누구를 위한 것인지 콘솔에 출력하도록 컴퓨터에 지시할 것입니다. 아래는 우리가 사용할 명령어입니다:\ncout \u0026lt;\u0026lt; \u0026#34;Hello Developer!\u0026#34; \u0026lt;\u0026lt; endl; 이 코드 줄에 대해 더 알아봅시다.\n문자열 (Strings) 따옴표(\u0026quot;\u0026quot;)로 감싸인 모든 것은 문자열(String)이라고 부릅니다. 문자열은 문자, 숫자, 글자 또는 기호로 이루어진 연속적인 데이터입니다. 예를 들어, 위 코드 줄에서 \u0026quot;Hello Developer!\u0026quot;는 문자열입니다. \u0026quot;123\u0026quot;, \u0026quot;abc!\u0026quot; , 또는 \u0026quot;Hello\u0026quot; 또한 문자열의 예입니다. 하지만 , 123, abc! , 또는 , Hello!는 따옴표로 감싸지 않았으므로 문자열이 아닙니다.\n콘솔에 출력하기 (Print to Console) 콘솔에 출력을 하기 위해 우리는 cout. 을 사용합니다. 모든 cout. 뒤에는 \u0026lt;\u0026lt;가 따라옵니다. endlendl\u0026rsquo; 은 우리가 줄의 끝에 도달했음을 의미합니다. \u0026lt;\u0026lt;로 감싸인 모든 내용은 콘솔에 출력됩니다. 예를 들어, 우리가 Run 버튼을 클릭하면 문자열 Hello Developer! 가 콘솔에 출력됩니다.\n위 코드 줄을 복사하여 처음 사용했던 main.cpp 파일에 붙여 넣으세요. 프로그램을 실행(Run)하고 어떤 일이 발생하는지 확인하세요. 문자열을 \u0026quot;Hello world!\u0026quot; 또는 \u0026quot;For the queen\u0026quot;.으로 변경해 보세요.\n도움이 필요할 때 (Help!) 만약 Run 버튼을 클릭한 후 빨간색 에러 메시지가 나타난다면, 코드에 문제가 있다는 뜻입니다. 이 경우, 강사님께 도움을 요청하세요.\n또한 아래 사항을 확인하세요:\n철자, 대소문자, 기호가 주어진 예제와 일치하는지 확인하세요. 각 코드 줄 끝에 세미콜론이 있는지 확인하세요. "
},
{
	"uri": "/kr/microbit-distance-checker/broadcasting/",
	"title": "신호 방송하기",
	"tags": [],
	"description": "",
	"content": "라디오 켜기 마이크로빗의 블루투스 라디오를 사용하여 다른 마이크로빗과 얼마나 떨어져 있는지 확인합니다. 먼저 라디오를 켜고 채널에 맞추는 작업을 해야 합니다. “Radio” 섹션을 클릭하세요. 화면에서 다섯 번째에 있는 분홍색 섹션입니다. “radio set group 1”을 선택하고 이를 작업 영역의 파란색 “on start” 블록으로 끌어다 놓으세요. 모든 참가자가 동일한 그룹 번호를 사용하도록 하세요. 다른 그룹 번호를 사용하면 마이크로빗 간 통신이 이루어지지 않습니다. 작업 영역은 아래와 같이 보여야 합니다:\n신호 방송하기 이제 마이크로빗이 신호를 청취할 준비가 되었으니, 해당 신호를 보낼 준비를 해야 합니다. 다시 “Radio” 섹션을 클릭하세요. 이번에는 “radio send number 0” 블록을 선택하고 이를 작업 영역의 파란색 “forever” 블록 안으로 끌어다 놓으세요. 이렇게 하면 마이크로빗이 동일한 그룹 내에서 계속해서 해당 숫자를 보내게 됩니다.\n"
},
{
	"uri": "/kr/javascript-blocks-earsketch/getting-started-earsketch/",
	"title": "EarSketch 시작하기",
	"tags": [],
	"description": "",
	"content": "EarSketch\r는 조지아 공과대학교에서 개발한 무료 교육용 프로그래밍 환경입니다. 오늘 우리는 EarSketch를 사용하여 음악을 만들 것입니다.\n음악을 만들기 위해, 아래 버튼을 클릭하여 EarSketch를 새 탭에서 엽니다. Earsketch 실행\n웹페이지가 열리면, 아래와 같은 환영 화면이 나타날 수 있습니다. \u0026ldquo;건너뛰기(skip)\u0026ldquo;를 눌러 안내 과정을 생략하세요. 필요한 단계를 아래에서 모두 다룰 것입니다. 이제 시작해봅시다. 왼쪽 메뉴바에서 스크립트(Scripts) 아이콘을 클릭하고, + 새 스크립트(New Script)를 선택하세요. 스크립트 이름을 myjam (또는 원하는 이름) 으로 입력하고, 프로그래밍 언어를 JavaScript로 변경하세요. 그런 다음 생성(Create) 버튼을 눌러 스크립트를 생성합니다(여기에 코드가 작성됩니다). 마지막으로, 톱니바퀴 아이콘을 클릭하고 블록 모드(Blocks mode)를 선택합니다. 화면이 다음과 같이 표시되어야 합니다. 교사를 위한 추천 사항 - EarSketch 개요 수업을 시작하기 전에 EarSketch 개요를 살펴보세요. 사용자 인터페이스(UI)를 어떻게 탐색하는지에 대해 이해하는 것이 중요합니다.\n화면 왼쪽의 콘텐츠 관리자(Content Manager) 는 EarSketch의 모든 기능을 탐색하는 중심 역할을 합니다.\n탐색 바의 첫 번째 항목은 사운드(Sounds) 모음입니다. 이것은 EarSketch에 미리 로드된 사운드를 제공하는 중앙 위치입니다. 사운드 브라우저에서 아티스트, 장르 또는 악기에 따라 표시되는 사운드를 필터링할 수 있습니다. 다음 항목은 스크립트(Scripts)창입니다. 여기에서 코드를 작성하게 됩니다. 3.마지막 항목은 API 브라우저(API Browser) 창입니다. API(애플리케이션 프로그래밍 인터페이스)는 바로 사용할 수 있는 코드의 집합입니다. API 브라우저를 클릭하면 각 API에 대한 자세한 설명이 제공됩니다.\n오른쪽에는 커리큘럼 가이드(Curriculum guide)가 보일 것입니다. EarSketch에 대해 더 알고 싶다면, 커리큘럼 창에서 탐색할 수 있습니다. 이번 연습에서는 이 부분은 생략하겠습니다.\n"
},
{
	"uri": "/kr/machine-learning/start-project/",
	"title": "Step 2: 프로젝트 시작하기",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "Jupyter Notebook을 열고, 새 노트북을 생성한 후 Python 3을 선택하세요.\n파일의 시작 부분에 필요한 패키지를 먼저 불러옵니다.\n# 필요한 패키지 불러오기 import pandas as pd import numpy as np import matplotlib.pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split 출력 결과:\n---------------------------------------------------------------------------\rImportError Traceback (most recent call last)\r\u0026lt;ipython-input-2-122d997e4faf\u0026gt; in \u0026lt;module\u0026gt;()\r1 # Importing necessary packages\r----\u0026gt; 2 import pandas as pd\r3 import numpy as np\r4 import matplotlib.pyplot as plt\r5 from sklearn.linear_model import LinearRegression\rImportError: No module named pandas "
},
{
	"uri": "/kr/ml-machine-learning/02-simple-linear-regression/",
	"title": "단순 선형 회귀",
	"tags": [],
	"description": "컴퓨터가 결과를 예측하게 하는 법 알아보기.",
	"content": "단순 선형 회귀란? 단순 선형 회귀(Simple Linear Regression)는 두 변수 간의 상관관계를 찾아내고, 이 관계를 설명하는 수학적 공식을 만드는 방법입니다. 일반적으로 단순 선형 회귀에서는 다음과 같은 결론에 도달하는 것을 목적으로 합니다:\n우리가 가진 변수들 간에 관계가 있는가?\n여러분은 소득과 소비, 경력과 급여, 또는 습도와 온도 사이의 관계를 파악할 수 있습니다. 반면, 학생의 키와 시험 점수 사이에는 아무런 관계가 없습니다.\n값을 예측하거나 예견할 수 있는가?\n회귀 분석(Regression)을 통해 모델을 학습시키고, 값을 확실하게 예측할 수 있는지 알아낼 수 있습니다. 우리가 관계에 대해 알고 있는 정보를 사용해서 새로운 값을 예측할 수 있을까요?\n예시:\n내일 온도는 몇 도가 될까? 올해 우리 빵집은 작년과 비교해서 얼마나 매출을 올릴까? 내가 경력이 5년이라면 급여는 얼마가 될까? 변수의 역할 단순 선형 회귀에서 변수는 두 가지 역할 중 하나를 맡습니다:\n종속 변수(Dependent Variable):\n예측하거나 알아내고 싶은 값입니다. 종속 변수는 다른 변수에 따라 값이 결정되므로, \u0026ldquo;종속적\u0026quot;이라고 부릅니다. 이를 y라고 합니다.\n독립 변수(Independent Variable):\n종속 변수에 영향을 미치는 변수입니다. 우리가 조정하거나 변경할 수 있는 변수입니다. 이를 x라고 합니다.\n예시: 만약 사과 한 개의 가격이 $1.00이고, 사과를 10개 산다면 총 비용은 $10.00이 됩니다.\n이 경우, 종속 변수(y)는 총 비용입니다. 독립 변수(x)는 사과의 개수입니다. 단순 선형 방정식의 수학적 모델 우리가 단순 선형 회귀를 사용할 때 이를 \u0026ldquo;선형(linear)\u0026ldquo;이라고 부르는 이유는, 수학적 모델이 2차원 평면에서 직선을 나타내기 때문입니다. 잠시 생각해 봅시다.\n직선의 수학적 방정식은 무엇일까요?\n답변 보기\r이 공식은 아마 익숙하게 느껴질 것입니다. 바로 직선의 일반 방정식입니다:\n\\[\ry = ax + b\r\\]\rx: 독립 변수(independent variable) y: 종속 변수(dependent variable) a: 직선의 기울기(slope) b: 절편(intercept), 즉 x=0일 때 y의 값 이 공식을 바탕으로 단순 선형 회귀 모델이 새로운 값을 어떻게 계산하고 예측하는지 자세히 알아보겠습니다.\n실제 세계에서의 예시 실제로는 데이터가 항상 선형적이지 않고, 예상한 것과 다르게 나타날 때가 많습니다. 처음에는 데이터 사이에 아무런 관계가 없어 보일 수도 있지만 단순 선형 회귀의 경우, 우리가 찾아야 할 것은 어느 정도 선형적인 패턴을 따르는 데이터입니다.\n여러분이 한 회사의 인사과에서 데이터 분석가로 일하고 있다고 가정해 보겠습니다. 이 회사에는 10,000명 이상의 직원이 있습니다. 여러분의 상사가 직원의 경력(근무 연수)이 급여와 관련이 있는지 알고 싶어 합니다. 데이터 분석가인 여러분은 직원 데이터베이스를 확인하여 다음과 같은 정보를 쉽게 확인할 수 있습니다:\n직원의 현재 급여는 얼마인가? 직원의 경력(근무 연수)은 얼마인가? 30명의 직원을 무작위로 선택해 데이터를 수집했다고 가정해 보겠습니다. 데이터는 다음과 같습니다:\n직원 ID 경력(근무 연수) 급여 1 1.1 39343 2 1.3 46205 3 1.5 37731 4 2.0 43525 5 2.2 39891 6 2.9 56642 7 3.0 60150 8 3.2 54445 \u0026hellip; \u0026hellip; \u0026hellip; 26 9.0 105582 27 9.5 116969 28 9.6 112635 29 10.3 122391 30 10.5 121872 표를 확인한 후, 이 값을 2D 산점도(scatter plot)로 시각화하면 아래와 같은 그래프를 얻을 수 있습니다.\n산점도 : 경력과 급여 위 그래프에서 점들은 어느 정도 직선의 모양으로 나타납니다. 이제 가상의 직선을 그려, 그 선이 모든 점을 통과할 수 있는지 확인해 봅시다.\n산점도 : 경력과 급여를 직선으로 나타내기 직선이 모든 점을 완벽히 통과하지는 않지만, 대부분 가까운 위치에 있습니다. 이는 무엇을 의미할까요? 왜 어떤 경우에는 점이 직선에 가깝고, 또 어떤 경우에는 멀리 떨어져 있을까요?\n현재까지 우리가 알고 있는 것은 다음과 같습니다:\n데이터가 선형적인 경향을 따르고 있습니다. 데이터에는 두 가지 중요한 변수, 즉 급여(salary)와 경력(years of experience)이 포함되어 있습니다.\n이는 우리가 데이터를 선형 방정식(linear equation)으로 모델링할 수 있음을 의미합니다. 질문: 우리는 급여(SALARY) 와 경력(YEARS OF EXPERIENCE) 이 변수라는 것을 알고 있습니다. 그렇다면 이 중에서 어느 것이 종속 변수(dependent Variable)이고, 어느 것이 독립 변수(independent Variable)일까요?\n답변 보기\r경력은 독립 변수입니다. 급여는 종속 변수입니다. 이 값을 선형 방정식에 대입하면 다음과 같은 식을 얻을 수 있습니다:\n\\[\r급여 = a(경력) + b\r\\]\r이 방정식은 \u0026ldquo;직원의 경력 연수가 급여에 직접적인 영향을 미친다\u0026quot;는 것을 나타냅니다.\n오류의 가능성 앞에서 알아 보았듯이 데이터는 항상 일정하지 않을 수 있으며, 여러 방식으로 다르게 나타날 수 있습니다. 이는 우리가 사용하는 선형 방정식에 오류(Error)를 고려해야 함을 의미합니다. 하지만 방정식에서 이러한 오류를 어떻게 나타낼 수 있을까요? 또한 산점도(Scatter Plot)에서 이 오류를 어떻게 시각화할 수 있을까요?\n아래의 표에서 선택된 모든 직원이 텍사스 주 산안토니오(San Antonio, TX) 출신이지만, 인사부에서 실수로 시애틀(Seattle, WA) 출신의 직원 데이터를 포함시켰다고 가정해봅시다. 시애틀의 생활비는 산안토니오보다 28.6% 더 높습니다\r. 이로 인해 산점도에서 일부 데이터 포인트가 우리가 그린 가상의 직선에서 더 멀리 떨어져 있는 것을 설명할 수 있습니다. 이러한 점들은 데이터의 오류(Errors)로 간주됩니다.\n단순 선형 회귀의 오류선 우리의 선형 방정식에 오류를 추가할 때, 이를 그리스 문자 ε(에타) 로 표현합니다..\n\\[\r급여 = a(경력) + b + ε\r\\]\rε 는 데이터에서 발생할 수 있는 오류(error)를 나타냅니다. 단순 선형 회귀의 목표는 데이터 포인트와 직선 사이의 이 오류를 최소화하는 가상의 직선을 그리는 것입니다. 이 오류 값은 종종 무시되기도 하지만, 중요한 점은 우리의 선형 방정식이 이 오류를 고려한다는 것입니다. 이를 반영하면 다음의 [예제1]과 같은 방식으로 선형 방정식을 표현할 수 있습니다.\n예제 1: Scikit-learn 사용해보기 Scikit-learn은 머신러닝 라이브러리로, 내장된 단순 선형 회귀 모델을 사용해 데이터를 분석하고 예측할 수 있도록 도와줍니다. 아래 Replit 창에서 프로그램 02-e1.py를 실행할 수 있습니다. 이 프로그램은 회사 직원의 경력과 급여 데이터를 활용하며, 직원 30명의 샘플을 추출해 그래프로 표시합니다.\nReplit 실행하기\n예제 2: 기울기(Slope)와 절편(Intercept) 찾기 다음으로 넘어가기 전에, 우리의 방정식을 다시 한번 살펴보겠습니다. 현재 방정식은 다음과 같이 업데이트되었습니다:\n\\[\r급여 = a(경력) + b + ε\r\\]\r우리는 이미 x와 y 값이 무엇인지 알고 있습니다. 하지만 a와 b는 어떨까요? 이 값들이 무엇을 의미하는지 다시 정리해 봅시다:\na: 직선의 기울기(Slope) 또는 계수(Coefficient)입니다. 기울기는 종속 변수(이 경우, 급여)가 어떻게 변화하는지 나타냅니다. b: 절편(Intercept)으로, x = 0일 때 y의 값입니다. 데이터를 그래프로 나타내면, 경력이 0일 때의 급여 값을 확인할 수 있습니다. 잠깐! 만약 회사에 경력이 전혀 없는 상태에서 입사하면, 급여가 0이라는 뜻인가요? 뭔가 이상하죠? 실제 값을 알아보도록 합시다. Scikit-learn을 사용하면 선형 회귀 모델(Linear Regression Model)을 통해 a와 b 값을 구할 수 있습니다. 아래 Replit 창에서 코드를 분석하며 a와 b를 계산해 봅시다!\n먼저 CSV 파일에서 데이터를 가져와야 합니다:\n# 데이터셋 불러오기 dataset = pd.read_csv(\u0026#34;Experience_vs_Salary.csv\u0026#34;) x = dataset.iloc[:, :-1].values # \u0026#34;Experience\u0026#34;(경력 연수) 열의 모든 값 가져오기 y = dataset.iloc[:, 1].values # # \u0026#34;Salary\u0026#34;(급여) 열의 모든 값 가져오기 다음으로, 선형 회기 모델 클래스를 생성하고 데이터를 학습시킵니다. fit 함수는 CSV 파일에서 가져온 값을 분석하여 기울기(Slope)와 절편(Intercept) 값을 계산합니다:\nmodel = linear_model.LinearRegression() model.fit(x,y) Replit 실행하기\n이 코드를 실행하면, 선형 방정식의 계수(Coefficient)와 절편(Intercept) 값이 반환됩니다. 이제 이 값을 사용하여 선형 방정식을 업데이트해 봅시다!\n\\[\r절편=25792.20\r\\]\r\\[\r계수=9449.96\r\\]\r\\[\r급여=9449.96(경력)+25792.20+ε\r\\]\r우리는 모델이 절편(Intercept) 값으로 25,792.20을 제공했다는 것을 알고 있습니다. 이는 경력이 전혀 없는 직원의 급여가 $25,792.20임을 의미합니다. 그렇다면 9,449.96은 무엇을 뜻할까요? 이 값은 경력이 1년 증가할 때마다 직원의 급여가 $9,449.96씩 증가한다는 의미입니다. 하지만 이 값들이 정말 정확한지 어떻게 확인할 수 있을까요? 무작위로 다른 30명의 직원을 선택해서 그들의 급여를 검증하면, 같은 값을 얻을 수 있을까요? 이러한 질문에 대한 답을 알아보기 위해 데이터를 더 분석해야 합니다.\n"
},
{
	"uri": "/kr/security/password-basics/",
	"title": "비밀번호 기초",
	"tags": [],
	"description": "",
	"content": "우리 비밀 요원 앨리스는 밥에게 비밀번호에 대해 설명하면서 사건을 해결합니다!!!\n비밀번호란 무엇일까요? 비밀번호는 당신의 가상 세계의 잠금 장치에 대한 열쇠입니다. 비밀번호와 사용자 이름을 사용하여 인터넷에서 개인 정보를 안전하게 보호하는 것처럼, 당신의 비밀은 잠금 장치와 열쇠를 사용하여 안전한 방에 보관됩니다. 안전한 방은 문에 있는 잠금 장치의 열쇠만큼이나 안전합니다. 해커라고 알려진 나쁜 사람들로부터 온라인 데이터와 신원을 보호하기 위해 더 강력한 비밀번호가 필요합니다.\n무엇이 문제일까요? 비밀번호는 비공식적이어야 하며 당신만 알아야 합니다. 강력한 비밀번호란 기계나 인간이 추측하기 어려운 특성으로 인해 더 안전한 비밀번호를 말합니다.\n보안이 약한 비밀번호의 예 어떤 일반적인 사전 단어(예: “비행기” 또는 “비밀번호”). 숫자로 대체된 사전 단어(예: “a1rplan3” 또는 “P4ssw0rd”). 반복된 문자 (예: “AAAAA” 또는 “12345”). 키보드 문자 나열(예: “qwerty” 또는 “poiuy”). 개인 정보(예: 생일, 애완동물의 이름 또는 친구의 이름, 사회보장번호, 주소). 컴퓨터 근처에 적어두고 저장한 모든 것. 밥의 열쇠(그의 비밀번호)는 개인 정보여서 이브는 그것을 추측할 수 있었습니다.\n어떻게 해결할까요? 더 강력한 비밀번호를 사용함으로써 해결할 수 있습니다. 비밀번호를 강력하면서도 기억하기 쉽게 만드는 방법을 배워봅시다. 비밀번호를 잊고 싶진 않잖아요?\n"
},
{
	"uri": "/kr/security-fundamentals/how-can-we-incorporate-security/",
	"title": "일상생활에서 어떻게 안전한 보안을 유지할 수 있을까요?",
	"tags": [],
	"description": "",
	"content": "\r사이버 보안은 매우 넓은 분야이며, 우리 모두가 인터넷을 안전하게 사용할 수 있도록 각자의 역할을 해야 합니다. 사이버 보안을 활용하면 우리가 속한 네트워크에 해커와 사이버 범죄자들이 침입하는 것을 예방할 수 있습니다.\n해커들의 침입을 막기 위해 우리가 할 수 있는 방법에는 무엇이 있을까요?\r제출\r좋은 생각이에요! 이 외에도 다른 방법들이 있어요:\n해커들이 쉽게 맞추지 못 하도록 긴 패스워드 사용하기\r민감한 정보를 안전하지 않은 곳에 남기지 않기(문서 작성, 일반 문서, 메모 앱)\r로그인 알림 켜기 및 이중 인증과 같은 기능 사용하기\r이메일 및 문자 메시지에서 의심스러운 링크를 열 때 주의하기\r기기를 최신 소프트웨어 버전으로 계속 업데이트하기\r"
},
{
	"uri": "/kr/security-phishing/phishing-basics/",
	"title": "피싱의 기본",
	"tags": [],
	"description": "",
	"content": "비밀 요원 앨리스가 밥에게 피싱에 대해 설명해요!\n피싱이란 무엇일까요? 낚시에서 물고기를 잡기 위해 미끼를 사용하는 것처럼, 나쁜 해커들도 사람들의 개인 정보를 훔치기 위해 다양한 미끼를 사용해요.\n피싱은 사회 공학공격(Social Engineering, 보안학적 측면에서 기술적인 방법이 아닌 사람들 간의 기본적인 신뢰를 기반으로 사람을 속여 비밀 정보를 획득하는 기법)의 한 종류로, 로그인 정보, 은행 정보, 신용카드 정보 같은 중요한 데이터를 훔치는 수법이에요.\n해커는 자신이 믿을만한 사람인 척하면서 이메일, 문자 메시지, 전화 등을 통해 사람을 속이죠.\n이 메시지를 받은 사람은 링크를 클릭하게 되는데, 그 결과로 PC나 스마트폰에 악성 소프트웨어가 설치되거나 중요한 정보가 노출될 위험이 있어요.\n밥이 저지른 실수는 무엇일까요? 밥은 해커인 이브가 보낸 이메일에 속아 바하마 여행을 받을 수 있다는 말에 속았고, 개인 정보를 입력하게 되었어요.\n더 깊이 알아보기 앨리스는 밥이 받은 이메일을 꼼꼼히 살펴보며 수상한 점들을 알려주었어요!\n참고: 신뢰할 수 있는 사람에게 개인 정보를 제공해야 하는 상황도 있지만, 잘못 제공하면 피싱 사기를 당할 수 있어요. 이번 워크숍에서는 진짜 이메일과 사기 이메일을 구별하는 법을 배워볼 거예요.\n"
},
{
	"uri": "/kr/razor/activity-2/",
	"title": "활동 2 - Visual Studio Code 확장 프로그램 추가",
	"tags": [],
	"description": "",
	"content": "활동 지침 Visual Studio Code 확장 프로그램 설정 이제 Visual Studio Code의 사용자 인터페이스에 익숙해졌으니, C# 코딩을 위해 환경을 설정해 보겠습니다.\nVisual Studio Code가 열려 있는지 확인합니다.\n액티비티 바(Activity Bar) 에서 확장 프로그램(Extensions) 아이콘을 선택합니다.\nSearch Extensions in Marketplace(마켓플레이스에서 확장 프로그램 검색) 상자에 C# 을 입력합니다.\n\u0026ldquo;C#\u0026ldquo;을 입력하면 C# 코딩과 관련된 확장 프로그램만 표시되도록 필터링됩니다.\n필터링된 확장 프로그램 목록에서 Microsoft가 게시한 C# Dev Kit - Official C# extension from Microsoft를 선택합니다.\n이 확장 프로그램은 Visual Studio Code에서 C# 코드를 개발, 편집, 디버깅하는 데 도움을 줍니다. 확장 프로그램에 대한 세부 정보는 나중에 다시 확인할 수 있습니다.\nInstall(설치) 버튼을 선택하여 확장 프로그램을 설치합니다.\n설치 버튼이 Installing(설치 중)으로 변경됩니다. 설치는 빠르게 완료됩니다.\nC# Dev Kit 페이지를 편집기(Editor)에서 닫습니다.\nEXTENSIONS 뷰의 검색 상자에서 C# 텍스트를 지웁니다.\n목록이 새로 고쳐지며, 설치된 확장 프로그램이 목록 맨 위에 표시됩니다. 그 아래에는 인기 있거나 추천되는 확장 프로그램이 나열됩니다.\nC# Dev Kit를 설치하면 다음 확장 프로그램이 함께 설치됩니다:\nC# Dev Kit - Official C# extension from Microsoft C# - Base language support for C# IntelliCode for C# - AI-assisted development for C# Dev Kit .NET Runtime Install Tool 이 네 가지 확장 프로그램은 현재 필요한 모든 기능을 제공합니다.\n"
},
{
	"uri": "/kr/java-tictactoe/activity-2/",
	"title": "2. 입력을 읽고 처리하기",
	"tags": [],
	"description": "스캐너 클래스로 입력 읽기 및 오류 사례 확인하세요.",
	"content": "패키지 불러오기 자바에서 사용자 입력을 효율적으로 받는 방법은 Scanner 클래스를 사용하는 것입니다. 이 클래스를 사용하려면 파일 상단에 다음과 같은 코드를 작성하여 java.util 패키지를 불러와야 합니다.\nimport java.util.Scanner; Scanner 클래스 사용하기 \u0026lsquo;main()\u0026lsquo;에서는 먼저 생성자를 호출하여 \u0026lsquo;sc\u0026rsquo;라는 \u0026lsquo;스캐너\u0026rsquo; 객체를 만들어야 합니다(아래에 표시됨).\n우리는 표준 입력 스트림에서 우리의 입력을 읽기 위해 \u0026lsquo;스캐너\u0026rsquo;를 사용하고자 합니다. 이를 위해서는 \u0026lsquo;System.in \u0026lsquo;(표준 입력 스트림 객체)\n// Create a Scanner object Scanner sc = new Scanner(System.in); 사용자 입력 받기 이전 활동에서는 사용자에게 1에서 9까지의 숫자를 입력하도록 요청했습니다. 따라서 입력 스트림에서 \u0026lsquo;int\u0026rsquo;를 기대할 수 있습니다.\nScanner 객체에 저장된 int 값을 얻으려면, sc라는 Scanner 객체에서 nextInt() 메서드를 호출하면 됩니다.\nint input = sc.nextInt(); 프로그램 테스트 (선택 사항) 프로그램을 테스트하기 위해 입력력 받은(띄어쓰기 수정) 값을 출력하는 print 문을 추가해봅시다.\n프로그램을 실행하고 몇 가지 숫자를 입력한 후 Enter를 누르면, 입력한 숫자가 정확하게 출력되는 것을 확인할 수 있습니다. 예를 들어:\n\u0026lt;\u0026lt;\u0026lt;~ 틱택토 ~\u0026gt;\u0026gt;\u0026gt;\r* 숫자 1 - 9를 선택하여 말을 놓으세요\r* 플레이어: \u0026#39;X\u0026#39; 컴퓨터: \u0026#39;O\u0026#39;\r1 | 2 | 3 ---+---+---\r4 | 5 | 6 ---+---+---\r7 | 8 | 9 말을 놓을 위치를 선택하세요 (1-9): 2\r입력한 숫자: 2 \u0026lt;----------- 입력된 숫자를 올바르게 출력한 문구 인쇄 사용자가 숫자가 아닌 것을 입력하면 어떻게 되나요? 프로그램을 작성할 때 프롬프트에 철자가 적혀 있어도 사용자가 올바른 값을 입력할 것이라고 기대할 수는 없습니다.\n우리 프로그램은 \u0026lsquo;int\u0026rsquo; 입력만 하기 때문에 \u0026lsquo;hi\u0026rsquo;, \u0026lsquo;$\u0026rsquo;, \u0026lsquo;20.1\u0026rsquo;과 같이 정수가 아닌 것을 입력하면 프로그램이 크래시가 나게 됩니다. 다음과 같은 오류 메시지가 표시됩니다:\nException in thread \u0026#34;main\u0026#34; java.util.InputMismatchException \u0026lt;------ tells you what error it is\rat java.base/java.util.Scanner.throwFor(Scanner.java:939)\rat java.base/java.util.Scanner.next(Scanner.java:1594)\rat java.base/java.util.Scanner.nextInt(Scanner.java:2258)\rat java.base/java.util.Scanner.nextInt(Scanner.java:2212)\rat Main.main(Main.java:15) \u0026lt;-------- 오류를 일으키는 코드 라인을 알려줍니다(Main.java의 15번째 줄) 또한, 1에서 9까지의 범위에 속하지 않는 숫자 입력은 프로그램에 충돌하지 않지만, 이 또한 우리가 원하지 않는 입력이라는 점에 유의하세요.\n스캐너로 잘못된 입력 처리하기 스캐너 클래스는 유효한 입력 또는 유효하지 않은 입력을 확인하는 메서드를 제공합니다. 예를 들어, 메서드 \u0026lsquo;hasNextInt\u0026rsquo;는 사용자의 입력 값이 정수인지 확인하고 \u0026lsquo;참\u0026rsquo; 또는 \u0026lsquo;거짓\u0026rsquo;을 반환합니다. 이 메서드는 사용자의 입력이 유효한지 확인하는 데 사용할 수 있습니다.\n제어 구조를 사용하여 사용자 입력을 검증합니다. 입력이 유효하지 않은 경우 유효한 입력을 다시 요청합니다.\nif(sc.hasNextInt()) { //was an integer entered move = sc.nextInt(); // get integer input if (!(move \u0026gt; 0 \u0026amp;\u0026amp; move \u0026lt;= 9)) { //is the integer between 1 and 9 System.out.print(\u0026#34;Invalid Position; re-enter your move (1-9): \u0026#34;); } } else { // if an integer wasn\u0026#39;t entered sc.next(); // clear the Scanner System.out.print(\u0026#34;Invalid Input; re-enter your move (1-9): \u0026#34;); } 프로그램 테스트(선택 사항) Run을 클릭하여 프로그램을 테스트하면 숫자가 아닌 입력을 입력했거나 숫자가 1에서 9 사이가 아닌 경우.\u0026lsquo;잘못된 위치; 이동(1-9)을 다시 입력하세요\u0026rsquo;라는 메시지가 표시됩니다:\n다중 입력 받기 이제 하나의 입력값을 받아 유효성을 평가하는 프로그램을 작성했으니, 게임이 끝날 때까지 플레이어가 계속 입력할 수 있도록 만들어 봅시다.\n플레이어가 다음 움직임을 입력하도록 반복적으로 요청하려면, 기존의 hasNextInt 조건문 전체를 while loop 안에 넣으면 됩니다. 이 while loop는 조건으로 true를 받기 때문에, 명시적으로 중단 명령을 내릴 때까지 계속 실행됩니다.\n또한, 루프의 각 반복 끝부분에서 printBoard(board)를 호출하여 현재 보드를 출력하고, 플레이어에게 입력을 요청합니다. 아래 예제에서 그 과정을 확인할 수 있습니다:\nwhile(true){ // insert the hasNextInt() if statement here // move these into the hasNextInt() if statement printBoard(board); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); } 유효하지 않은 입력 처리하기 플레이어가 유효하지 않은 입력값을 입력했을 때, 프로그램이 printBoard(board)를 호출하거나 Enter your move (1-9):라는 메시지를 출력하지 않도록 해야 합니다.\n즉, 잘못된 입력이 들어오면 while 루프의 다음 반복으로 바로 넘어가도록 프로그램을 설계해야 합니다. 이를 위해 코드에 continue;를 추가하여 루프의 현재 실행을 종료하고, 루프의 처음으로 되돌아가 실행을 이어가게 만듭니다.\n이 연습이 끝나면, 잘못된 입력이 들어왔을 경우 다시 입력을 요청하고, 올바른 입력에 대해서는 빈 보드와 함께 Enter your move (1-9): 메시지가 출력되는 프로그램이 완성될 것입니다!\n\u0026laquo;\u0026lt;~ 틱택토~\u0026raquo;\n1번 - 9번을 선택하여 이동합니다 플레이어: \u0026lsquo;X\u0026rsquo; 컴퓨터: \u0026lsquo;O\u0026rsquo; 1 | 2 | 3 \u0026mdash;+\u0026mdash;+\u0026mdash; 4 | 5 | 6 \u0026mdash;+\u0026mdash;+\u0026mdash; 7 | 8 | 9\n당신의 이동을 입력하세요 (1-9): d 잘못된 입력; 이동을 다시 입력합니다 (1-9): 3 | | \u0026mdash;+\u0026mdash;+\u0026mdash; | | \u0026mdash;+\u0026mdash;+\u0026mdash; | | 당신의 이동을 입력하세요 (1-9):\n"
},
{
	"uri": "/kr/supply-chain-analytics/linearoptimizationbasics/",
	"title": "선형 최적화 - 기초",
	"tags": [],
	"description": "",
	"content": "최적화란 무엇일까? 공식 정의: 수학적 최적화 모델은 목표 함수와 제약 조건으로 이루어진 방정식이나 부등식의 시스템이에요.\n선형 최적화는 복잡하게 들릴 수 있어요. 하지만 시작할 때는 몇 가지 기본 개념만 이해하면 돼요.\n최적화란? 최적화는 제한된 자원을 가지고 가장 효율적인 결정을 내리는 방법이에요. 예를 들어, Xbox를 할 수 있는 시간이 제한되어 있다면, 가장 좋아하는 게임을 최대한 오래 하도록 시간을 쓰는 것이 최적화된 선택이겠죠.\n최적화 문제에서는 컴퓨터 사용 시간이나 계란의 수처럼 현실의 제약을 수학 공식으로 나타내요. (보세요, 결국 우리는 대수학을 사용하는 거예요!)\n요즘에는 Excel이나 Python을 사용해서 이런 문제를 직접 공식을 쓰지 않고도 풀 수 있어요.\n최적화 문제를 풀기 위해 알아야 할 세 가지 주요 부분은 다음과 같아요: 의사결정 변수, 목표 함수, 제약 조건.\n의사결정 변수 의사결정 변수는 여러분이 최적화하고 싶은 항목이에요. 예를 들어, 계란의 수 같은 것이 될 수 있죠. 컴퓨터는 이 변수를 최적으로 계산해 주고, 가장 적절한 양을 추천해 줘요.\n목표 함수 목표 함수는 여러분의 목표를 설명하는 식이에요. 예를 들어, 베이커리에서 수익을 최대화하고 싶다면 어떻게 수익을 계산할까요? 각 쿠키의 수익에 쿠키를 얼마나 만들 것인지 곱한 값이 될 거예요. 여기서 의사결정 변수가 사용되는 거죠!\n제약 조건 제약 조건은 여러분이 가지고 있는 제한을 의미해요. 예를 들어, 계란의 수가 제한되어 있다면, 사용하려는 총 계란의 수가 가지고 있는 계란 수보다 적거나 같아야 해요. 이렇게 해서 방정식을 만들 수 있어요.\n"
},
{
	"uri": "/kr/jsappybird/jump/",
	"title": "새가 점프하도록 만들고 중력 적용하기",
	"tags": [],
	"description": "",
	"content": "새에게 어떤 동작을 추가할까요? 새가 점프하도록 만들어 봅시다:\n파일 [File: create-game.js] 에 다음 명령을 추가하세요: spaceKey.onDown.add(jump, this);\n함께 해보기 아래 Replit 창에서 코드는 spaceKey.onDown.add(jump, this);로 시작합니다.\nrun 을 누르고 스페이스 바를 누르면, 콘솔에 새가 점프하는 모습이 나타납니다:\n중력 추가하기 함께 해보기 아래 Replit 창에서 코드는 bird.body.gravity.y = 900;로 시작합니다.\nrun 을 누르고 스페이스 바를 누르면, 콘솔에 중력이 적용된 상태로 새가 점프하는 모습이 나타납니다.:\n"
},
{
	"uri": "/kr/secret-messages/activity-2/",
	"title": "Activity 2 - 변수와 입력",
	"tags": [],
	"description": "",
	"content": "\n멋져요! 이제 한 단계 더 나아가 봅시다. 이번에는 메시지를 출력하는 것뿐만 아니라, 수신자의 이름을 입력 받아 프로그램이 \u0026ldquo;Hello\u0026quot;라고 말하도록 만들어 보겠습니다.\n이를 위해, 우리는 **변수(Variable)**가 필요합니다.\n변수(Variable) 변수는 정보를 저장하는 컨테이너입니다. 변수에는 다양한 종류가 있으며, 각 변수는 서로 다른 유형의 정보를 저장합니다:\nstring: : 문자, 숫자, 기호의 연속적인 데이터(문자열)를 나타냅니다. 문자열은 항상 따옴표(\u0026quot;\u0026quot;)로 감싸야 합니다. 예시: \u0026ldquo;hello\u0026rdquo;, \u0026ldquo;1,2,3\u0026rdquo; int: 양수 또는 음수의 정수를 나타냅니다. 예시: 1, 100, -250 char: 단일 문자를 나타냅니다. 문자는 항상 작은따옴표(\u0026rsquo;\u0026rsquo;)로 감싸야 합니다. 예시: \u0026lsquo;A\u0026rsquo;, \u0026rsquo;e\u0026rsquo;, \u0026lsquo;I\u0026rsquo; bool: true(참) 또는 false(거짓)의 값을 나타냅니다. 변수를 생성하려면 다음과 같이 선언합니다:\nint number = 10; 이 코드 줄을 자세히 살펴보겠습니다:\n먼저 변수에 저장할 정보의 유형(type)을 지정합니다. 여기서는 int 유형입니다. 그 다음 변수의 이름을 선언합니다. 여기서는 변수 이름이 number입니다. 마지막으로 변수에 저장할 값(value)을 지정합니다. 여기서는 10입니다. 줄 끝에는 세미콜론(;)을 추가해 코드가 끝났음을 나타냅니다. 이제 프로그램 내에서 변수 number를 사용해 저장된 값을 참조할 수 있습니다. 예를 들어, 변수의 값을 출력하려면 아래와 같이 작성합니다: cout \u0026lt;\u0026lt; \u0026#34;The number is: \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; Running this line of code, the console will print:\nThe number is: 10 cout을 사용하면 단어, 숫자, 변수를 출력할 수 있습니다. 여러 항목을 출력하려면 각 항목 사이에 \u0026lt;\u0026lt;를 추가해야 합니다: Example:\nint hour = 13;\rcout \u0026lt;\u0026lt; \u0026#34;It is \u0026#34; \u0026lt;\u0026lt; hour \u0026lt;\u0026lt; \u0026#34; in the afternoon\u0026#34; \u0026lt;\u0026lt; endl; 위 코드를 실행하면 콘솔에 다음이 출력됩니다:\nIt is 13 in the afternoon. 이제 메시지 수신자가 자신의 이름을 콘솔에 입력하고, 프로그램이 그 이름을 사용해 \u0026ldquo;Hello\u0026quot;라고 말하도록 만들어 보겠습니다. 이름을 입력 받기 위해 아래 코드를 사용할 것입니다:\n이 코드를 살펴보겠습니다:\nstring name;\rcin \u0026gt;\u0026gt; name; Let\u0026rsquo;s dig into this line of code.\n콘솔 입력(Console Input) cout을 사용해 콘솔에 출력할 수 있듯이, cin을 사용해 콘솔에서 받을 수 있습니다. 입력 받은 데이터는 미리 선언한 변수에 저장됩니다. 위 코드에서는 입력한 데이터를 변수 name.에 저장하겠다고 선언한 것입니다. 예를 들어, 콘솔에서 Queen을 입력하면, 변수 name은 문자열(string)\u0026ldquo;Queen\u0026quot;을 저장합니다.\n이제 우리 프로그램을 실행할 시간입니다.\n이 활동을 위해 따라야 할 단계는 다음과 같습니다:\n문자열 변수 name을 선언합니다. \u0026lsquo;cin\u0026rsquo;을 사용하여 사용자에게 입력을 요청하고, 입력된 데이터를 name 변수에 저장합니다. \u0026lsquo;Hello (name)\u0026rsquo; 콘솔로 인쇄합니다. 여기서 (name)은 name 변수의 값으로 대체되어야 합니다. 실행을 클릭합니다. console 탭에서 수신자의 이름으로 \u0026lsquo;Queen\u0026rsquo;을 입력하고 콘솔에서 \u0026lsquo;Hello Queen\u0026rsquo;을 출력하는지 확인합니다. Replit 실행하기\n도움이 필요할 때 (HELP!) 만약 Run 버튼을 클릭한 후 빨간색 에러 메시지가 나타난다면, 코드에 문제가 있다는 뜻입니다. 이 경우, 강사님께 도움을 요청하세요. 또한 아래 사항을 확인하세요:\nYou should also check for the following\n철자, 대소문자, 기호가 주어진 예제와 일치하는지 확인하세요. 각 코드 줄 끝에 세미콜론(;)이 있는지 확인하세요. 문자열은 반드시 따옴표(\u0026quot;\u0026quot;)로 감싸야 합니다. 작성한 모든 코드는 int main 함수의 중괄호 안에 있어야 합니다. "
},
{
	"uri": "/kr/microbit-distance-checker/receiving/",
	"title": "메시지 수신하기",
	"tags": [],
	"description": "",
	"content": "이제 메시지를 보내고 청취할 준비가 되었으니, 받은 정보를 사용해 마이크로빗 간 거리를 계산할 준비를 해야 합니다. 이를 위해, 수신 신호의 강도를 알아야 합니다. “Radio” 섹션으로 돌아가 이번에는 “on radio received (receivedNumber)” 블록을 작업 영역의 빈 공간으로 끌어다 놓으세요.\n이 블록은 다른 마이크로빗에서 전송된 숫자를 받을 때 마이크로빗이 수행할 동작을 지정합니다.\n다음으로, 빨간색 “Variables” 섹션을 클릭하고 “Make a Variable…”을 선택합니다. 텍스트 상자에 “strength”라는 이름을 입력하고 “Ok ✔”를 클릭하세요.\n다시 Variables 메뉴로 돌아가 “set strength to 0” 블록을 분홍색 “on radio received (receivedNumber)” 블록 안에 넣으세요. 그런 다음 “Radio” 메뉴로 돌아가 “received packet (signal strength)”을 선택하고, “set strength to 0”에 있는 숫자 0️ 위에다가 드롭하세요. 완료하면 작업 영역은 다음과 같이 보여야 합니다:\n변수(variable)는 정보를 저장할 수 있는 공간으로, 저장된 내용이 무엇인지 명확히 이해할 수 있도록 친숙한 이름을 붙여야 합니다. 예를 들어,strength라는 변수를 생성하면, 값을 저장할 수 있는 공간을 따로 확보하는 것입니다. 여기서 수신된 메시지로부터 측정된 신호 강도를 저장하기 위해 이 변수를 사용합니다. 이후에는 strength라는 이름을 사용하여 저장된 현재 값을 확인하거나 다른 값과 비교할 수 있습니다. 나중에 신호가 더 강해지거나 약해지는 메시지를 새로 받으면, 변수의 값이 자동으로 그 새로운 값으로 업데이트됩니다. 따라서 “on radio received” 블록은 새로운 메시지를 받을 때마다 신호 강도의 최신 값을 자동으로 업데이트하도록 설정됩니다. 이를 위해 직접 추가 작업을 할 필요는 없습니다.\n"
},
{
	"uri": "/kr/javascript-blocks-earsketch/activity-1-set-tempo-add-sounds/",
	"title": "활동 1 - 템포 설정 및 사운드 추가",
	"tags": [],
	"description": "",
	"content": "기존 코드의 내용을 자세히 살펴보고 그 의미를 이해해 봅시다.\nsetTempo() 함수는 프로젝트 전체의 템포(음악이 연주되는 속도)를 설정할 수 있도록 합니다. 프로젝트의 템포를 변경하면 다양한 스타일의 음악을 만들 수 있습니다. setTempo 함수의 숫자를 변경하여 템포를 조정해 보세요! 숫자는 45에서 220 사이여야 합니다. 아래는 사용할 수 있는 몇 가지 템포 예시입니다.\n이제 템포가 설정되었으니 사운드를 추가할 시간입니다. 이를 위해 우리는 fitMedia() 함수를 사용해야 합니다. 새로운 코드를 setTempo() 함수 블록 아래에 추가할 것입니다.\n활동 1 코드 에디터의 왼쪽에서 보라색 fitMedia() 블록을 찾으세요. fitMedia() 블록을 드래그하여 setTempo 블록 아래에 삽입합니다. 블록을 추가하면, EarSketch가 자리 표시자 텍스트(Placeholder text)를 생성하는 것을 볼 수 있습니다. 나중에 이 자리 표시자 텍스트(Placeholder text)를 교체해야 합니다. 이 자리 표시자 텍스트(Placeholder text)는 매개변수(parameters)라고도 불립니다. 각 자리 표시자 텍스트(Placeholder text)를 유효한 값으로 교체합니다.\nsound - \u0026ldquo;Sounds\u0026rdquo; 창으로 이동하여 원하는 사운드를 찾으세요. fitMedia() 함수 블록의 \u0026ldquo;sound\u0026rdquo; 부분을 클릭한 후, 추가하고자 하는 사운드 옆의 붙여넣기(Paste) 버튼을 누릅니다. 사운드의 이름이 fitMedia() 블록 안에 나타나야 합니다. trackNumber - 드롭다운(Dropdown)을 사용하여 트랙 번호를 선택하세요. 1 이상의 정수를 사용할 수 있습니다. 예시로, 1을 선택하세요. start/end - 이 매개변수는 음표를 측정하는 단위로 양의 정수를 입력해야 합니다. 시작 값(start)은 1, 끝 값end은 9로 설정해 보세요.`. 이제 코드가 아래와 같이 보일 것입니다:\nM함수 블록과 텍스트가 올바르게 배치되었는지 확인하세요.\n매개변수를 입력한 후, 실행(Run) 버튼을 누르고, 재생(Play)을 클릭하여 오디오 클립을 들어보세요!\n만약 빨간색 텍스트가 보인다면, 오류가 발생한 것입니다! 도움이 필요하면 요청하세요. fitMedia() 함수는 EarSketch에서 음악을 만드는 핵심 요소입니다. 이 함수를 많이 사용할 예정이니, 사용법에 대한 질문이 있다면 언제든지 물어보세요. 디지털 오디오 워크스테이션 (DAW)은 사운드가 나타나는 영역입니다. EarSketch 창의 상단 중앙에 위치합니다. 아래는 노래의 다른 부분이 DAW에서 어떻게 표시되는지 예시입니다.\n"
},
{
	"uri": "/kr/machine-learning/load-dataset/",
	"title": "Step 3: 데이터셋 불러오기",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "mypath를 데이터셋 파일을 추출한 폴더 경로로 변경하세요(예: C:\\fifa_dataset). 데이터가 성공적으로 불러와졌는지 확인하기 위해 describe() 함수를 사용하여 통계 정보를 출력합니다.\n# 데이터셋 불러오기 mypath = \u0026#34;C:/Users/ruilliu/Documents/nuevo_lr_fifa/\u0026#34; # 자신의 경로로 변경하세요 fifa_data = pd.read_csv(mypath+\u0026#34;data.csv\u0026#34;) fifa_data.describe() 출력 결과:\n---------------------------------------------------------------------------\rNameError Traceback (most recent call last)\r\u0026lt;ipython-input-3-f099c0f24a52\u0026gt; in \u0026lt;module\u0026gt;()\r1 # load datasets\r2 mypath = \u0026quot;C:/Users/ruilliu/Documents/nuevo_lr_fifa/\u0026quot; # change it to your own path\r----\u0026gt; 3 fifa_data = pd.read_csv(mypath+\u0026quot;data.csv\u0026quot;)\r4 fifa_data.describe()\rNameError: name 'pd' is not defined "
},
{
	"uri": "/kr/security-phishing/a-closer-look/",
	"title": "더 깊이 알아보기",
	"tags": [],
	"description": "",
	"content": "밥이 받은 이메일은 다음과 같은 내용이었어요.\n이 이메일에서 수상한 점이 무엇일까요? 함께 분석해 봅시다. 발신자의 이메일 주소가 수상하고, 이 발신자를 개인적으로 알지 못해요.\n제목에 \"Free Trip\"처럼 너무 좋은 기회라고 끌리는 내용이 들어 있어요. 보통 이런 제안은 의심해 봐야 해요.\n보통 업무 시간대가 아닌 이상한 시간에 이메일을 받았어요.\n이메일 내용이 급하게 행동하도록 재촉하는 말투를 사용하고 있어요.\n발신자가 여러분에게 클릭하라고 한 링크나 열어보라고 한 첨부 파일이 낯설어요.\r링크나 URL에 철자가 살짝 틀린 부분이(예: banana 대신 bahana) 있어요. 이런 실수는 쉽게 알아차리기 어렵답니다.\r앨리스는 이 모든 설명을 마친 후, 밥에게 안전을 위해 모든 비밀번호와 은행 계정 로그인 정보를 바꾸라고 조언했어요. 다행히도 해커인 이브가 아직 밥의 정보를 사용하지 않아서 안전했어요.\n"
},
{
	"uri": "/kr/security-fundamentals/security-vs-privacy/",
	"title": "보안 vs 개인정보 보호",
	"tags": [],
	"description": "",
	"content": "사람들은 종종 보안과 개인정보 보호를 혼동하지만, 이 두 가지 개념은 다릅니다. 이러한 차이를 이해하는 것이 중요합니다.\n보안 보안은 데이터를 무단으로 접근하지 못하게 보호하는 것입니다. 누군가가 허락 없이 데이터를 접근하지 못하게 하는 모든 조치를 보안이라고 합니다. 예를 들어:\n컴퓨터를 사용하지 않을 때 잠금 설정하기 소프트웨어 공격을 막는 프로그래밍 기술사용하기 이중 인증(2FA) 설정하기 개인정보 보호 개인정보 보호는 사용자가 원하지 않는 관심이나 감시에서 벗어날 권리를 말합니다. 주로 개인식별정보(PII)를 보호하는 것에 중점을 둡니다. 개인식별정보의 예는 다음과 같습니다:\n이메일 주소 전화번호 주소 생년월일 신용카드 정보 지문 보안과 개인정보 보호의 관계 보안은 데이터에 접근할 수 있는 사람을 제한하는 데 사용됩니다. 개인정보 보호는 어떤 종류의 정보가 접근 가능한지 통제하는 데 사용됩니다. 보안은 개인정보 보호 없이도 가능하지만, 개인정보 보호는 보안 없이는 성립될 수 없습니다.\n쉽게 말해, 보안이 먼저 있어야 개인정보 보호가 가능합니다. 예를 들어, 문이 잠겨야만 그 안에 있는 물건들을 안전하게 보호할 수 있는 것처럼 말이죠.\n예를 들어, 여러분이 은행에서 계좌를 개설할 때, 개인 정보를 은행에 제공하게 됩니다. 그 이후에 어떤 일이 벌어질 수 있을까요? 개인 정보와 관련돼 발생할 수 있는 세 가지의 상황들을 살펴보겠습니다. (계좌에 있는 돈과는 관련이 없습니다).\n개인정보와 보안이 모두 유지됨 은행은 여러분의 정보를 사용하여 계좌를 개설하고 서비스를 제공합니다. 그리고 그 데이터를 보호합니다. 개인정보는 침해되었으나 보안은 유지됨 은행이 여러분의 정보를 마케터에게 판매할 수 있습니다. 주의할 점은 은행의 개인정보 보호정책에 동의했을 가능성이 있다는 것입니다. 결과적으로, 원치 않게 더 많은 사람들이 여러분의 개인 정보를 엿보게 될 수 있습니다. 개인정보와 보안이 모두 침해됨 은행이 데이터 침해를 당합니다. 사이버 범죄자들이 은행 데이터베이스에 침입하여 보안이 뚫립니다. 그래서 여러분의 정보가 노출되어 다크 웹에서 판매될 수 있으며, 개인정보는 침해되고 사이버 사기나 신원 도용의 피해자가 될 수 있습니다. "
},
{
	"uri": "/kr/ml-machine-learning/03-confidence-intervals/",
	"title": "신뢰 구간(Confidence Interval)",
	"tags": [],
	"description": "컴퓨터가 결과를 예측하게 하는 법 알아보기.",
	"content": "이전 섹션에서, 무작위로 선택한 직원 30명의 샘플 데이터를 사용하여 선형 방정식의 기울기(Coefficient)와 절편(Intercept) 값을 구할 수 있었습니다.\n\\[\r절편=25792.20\r\\]\r\\[\r기울기=9449.96\r\\]\r\\[\r급여=9449.96(경력)+25792.20+ε\r\\]\r하지만 여기서 또 다른 질문이 생깁니다:\n급여는 정말로 직원의 경력과 관련이 있을까요? 두 변수 간의 관계가 실제로 연관성이 있다고 주장할 만큼 강한가요? 무작위로 선택한 직원 30명의 데이터만으로 이를 판단하기에 충분할까요? 이 값들이 정말로 올바른 지 어떻게 확인할 수 있을까요? 여러분은 훨씬 더 많은 직원들로 구성된 데이터에서 작은 샘플을 추출해 값을 계산했다는 것을 기억해야 합니다. 하나의 샘플만 사용했기 때문에, 기울기와 계수 값에는 불확실성이 더 클 수 있습니다. 그렇다면 이 값들이 올바른 지 확인하려면 무엇을 해야 할까요?\n답변 보기\r더 많은 무작위 샘플을 사용해 선형 모델을 실행해야 합니다.\n연습 문제 1: 더 많은 샘플 확인하기 회사 내 직원들의 데이터 10,000건 이상을 찾았다고 가정해 봅시다. 이는 매우 훌륭한 일입니다. 머신러닝에서는 데이터가 많을수록 더 나은 결과를 얻을 수 있으니까요. 이제 이 데이터셋에서 30개의 무작위 샘플을 추출하여, 원래 샘플에서 계산한 절편과 기울기 값과 비교해 보겠습니다. 아래 Replit 창에서 코드를 원하는 만큼 실행해 보세요. 실행할 때마다 절편과 기울기 값이 이전에 계산한 값과 비슷하면서도 조금씩 다르다는 것을 알 수 있을 겁니다. 왜 이런 일이 발생할까요?\nReplit 실행하기\n왜 실행할 때마다 절편과 기울기 값이 조금씩 다를까요? 왜 원래 샘플의 선(녹색 선)이 새로운 샘플의 선(파란색 선)과 비슷하면서도 다른걸까요?\n답변 보기\r그 이유는 프로그램을 실행할 때마다 무작위로 30개의 샘플이 선택되기 때문입니다. 무작위 샘플이기 때문에 값이 매번 다르지만, 다행히도 모든 값은 같은 데이터셋에서 얻어진 것입니다.\n절편(Intercept)과 기울기(Coefficient) 값이 정말로 우리가 가진 데이터를 대표한다고 확신할 수 있을까요?\n신뢰 구간 이전 예제에서 배운 점은, 더 큰 데이터셋에서 무작위 샘플을 사용할 때 절편과 기울기 값이 특정 범위 안에 들어간다는 것입니다. 우리는 실제 값이 절편과 기울기 값 사이에 있어야 한다는 것을 알지만, 그 범위가 무엇인지는 모릅니다. 이 범위를 신뢰 구간confidence interval\r이라고 부릅니다.\n연습 문제 1 의 코드를 여러 번 실행해 보면 기울기 값이 매번 조금씩 바뀌지만, 거의 항상 9000 미만으로 떨어지거나 10,000을 초과하지는 않는 것을 알 수 있습니다. 그렇다면, 여러 번 실행했을 때 가능한 모든 기울기 값의 차이는 무엇일까요? 이 차이를 표준 오류(Standard Error) 라고 부릅니다.\n표준 오류(Standard Error)\r: 표준 오류는 값이 회귀선(Regression Line)으로부터 얼마나 떨어져 있는 지의 평균 거리를 나타냅니다.\n예제 2: 표준 오류(Standard Error) 구하기 StatsModels\r라이브러리를 사용하면 선형 회귀에서 다양한 값을 얻을 수 있습니다. 아래 Replit 창에서 코드를 실행하면 다음과 같은 출력이 나타날 것입니다:\nStatsModels 실행 요약 Replit 실행하기\n표에서 표준 오류 값에 주목해 봅시다. 이 값은 stderr로 표시되어 있으며, 이번 경우에는 409.40입니다. 이 값은 무작위로 선택한 샘플 집합에서 직선의 기울기(coefficient 또는 slope)가 409.40만큼 변할 수 있다는 것을 의미합니다. 다시 말해, \u0026ldquo;직원의 급여는 $409.40 정도의 오차가 발생할 수 있다\u0026rdquo; 는 뜻입니다.\n예제 3: 정규 분포(The Normal Distribution) 잠시 돌아가서, 연습 문제 2에서 구한 기울기(cofficient 또는 slope)가 다른 샘플을 사용할 때도 반복될 가능성이 얼마나 될지 생각해 봅시다. 머신 러닝에서는 우리가 얻은 값을 결정하기 위해 통계(statistics)를 많이 활용합니다. 통계의 세계에서는 특정 값이 데이터에서 나타날 가능성을 측정하는 데 사용되는 그래프가 있습니다. 이를 정규 분포(Normal Distribution) 또는 종 모양 곡선(Bell Curve)이라고 부르며, 대략 다음과 같이 생겼습니다:\n[그림 #]: 정규 분포 또는 종 모양 곡선 다음 예를 들어 보겠습니다.\n아주 키가 작은 사람을 볼 가능성은 얼마나 될까요? 아주 키가 큰 사람을 볼 가능성은 얼마나 될까요? 이 관계를 종 모양 곡선(Bell Curve)으로 표현하면, 아래와 같은 그래프를 얻을 수 있습니다:\n[그림 #]: 정규 분포(Bell Curve)와 사람들의 키. 보다시피, 아주 키가 작은 사람이나 아주 키가 큰 사람을 볼 가능성은 매우 낮습니다. 하지만 평균 키를 가진 사람을 보는 것은 꽤 일반적입니다. 물론, 이러한 분포는 국가에 따라 다를 수 있지만, 개념은 이와 같습니다. Replit에서 코드를 실행하면 생성된 히스토그램\r이 종 모양 곡선(Bell Curve)과 비슷하다는 것을 볼 수 있습니다. 이 프로그램은 데이터셋에서 특정 값이 얼마나 자주 나타나는지를 보여주는 히스토그램을 생성합니다. 즉, 같은 급여를 받는 직원이 여러 명 있다는 것을 의미합니다.\nReplit 실행하기\n이 경우, 우리는 표준 오류(Standard Error)와 다음 공식을 사용하여 말할 수 있습니다: \u0026ldquo;기울기(coefficient)의 값이 이 범위 안에 있을 가능성이 95%입니다.\u0026rdquo; 그렇다면 이 범위는 무엇일까요? 이 범위가 바로 신뢰 구간(Confidence Interval)입니다.\n\\[\rCoefficientRange = Coefficient \\pm2 * (StdError)\r\\]\r표준 오류(Standard Error)가 409.40이라는 것을 알고 있으니, 이를 사용해 기울기의 범위를 다음과 같이 계산할 수 있습니다:\n\\[\r표준오류 = 409.40\r\\]\r\\[\r기울기 = 9449.96\r\\]\r\\[\rCoefficientRange = Coefficient \\pm 2 * StdError\r\\]\r\\[\rCoefficientRange = 9449.96 \\pm 2 * StdError\r\\]\r\\[\rCoefficientRange = [8,631.16, 10,268.76]\r\\]\r위에서 계산한 기울기(Coefficient) 범위는 다음을 의미합니다:\n\u0026ldquo;기울기 값은 8,631.16에서 10,268.76 사이에 있을 것입니다.\u0026rdquo; \u0026ldquo;직원의 1년당 급여 증가액은 8,631.16달러에서 10,268.76달러 사이입니다.\u0026rdquo; 아래 코드에서는 무작위로 100명의 직원을 샘플링하여 히스토그램을 생성하고, 이 히스토그램이 종 모양 곡선(Bell Curve)과 얼마나 유사한지 보여줍니다. 결과를 보면, 값이 기울기 범위(8,631.16에서 10,268.76)를 벗어나지 않는 것을 확인할 수 있습니다.\nReplit 실행하기\n"
},
{
	"uri": "/kr/adafruit/creating-the-program/",
	"title": "프로그램 작성하기",
	"tags": [],
	"description": "",
	"content": "가장 선호하는 인터넷 브라우저(예: Edge, Firefox, Google Chrome, Internet Explorer)를 열고 https://aka.ms/oranges\r로 이동합니다. 화면이 아래와 같이 보여야 합니다:\n변수 정의하기 오늘 우리는 오렌지를 사용하여 아다프루트가 언제 소리를 낼지 설정할 것입니다. 첫 번째 단계는 각 오렌지에 이름을 부여하고, 오렌지가 어떤 값을 전달하는지 확인할 위치를 컴퓨터에 알려주는 것입니다. 이를 위해 변수를 정의합니다. VARIABLES 섹션(담홍색, 상단에서 일곱 번째)을 클릭합니다. Make a Variable 버튼을 클릭하여 변수를 생성합니다. 두 개의 변수를 정의합니다. (예: analog1과 analog2) 원한다면 다른 이름을 사용할 수도 있습니다.\n입력값 해석하기 N이제 컴퓨터가 오렌지의 이름을 알게 되었으니, 아다프루트가 오렌지를 이해하도록 설정해야 합니다. 입력값에는 두 가지 종류가 있습니다: 디지털 입력과 아날로그 입력. 디지털 입력은 전등 스위치나 전원 버튼과 같이 켜짐(1) 또는 꺼짐(0) 상태로만 작동합니다. 아날로그 입력은 조명 조절기나 볼륨 버튼처럼 여러 값의 범위를 가질 수 있습니다. 오렌지는 아날로그 입력으로 작동하며, 만지거나 누르는 강도에 따라 아다프루트에 전달하는 값이 달라집니다.\nVARIABLES 섹션으로 다시 이동하세요. 우리가 정의한 두 변수가 이제 목록에 표시됩니다. \u0026ldquo;set ___ to __\u0026rdquo; 블록을 작업 공간의 초록색 \u0026ldquo;forever\u0026rdquo; 블록 안으로 드래그합니다. 첫 번째 빈칸을 \u0026ldquo;analog1\u0026quot;로 변경합니다.\nADVANCED를 클릭한 다음 PINS를 선택하세요. \u0026ldquo;analog read pin __\u0026rdquo; 블록(상단에서 세 번째)을 찾아 드래그하여 \u0026ldquo;set analog1 to 0\u0026rdquo; 블록의 숫자 0 부분에 넣습니다. 블록을 드래그해 숫자 0 위에 놓고, 숫자가 노란색으로 강조 표시될 때 블록을 내려놓으세요. 블록이 확장되어 새 블록을 포함할 수 있어야 합니다. 그렇지 않다면 다시 시도하세요.\n작업이 완료되면 작업 공간이 아래 그림과 같아야 합니다. 위 과정을 반복하여 이번에는 analog2와 A2를 선택하세요. 아래 그림을 확인하여 올바르게 설정했는지 확인하세요. 루프 생성하기 컴퓨터가 오렌지의 이름과 입력값을 이해할 수 있게 되었습니다. 이제 오렌지를 만졌을 때 확인할 루프를 생성해 봅시다. LOGIC 섹션으로 이동하여 \u0026ldquo;If ____ then\u0026rdquo; 블록을 가져옵니다. 그런 다음 이 블록을 변수 블록 아래에 놓습니다.\n예시로 볼륨 다이얼을 생각해봅시다. 사람마다 음악을 가장 즐길 수 있는 ‘스위트 스팟’ 볼륨이 있습니다. 이 개념은 오렌지에도 적용됩니다. 오렌지가 가만히 있을 때는 하나의 숫자를 컴퓨터에 전달합니다. 오렌지를 만졌을 때는 더 낮은 숫자를 전달합니다. 우리는 그 중간 지점을 찾아야 하며, 그렇게 하면 오렌지를 만질 때만 소리가 나도록 설정할 수 있습니다.\nLOGIC 섹션으로 이동하여 \u0026ldquo;__ \u0026lt; __\u0026rdquo; 블록을 가져옵니다. 이 블록을 \u0026ldquo;if ____ then\u0026rdquo; 블록의 \u0026ldquo;true\u0026rdquo; 부분에 놓습니다. 놓기 전에 노란색 강조 표시를 확인하세요. 아래 그림을 확인하여 블록의 위치를 올바르게 설정했는지 확인하세요.\n이제 비교하려는 값을 입력합니다. VARIABLES 섹션으로 이동하여 analog1을 가져와 첫 번째 슬롯에 넣습니다. 그런 다음 두 번째 슬롯을 클릭하고 숫자 40을 입력하세요. 이 숫자 40이 일반적으로 가장 적합한 스위트 스팟입니다 가장 적합합니다. 만약 오렌지를 만지지 않았는데도 소리가 난다면, 숫자를 더 크게 만들어 보세요. 반대로, 오렌지를 만졌는데도 소리가 나지 않는다면, 숫자를 더 작게 만들어 보세요. 현재는 이 숫자를 40으로 유지해 둡시다.\n이제 음악을 선택해 봅시다! MUSIC 섹션으로 이동하여 \u0026ldquo;play _____ until done\u0026rdquo; 블록을 가져옵니다. 그런 다음 If-Then 블록 안에 추가합니다. 아래쪽 화살표를 클릭하여 원하는 소리를 선택할 수 있습니다.\n이제 같은 과정을 analog2로 반복합니다. 이렇게 하면 작업 공간은 아래 그림과 유사하게 보일 것입니다(음악 선택은 각자 다를 수 있습니다).\n조명과 함께 즐거움 추가하기 (시간 여유가 있을 경우) 아다프루트 보드에는 다양한 LED 조명이 있습니다! 이 조명은 가지고 놀기 정말 재미있습니다. 이제 소리를 들을 때 색상도 함께 볼 수 있도록 추가해 보겠습니다. LIGHT 섹션을 클릭하여 “Set all Pixels to ___” 블록을 가져옵니다. 이 블록을 두 개의 If-Then 블록 각각에 추가합니다. play _____ until done 블록 바로 앞에 넣으세요. 색상 부분을 클릭하여 원하는 색상을 선택할 수 있습니다. 오렌지마다 다른 색상을 선택해 보면 더욱 재미있게 즐길 수 있습니다.\n"
},
{
	"uri": "/kr/security/activity/",
	"title": "활동",
	"tags": [],
	"description": "",
	"content": "게임을 해봅시다!\n아래 텍스트 상자에 당신의 가장 좋아하는 문장을 적어보세요. 반드시 다섯 단어 이상이어야 합니다.(예: I like playing volleyball at the beach.)\r이제 위 문장의 각 단어의 첫 글자를 가져와서 텍스트 상자에 적어보세요.\r(예: ilpvatb)\r텍스트에 숫자를 추가해보세요. 숫자의 위치를 기억하세요.\r(예: 1ilpvatb6)\r마지막으로, 텍스트에 특수 문자를 추가해보세요.\r(예: 1ilpv$atb6)\rVoilà(감탄), 당신의 새로운 비밀번호가 완성되었습니다! 보안을 뚫기 어려워 보이지 않나요? 성공! "
},
{
	"uri": "/kr/razor/razor-explained/",
	"title": "Razor 기초1",
	"tags": [],
	"description": "",
	"content": "Razor를 사용하는 때와 이유 알아보기 Razor Pages의 장점 Razor는 서버 기반 코드(C#)를 웹 페이지에 포함할 수 있게 해주는 마크업 구문입니다.\n서버 기반 코드는 웹 페이지가 브라우저에 쓰여지는 동안 동적인 웹 콘텐츠를 생성할 수 있습니다. 웹 페이지가 호출되면 서버는 페이지 내의 서버 기반 코드를 실행한 뒤 결과를 브라우저에 반환합니다. 서버에서 실행되므로, 데이터베이스 접근과 같은 복잡한 작업을 수행할 수 있습니다.\nRazor는 ASP.NET을 기반으로 설계되었으며, 웹 애플리케이션을 만들기 위한 도구입니다. 기존 ASP.NET 마크업의 강력함을 유지하면서도 더 쉽고 간단하게 사용할 수 있도록 설계되었습니다.\nRazor Pages의 장점\nHTML, CSS, C#을 사용하여 동적 웹 애플리케이션을 손쉽게 설정할 수 있습니다. 기능별로 정리된 파일 구조를 통해 유지보수가 용이합니다. Razor 구문을 사용해 마크업과 서버 사이드 C# 코드를 결합할 수 있습니다. Razor Pages는 Razor를 활용해 서버 기반 코드를 웹 페이지에 포함시킵니다. Razor 구문은 HTML과 C#을 결합하여 동적 렌더링 로직을 정의합니다. 이를 통해 HTML 마크업 안에서 C# 변수와 메서드를 사용해 런타임에 서버에서 동적 웹 콘텐츠를 생성할 수 있습니다. Razor Pages는 HTML, CSS, 또는 JavaScript를 대체하는 기술이 아닙니다. 대신, 이 기술들을 결합하여 동적인 웹 콘텐츠를 생성할 수 있도록 돕는 도구입니다.\nRazor Pages를 사용하는 때 다음과 같은 경우에 ASP.NET Core 애플리케이션에서 Razor Pages를 사용합니다:\n동적 웹 UI를 생성하려는 경우. 페이지 중심(page-focused) 접근 방식을 선호하는 경우. Partial Views를 사용하여 중복을 줄이고자 하는 경우. Razor Pages는 관련된 페이지와 로직을 동일한 네임스페이스와 디렉터리에 함께 배치함으로써 ASP.NET Core 페이지 구조를 간소화합니다.\n"
},
{
	"uri": "/kr/java-tictactoe/activity-3/",
	"title": "3. 게임판 업데이트하기",
	"tags": [],
	"description": "컴퓨터의 움직임 생성 및 보드 업데이트하기",
	"content": "이전 단계에서는 사용자의 유효한 입력을 받아 게임판을 출력하는 프로그램을 만들었습니다. 하지만 게임판은 여전히 비어 있습니다. 이번 단계에서는 사용자의 입력을 받아 게임판을 업데이트하고, 컴퓨터의 랜덤한 움직임도 추가하는 방법을 배웁니다.\n\u0026lt;\u0026lt;\u0026lt;~ 틱택토~\u0026gt;\u0026gt;\r* 1번 - 9번을 선택하여 이동합니다\r* 플레이어: \u0026#39;X\u0026#39; 컴퓨터: \u0026#39;O\u0026#39;\r1 | 2 | 3\r---+---+---\r4 | 5 | 6\r---+---+---\r7 | 8 | 9\r당신의 이동을 입력하세요 (1-9): 1\r| |\r---+---+---\r| | \u0026lt;--------------------- 보드에 플레이어/컴퓨터 이동이 없습니다\r---+---+---\r| |\r당신의 이동을 입력하세요 (1-9): d\r잘못된 입력; 이동을 다시 입력합니다 (1-9): 3\r| |\r---+---+---\r| | \u0026lt;--------------------- 보드에 플레이어/컴퓨터 이동이 없습니다\r---+---+---\r| |\r당신의 이동을 입력하세요 (1-9): 사용자 움직임 표시하기 hasNextInt() 조건문 안에서, printBoard(board) 메서드를 호출하기 전에 사용자가 입력한 값을 기반으로 board 배열을 업데이트합니다.\n플레이어는 게임판에서 **\u0026ldquo;X\u0026rdquo;**로 표시된다는 점에 유의하세요.\n알림 Java는 0부터 시작하는 인덱싱(0-indexing)을 사용합니다. 하지만 플레이어는 1부터 9까지의 숫자를 입력하도록 요청받았습니다. 배열의 요소에 접근하려면 인덱스 표기법을 사용해야 합니다: myVariable[indexNumber].\n컴퓨터의 움직임 설정하기 컴퓨터가 유효한 위치에 말을 놓는 동작을 구현하기 위해 **getComputerMove(String[] curBoard)**라는 새로운 메서드를 만들어봅시다.\n이 메서드는 1에서 9까지의 유효한 위치 중 하나를 선택하여 컴퓨터의 말을 놓습니다. 다음 단계에서 이 메서드를 구현하는 방법을 설명합니다.\n컴퓨터의 움직임 구현하기 getComputerMove() 메서드 안에서 1에서 9까지의 숫자를 랜덤으로 생성합니다. 이를 위해 자바에서 자주 사용되는 Random 클래스를 사용할 것입니다. 이 클래스를 사용하려면 파일 상단에 다음과 같은 코드를 작성하여 Random 클래스를. 임포트(import)합니다.\nimport java.util.Random; 생성자를 Random()이라고 불러 Random 객체를 만듭니다.\nRandom rand = new Random(); 랜덤 숫자 생성 생성한 Random 객체에서 int nextInt(int num) 메서드를 호출하여 1부터 9까지의 숫자를 무작위로 생성할 수 있습니다.\nint nextInt(int num) 메서드는 0부터 num-1까지의 랜덤 숫자를 반환합니다. 따라서 1부터 9까지의 숫자를 얻으려면 반환값에 1을 더해야 합니다.\nint position = rand.nextInt(9); 유효한 움직임 확인 랜덤하게 1부터 9 사이의 숫자를 생성한 후, 해당 위치가 사용 가능한지 확인해야 합니다.\n만약 이미 사용 중인 위치라면, while 루프를 사용해 유효한 움직임이 나올 때까지 새로운 랜덤 숫자를 계속 생성합니다.\n이 과정이 끝나면 컴퓨터의 유효한 위치가 결정됩니다. 그 위치를 반환합니다\nwhile (!curBoard[position].equals(\u0026#34; \u0026#34;)){ position = rand.nextInt(9); } return position; 게임판 배열 업데이트하기 1단계와 마찬가지로 \u0026lsquo;printBoard(보드)\u0026lsquo;라는 메서드를 사용하기 전에 컴퓨터의 board 배열을 업데이트해야 합니다.\n무작위로 \u0026lsquo;getComputerMove()\u0026lsquo;를 호출하여 이동을 생성합니다!\n컴퓨터는 게임 보드에서 \u0026lsquo;O\u0026rsquo;로 표시된다는 점에 유의하세요.\nboard[getComputerMove(board)] = \u0026#34;O\u0026#34;; //getComputerMove returns the integer 0-8 that is the proper position in the array printBoard(board); Run the Program 지금 프로그램을 \u0026lsquo;실행\u0026rsquo;(Run) 하세요! 보드는 아래와 같이 각 입력으로 플레이어와 컴퓨터의 움직임을 올바르게 업데이트해야 합니다:\n\u0026lt;\u0026lt;\u0026lt;~ 틱택토~\u0026gt;\u0026gt;\r* 1번 - 9번을 선택하여 이동합니다\r* 플레이어: \u0026#39;X\u0026#39; 컴퓨터: \u0026#39;O\u0026#39;\r1 | 2 | 3\r---+---+---\r4 | 5 | 6\r---+---+---\r7 | 8 | 9\r당신의 이동을 입력하세요 (1-9): 1\rX | |\r---+---+---\r| |\r---+---+---\r| O |\r당신의 이동을 입력하세요 (1-9): 1\r잘못된 위치; 이동을 다시 입력하세요 (1-9): 2\rX | X |\r---+---+---\r| | O\r---+---+---\r| O |\r당신의 이동을 입력하세요 (1-9): 모든 것이 잘 작동하는 것 같습니다! 게임의 승자와 패자만 결정하면 다음 활동에서 구현할 수 있습니다!\n"
},
{
	"uri": "/kr/supply-chain-analytics/solverandsolving/",
	"title": "문제 해결하기",
	"tags": [],
	"description": "",
	"content": "Excel에서 최적화 문제를 실행하려면 “Solver”라는 추가 기능을 활성화해야 해요. 자세한 내용은 아래 링크나 이미지를 참조하세요.\n문제를 해결하는 방법이 어려우면, 이곳\r에서 도움을 받을 수 있어요.\nSolver 추가 기능은 Excel의 “Data” 탭에서 “Solver”를 클릭하면 사용할 수 있어요.\n다음 템플릿\r을 다운로드하여 문제 설정을 따라가 보세요.\nSolver를 사용할 때는 셀 번호와 셀 간의 관계만 선택하면 돼요. Excel 사용이 익숙하지 않은 경우, 선생님께 도움을 요청하세요.\n정답을 확인하려면 “답안” Excel 파일을 사용할 수 있어요. 또한, Solver를 올바르게 설정하는 방법의 스크린샷도 있어요.\n정답\r행운을 빌어요!\n"
},
{
	"uri": "/kr/jsappybird/jump-force/",
	"title": "새가 힘차게 점프하고 회전하면서 떨어지도록 만들기",
	"tags": [],
	"description": "",
	"content": "이번에는 새가 더 힘차게 점프할 수 있게 해 봅시다.\n파일 [File: create-game.js] 에 다음 명령을 추가하세요. bird.body.velocity.y = -350;\n함께 해보기 아래 Replit 창에서 코드는 bird.body.velocity.y = -350;로 시작합니다.\nrun 을 누르면, 콘솔에 새가 힘차게 점프하는 모습이 나타납니다:\n보너스 활동 새가 위로 점프하면서 앞으로 나아가도록 만들어 봅시다:\n파일 [File: create-game.js] 에 다음 명령을 추가하세요. bird.body.velocity.x = 100;\n새가 회전하면서 떨어지도록 만들기 새에게 회전 효과를 추가해 봅시다:\n파일 [File: update-game.js] 에 다음 명령을 추가하세요. if (bird.angle \u0026lt; 50) { bird.angle += 1; }\n설명: “if”는 조건 블록으로, 여기서는 새의 각도를 확인하여, 각도가 50보다 작을 때 각도를 1씩 증가시키는 코드를 실행합니다. -bird.angle+=1;\n함께 해보기 아래 Replit 창에서 코드는 bird.angle +=1;로 시작합니다.\nrun 을 누르면, 콘솔에 새가 회전하면서 떨어지는 모습이 나타납니다:\n"
},
{
	"uri": "/kr/secret-messages/activity-3/",
	"title": "Activity 3 - 반복문 (Loops)",
	"tags": [],
	"description": "",
	"content": "\n좋아요!\n이제 왕께서 메시지를 문자를 통해 입력하도록 요청하셨습니다. 나중에 메시지를 수정할 수 있도록 하기 위함입니다.\n이를 위해 **반복문(Loop)**이라는 것을 사용해야 합니다. 반복문은 특정 코드 블록을 여러 번 실행할 수 있게 합니다. 아래의 예제를 살펴보세요. 이 코드는 반복문을 사용하여 숫자를 출력합니다.\nfor(int i=0; i\u0026lt;3; i++){\rcout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;\r} Let\u0026rsquo;s try to understand what this line of code does.\n반복문(Loops) for(int i=0; i\u0026lt;3; i++) { } 이 코드는 중괄호 {} 안에 있는 명령어를 반복문(loop)으로 실행하도록 프로그램에 지시합니다. 이 명령어에는 세 가지 주요 부분이 있습니다:\nint i=0; o\ti라는 이름의 정수형(int) 변수를 선언하고, 초기값을 0으로 설정합니다. o\t이 변수는 반복문 안에서 우리가 몇 번 반복했는지 세는 카운터(counter) 역할을 합니다. i\u0026lt;3; o\t반복문이 계속 실행되려면 이 조건이 참(true)이어야 합니다. o\t예제에서는 i의 값이 3보다 작을 때 반복문이 실행됩니다. i++ o\t반복문이 한 번 실행된 후, i에 1을 더합니다. o\t이 방식은 명령어를 지정된 횟수(이 경우 3번)만큼 반복할 때 자주 사용됩니다. string 변수의 속성은 문자열의 문자 수를 셀 수 있다는 것입니다.\n문자열에서 각 문자에 접근하기 문자열(string) 변수의 속성 중 하나는 문자열에 포함된 문자(character) 개수를 셀 수 있다는 것입니다. 문자열의 각 문자는 char라고 하며, 문자열 안에서의 위치를 사용해 접근할 수 있습니다. 문자열을 문자들의 리스트로 생각해 봅시다: •\t첫 번째 문자는 위치 0에 있습니다. •\t두 번째 문자는 위치 1에 있습니다. •\t세 번째 문자는 위치 2에 있습니다. •\t이런 식으로 계속됩니다.\n다음 코드는 각 문자에 접근하는 방법을 보여줍니다:\nstring word = \u0026#34;hello\u0026#34;;\rchar letter = word[0];\rcout \u0026lt;\u0026lt; \u0026#34;The first letter is: \u0026#34; \u0026lt;\u0026lt; letter \u0026lt;\u0026lt; endl; This would print:\nThe first letter is: h 문자열의 길이 확인하기 문자열의 각 문자에 접근하는 것 외에도, 문자열의 길이를 알 수 있습니다. 이를 위해 아래 코드를 사용할 수 있습니다:\nstring word = \u0026#34;hello\u0026#34;;\rint wordSize = word.size();\rcout \u0026lt;\u0026lt; \u0026#34;The size is: \u0026#34; \u0026lt;\u0026lt; wordSize \u0026lt;\u0026lt; endl; This would print:\nThe size is: 5 이제 우리가 작성한 코드를 수정하여 hello 대신 입력된 이름의 각 문자를 출력하도록 만들어 봅시다.\nReplit 실행하기\n"
},
{
	"uri": "/kr/microbit-distance-checker/signal-strength/",
	"title": "신호 강도 해석하기",
	"tags": [],
	"description": "",
	"content": "이제 마이크로빗이 수신한 신호 강도를 알게 되었으니, 이를 사용하여 거리를 계산해 봅시다. Logic 섹션을 클릭한 뒤 “if true then / else” 블록을 가져와 radio received 블록 안으로 끌어다 놓습니다. 그런 다음 Logic 섹션으로 돌아가 “0 = 0” 비교 블록을 가져와 “if true then” 라인의 true 부분 위에 드롭하세요. 이 단계가 끝나면 코드가 아래와 같이 보여야 합니다:\n이제 마이크로빗이 우리가 6피트(약 2미터) 이상 떨어져 있는지 확인하는 방법을 설정해 봅시다. Variables 메뉴를 열고 strength 버블을 선택한 뒤, 이를 if 블록의 첫 번째 0 위에 드롭하여 if strength = 0 then로 변경하세요. 그런 다음, 등호(=) 기호를 클릭하여 다른 기호들의 목록을 표시합니다. 여기에서 “\u0026gt;” 기호를 선택하세요. 마지막으로, if 문 안의 마지막 0을 클릭하여 `-67로 바꿔줍니다. 완성된 “on radio received” 블록은 다음과 같이 보여야 합니다:\n여러분은 여기서 궁금증이 생길 것입니다: 왜 -67인가요? “무작위로 선택된 숫자처럼 보이는데?” -67 dBm(데시벨 밀리와트)은 마이크로빗 두 대가 6피트 떨어져 있을 때 측정된 신호 강도 값입니다. 블루투스 라디오의 종류에 따라 동일한 거리에서도 신호 강도가 다를 수 있습니다. 예를 들어, 스마트폰 블루투스의 경우 신호 강도가 다르게 나타날 수 있습니다. 신호 강도가 0에 가까울수록 더 강하며, 이는 다른 라디오에 더 가까이 있다는 것을 의미합니다. 반대로 신호 강도가 0에서 멀어질수록 신호는 약해지고, 거리가 멀다는 뜻입니다.\n따라서, 수신한 신호 강도가 -67 dBm보다 강하다면 (strength \u0026gt; -67), 두 마이크로빗 간의 거리는 6피트 미만이라는 뜻입니다. 반대로 신호 강도가 약하면 마이크로빗 간 거리는 6피트 이상입니다.\n"
},
{
	"uri": "/kr/javascript-blocks-earsketch/activity-2-make-a-song/",
	"title": "활동 2 - 곡 만들기!",
	"tags": [],
	"description": "",
	"content": "이제 EarSketch에 사운드를 추가하는 방법을 배웠으니, 곡을 만들어봅시다! 이미 EarSketch에 하나의 오디오 클립이 추가된 상태일 것입니다. 하지만 곡은 여러 악기로 구성되므로, 더 많은 오디오 클립을 추가해야 합니다.\nfitMedia() 블록을 하나 더 추가하세요. 현재 곡에 추가할 오디오 클립을 찾아서 sound 매개변수에 넣으세요. track 매개변수는 고유한 숫자여야 합니다. 이렇게 하면 다른 트랙에 사운드를 배치할 수 있습니다. 다른 트랙에 사운드를 배치하면 각 사운드를 체계적으로 관리할 수 있으며, 동시에 다양한 사운드를 재생할 수 있습니다. 예시: 첫 번째 fitMedia() 호출이 1번 트랙에 있다면, 두 번째 fitMedia() 호출은 2번 트랙에 있어야 합니다. 나머지 매개변수들도 완성하세요. 이 단계를 반복하여 네 개의 서로 다른 오디오 사운드를 곡에 추가하세요. 이제 코드가 아래와 같이 보일 것입니다::\n"
},
{
	"uri": "/kr/guidelines/web-developer/",
	"title": "웹 개발자 가이드라인(Web Developer Guidelines)",
	"tags": [],
	"description": "",
	"content": "이 문서는 Nuevo Foundation 워크숍 프로젝트\r의 템플릿과 스타일을 변경하려는 웹사이트 개발자 전용입니다.\n시작하기 전에 웹사이트를 추가하거나 업데이트하기 전에 프로젝트 팀과 동기화를 맞추고 프로젝트 백로그(Project Backlog)\r내 기존 작업을 확인하세요.\n설치 프로젝트를 로컬에서 테스트하기 위해 시작하기(Getting Started)\r페이지의 지침에 따라 Git과 Hugo를 설치하세요.\n웹 디자인 스타일과 구조 이미지(images) 웹사이트 이미지 파일은 themes/images에 저장해야 합니다. CSS SCSS 파일은 무시하고 /themes/docdock/static/css/파일만 사용하세요. 필요한 CSS를 head.html파일 안 /themes/docdock/layouts/partials/flex/head.html 파일의 태그에 참조로 추가하세요. 워크숍 페이지 분석 전체 페이지 템플릿(Full page template): 헤더, 메뉴, 본문, 푸터를 포함한 페이지의 모든 구성 요소를 확인하려면 /themes/docdock/layouts/_default/baseof.html 파일을 참조하세요. 헤드(Head): 메타 정보, CSS, 및 JS 파일은 /themes/docdock/layouts/partials/flex/head.html 파일에서 확인하세요. 상단/메뉴 내비게이션(Top/Menu Navigation): docDock config.toml 값을 사용하지 마세요., 대신 /themes/docdock/layouts/partials/flex/body-before-content.html 파일에서 HTML을 추가하거나 수정하세요. 왼쪽 메뉴(Left Menu): /themes/docdock/layouts/partials/flex/menu.html 파일을 참조하세요. 푸터 내비게이션(Footer Navigation): /themes/docdock/layouts/partials/flex/body-after-content.html 파일을 참조하세요. 메타데이터 박스(Metadata Box): /themes/docdock/layouts/partials/flex/body-after-content.html 파일을 참조하세요. 도움말: CSS가 사라졌어요! Hugo의 주요 매개변수 중 하나는 baseURL 변수입니다. 콘텐츠는 로드되지만 CSS가 로드되지 않는다면 baseURL 설정의 문제일 가능성이 큽니다. 콘텐츠를 빌드할 때 config.toml 파일을 변경하는 대신 baseURL을 설정할 수 있습니다. 아래 예시는 CSS와 JS를 최적화하고 baseURL을 프로덕션 URL로 설정하여 public 디렉터리에 결과를 복사하는 방법입니다.\nconfig.toml 파일을 직접 수정하지 않고도 콘텐츠를 만들 때 baseURL을 변경할 수 있습니다. 아래 예시는 CSS와 JS 파일을 축소하고, baseURL을 프로덕션 .org URL로 설정하며, 결과를 public 디렉토리에 복사하는 과정을 보여줍니다.\nhugo --minify --baseURL \u0026quot;https://workshops.nuevofoundation.org/\u0026quot;\n팁과 요령(Tips \u0026amp; Tricks) Public 디렉터리 무시(Ignore Public): 기본적으로 hugo를 매개변수 없이 실행하면 사이트가 public 디렉터리에 빌드됩니다. public 디렉터리를 소스 제어에 추가하지 않도록 하세요 (현재 gitignore에 포함되어 있습니다). 왼쪽 탐색(Left Nav): 파일의 메타데이터에 hidden: true를 설정하여 왼쪽 탐색에서 콘텐츠를 숨길 수 있습니다 (이 워크숍의 index.md 마크다운 파일처럼!). 파셜(Partials): 페이지에 재사용 가능한 구성 요소를 추가하려면 /themes/docdock/layouts/partials/flex/디렉터리에 새 파셜 파일을 만드세요. "
},
{
	"uri": "/kr/machine-learning/preprocess-data/",
	"title": "Step 4: 데이터 전처리하기",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "이전 스텝을 통해 데이터셋을 불러왔습니다. 실제 상황에서는 각 축구 선수는 특정한 포지션을 가지고 있으며, 각 포지션마다 필요한 능력치가 다릅니다. 그래서 우리는 이제 분석 범위를 스트라이커(ST)로 좁혀보겠습니다.\n먼저, 모든 포지션을 나열해 봅시다. 명령어가 조금 길긴 합니다. 하지만 잘 따라해주세요. fifa_data['Position']은 fifa_data의 포지션 열을 선택하고, dropna()는 빈 셀을 제거하며, unique()는 모든 중복 항목을 제거해 줍니다.\n# 포지션이 몇 개인지 확인하기 print(fifa_data[\u0026#39;Position\u0026#39;].dropna().unique()) 출력 결과는 다음과 같습니다:\n['RF' 'ST' 'LW' 'GK' 'RCM' 'LF' 'RS' 'RCB' 'LCM' 'CB' 'LDM' 'CAM' 'CDM'\r'LS' 'LCB' 'RM' 'LAM' 'LM' 'LB' 'RDM' 'RW' 'CM' 'RB' 'RAM' 'CF' 'RWB'\r'LWB']\r이제 \u0026ldquo;ST\u0026rdquo; 포지션을 기준으로 데이터를 필터링 해보겠습니다. 여러분은 다른 포지션을 선택해서 차이를 확인해 보길 권장합니다.\n# 포지션이 \u0026#39;ST\u0026#39;인 선수 필터링 fifa_data_by_pos = fifa_data[fifa_data[\u0026#39;Position\u0026#39;]==\u0026#39;ST\u0026#39;] 다음으로, 모든 스트라이커의 종합 능력치에 대한 히스토그램을 그려봅시다.\n# 모든 스트라이커의 종합 능력치 히스토그램 그리기 plt.hist(x=fifa_data_by_pos[target], bins=10, alpha=0.75, rwidth=0.85) 히스토그램 출력 결과는 다음과 같습니다:\n(array([ 40., 186., 363., 463., 601., 341., 113., 34., 9., 2.]),\rarray([47. , 51.7, 56.4, 61.1, 65.8, 70.5, 75.2, 79.9, 84.6, 89.3, 94. ]),\r\u0026lt;a list of 10 Patch objects\u0026gt;)\r다음으로, 데이터를 두 개의 세트로 나누고자 합니다. 하나는 모델을 훈련하는 데 사용할 테스트용이고, 다른 하나는 훈련된 모델이 좋은지 검증하는 데 사용할 훈련용입니다. 여러분은 모델을 더 잘 훈련하기 위해 가능한 많은 데이터를 훈련용 데이터에 남겨야 한다고 생각할 수도 있습니다. 그렇게 한다면 훈련 데이터는 모델에 아주 적합해질 것입니다. 하지만 주의할 점은 그렇게 한다면 모델을 테스트 데이터에 적용할 때는 예측 정확도가 낮아질 수 있습니다. 이를 과적합(overfitting) 이라고 부릅니다.\n따라서 25%의 데이터만 테스트용으로 남기겠습니다.\n# 데이터를 훈련용 데이터와 테스트용 데이터로 무작위로 나누기 # test_size 비율을 변경하여 어떤 결과가 나오는지 확인해 보세요 train_data, test_data = train_test_split(fifa_data_by_pos,test_size=0.25) # 훈련용 데이터와 테스트용 데이터에 포함된 선수 수 출력 # len()은 숫자 형식으로 선수 수를 반환하고, # str()은 숫자를 문자열로 변환합니다 print(\u0026#34;The # of training data is \u0026#34; + str(len(train_data))) print(\u0026#34;The # of testing data is \u0026#34; + str(len(test_data))) 출력 결과:\nThe # of training data is 1614\rThe # of testing data is 538 "
},
{
	"uri": "/kr/ml-machine-learning/04-model-fit/",
	"title": "모델 적합도",
	"tags": [],
	"description": "",
	"content": "우리가 만든 모델이 데이터를 잘 설명할까요? 우리가 만든 선형 방정식은 랜덤 오류 값(ε)을 포함하고 있습니다:\n\\[\r급여 = 9449.96(경력) + 25792.20 + ε\r\\]\rε는 우리가 정확히 알 수 없는 오류 값입니다. 그래서 다음과 같은 질문을 해봐야 합니다:\n우리의 모델이 현실을 얼마나 잘 반영하나요? 또는 모델이 우리가 가진 데이터를 얼마나 잘 설명하나요? 경력이 정말로 급여에 영향을 미치는지 어떻게 알 수 있을까요? 이를 알아내는 방법은 여러 가지가 있지만, 머신 러닝과 통계의 세계에서는 이를 평가할 수 있는 R-제곱(R-Squared 또는 R^2)이라는 값을 사용합니다.\nR-제곱(R-Squared, R^2)\r: R-제곱은 모델의 적합도를 나타내는 측정값입니다. 회귀 분석에서는 회귀선이 실제 데이터를 얼마나 잘 근사 하는지를 통계적으로 평가하는 척도입니다. 간단히 말해, R^2 값이 1에 가까울수록 우리가 선택한 수학적 모델이 데이터를 잘 설명하고, 실제 값을 정확히 예측할 가능성이 높다는 뜻입니다.\n연습 문제 1: R-제곱(R-Squared) 찾기 Experience_vs_Salary-More_Data 파일에는 회사 직원 10,000명 이상의 경력과 급여 데이터가 포함되어 있습니다. 아래 Replit 코드를 실행하면, 처음 선택된 직원 30명의 샘플로부터 표준 오류와 R-제곱(R²) 값을 계산합니다.\nReplit 실행하기\n결과를 보면, R2 값이 0.973로 나타납니다. 이 값을 통해 \u0026ldquo;직원의 경력이 급여와 관련이 있을 확률이 97.3%이다\u0026quot;라고 자신 있게 말할 수 있습니다. 또한, 샘플 크기(sample_size) 변수를 더 크게 또는 더 작게 변경하여 R2 값이 어떻게 변하는지 확인해 보세요. 이제 예측을 시작해 봅시다!\n"
},
{
	"uri": "/kr/security-fundamentals/cyber-security-cause--effect/",
	"title": "사이버 보안의 원인과 결과",
	"tags": [],
	"description": "",
	"content": "사이버 보안 실천은 단순히 온라인 사기에 넘어가지 않는 것 이상입니다. 사용자가 흔히 간과하고 해커들이 악용하는 일반적인 위험 요소들은 무엇일까요?\n이중 인증(2FA)을 설정하지 않음 소셜 미디어, 은행, 게임 계정 등에 로그인할 때 이중 인증을 활성화하지 않으면 해커들이 쉽게 비밀번호를 알아채서 나도 모르게 로그인할 수 있습니다.\n이중 인증(2FA) 설정하기 이중 인증(2FA)은 로그인할 때 두 가지 방법으로 본인을 증명하는 절차를 말합니다. 이 기능은 누군가가 여러분의 비밀번호를 훔치거나 추측하더라도 계정에 로그인할 수 없도록 보호해줍니다.\n이중 인증은 보안 침해가 발생하기 전에 설정해야 합니다. 대부분의 계정은 처음 생성할 때 이 설정을 요구하지만, 설정하지 않았다면 계정 설정 페이지에서 설정할 수 있습니다. 전화번호나 이메일 주소를 제공하여 본인 확인 방법을 등록하면, 인증 메시지를 받을 수 있는지 확인하는 확인 메시지가 전송됩니다.\n이중 인증이 활성화되면 로그인 시도 시 제공된 이메일이나 전화번호로 인증 메시지가 발송되어 로그인하는 사람이 실제로 본인인지 확인할 수 있습니다. 로그인할 때 휴대폰을 준비해두세요!\n비밀번호 재사용 (여러 사이트에서 같은 비밀번호 사용하기) 비밀번호가 한 번 유출되면, 해커가 그 비밀번호로 다른 사이트의 계정에도 쉽게 접속할 수 있습니다.\n비밀번호 관리자 사용하기 비밀번호 관리자는 여러 비밀번호를 안전하게 저장해 주는 프로그램입니다. 이렇게 하면 다음과 같은 장점이 있습니다:\n여러 계정의 비밀번호를 일일이 기억하지 않고, 비밀번호 관리자에 로그인하는 하나의 비밀번호만 기억하면 돼요. 보안에 강한 비밀번호를 만들어도, 매번 입력할 필요 없이 복사해서 붙여넣기할 수 있어요. 대부분의 비밀번호 관리자는 안전한 비밀번호를 추천해 줍니다. 즉, 쉽게 뚫리지 않는 비밀번호를 만들 수 있어요. 비밀번호 관리자 프로그램은 여러 가지가 있으며, 일부는 웹 브라우저에 기본으로 설치되어 있답니다!\n"
},
{
	"uri": "/kr/security/spy-game/",
	"title": "스파이 게임",
	"tags": [],
	"description": "",
	"content": "지난 활동에서 우리는 강력한 비밀번호가 무작위 문자 조합(대문자와 소문자, 숫자 및 일부 특수 문자가 포함될 수 있음)으로 이루어져 있다는 것을 배웠습니다. 이제 \u0026ldquo;해킹 가능\u0026rdquo; 또는 \u0026ldquo;안전\u0026rdquo; 게임을 해볼 시간입니다! 우리 누비의 비밀번호 목록에서 이브가 해킹할 수 없는 가장 강력한 비밀번호를 선택하세요.\n이 비밀번호는 해킹될 수 있습니까?\rYes\rNo\r이 비밀번호는 해킹될 수 있습니까?\rYes\rNo\r이 비밀번호는 해킹될 수 있습니까?\rYes\rNo\r이 비밀번호는 해킹될 수 있습니까?\rYes\rNo\r축하합니다! 해내셨어요! 아래 버튼을 클릭하여 정답을 확인하세요. 정답 "
},
{
	"uri": "/kr/security/summary/",
	"title": "요약",
	"tags": [],
	"description": "",
	"content": "강력한 비밀번호의 특징은 다음과 같습니다: 최소 8자 이상 - 문자가 많을수록 좋습니다. 문자와 숫자의 혼합 적어도 하나의 특수 문자를 포함해야 합니다. 예: ! @ # ? ] 주의: 비밀번호에 \u0026lt; 또는 \u0026gt;를 사용하지 마세요. 이 두 기호는 웹 브라우저에서 문제를 일으킬 수 있습니다. 보안이 강력한 비밀번호는 추측하기 어렵지만, 당신이 기억하기 쉬워야 합니다. 적어 두어야 하는 비밀번호는 강력하지 않습니다.\n해답 우리의 스파이 게임에서 “Ilovemypet” 비밀번호는 숫자와 특수 문자가 포함되어 있지 않으며, “12345678”은 숫자의 시퀀스입니다. 따라서 두 비밀번호 모두 약하며 해킹 될 수 있습니다.\n"
},
{
	"uri": "/kr/adafruit/downloading-your-program/",
	"title": "프로그램 다운로드하기",
	"tags": [],
	"description": "",
	"content": "작업 공간 하단에서 프로그램 이름 옆에 있는 밝은 분홍색 [Download] 버튼을 찾을 수 있습니다. 프로그램 이름을 지정하세요. 여기서는 예시로 adafruit_musicalfruit라고 이름을 붙였습니다. [Download] 버튼을 클릭합니다.\n파일 저장 위치를 묻는 창이 나타나면 Downloads 폴더를 선택하세요. 기본적으로 Downloads 폴더로 설정되어 있을 것입니다. 그렇지 않은 경우, Downloads 폴더로 이동하여 저장하세요.\n이제 컴퓨터에 USB 케이블을 연결하세요. 연결하면 무지개색 조명이 나타날 것입니다. 이는 보드가 기본 프로그램을 실행 중임을 의미합니다. 이 기본 프로그램을 우리 프로그램으로 교체할 것입니다. 보드 중앙의 작은 리셋 버튼을 누르세요. 조명이 빨간색으로 바뀐 후 초록색으로 바뀌면 준비 완료입니다. 만약 조명이 초록색으로 바뀌지 않는다면, 리셋 버튼을 빠르게 두 번 클릭한 후 몇 초 동안 기다려 보세요.\n조명이 초록색으로 바뀌면, Windows 탐색기(Windows Explorer) 창을 엽니다. 자동으로 열리지 않을 경우 직접 실행하세요. 이제 CPLAYBOOT 드라이브가 표시되어야 합니다. 여기서는 D: 드라이브로 나타나 있지만, E:, F: 등 다른 이름으로 나타날 수도 있습니다.\nCPLAYBOOT 드라이브를 확인한 후, Downloads 폴더로 이동하여 저장한 파일을 찾으세요. 그 파일을 클릭한 후 CPLAYBOOT 위로 드래그하세요. 드래그하는 동안 “→ Move to CPLAYBOOT”라는 메시지가 나타나야 합니다. 파일을 놓아 CPLAYBOOT에 복사하세요.\n파일을 올바른 위치에 복사한 후, 초록색 조명이 꺼질 것입니다. 이는 프로그램이 성공적으로 아다프루트(Adafruit)에 업로드되었음을 나타냅니다!\n축하합니다! 여러분은 모든 과정을 성공적으로 완료했습니다. 더 궁금하다면 다시 돌아가 소리나 비교값(매직 넘버)을 조정하며 실험해 보세요.👏🏽👏🏽👏🏽 "
},
{
	"uri": "/kr/security-phishing/other-phishing-types/",
	"title": "피싱에 대해 더 배우기",
	"tags": [],
	"description": "",
	"content": "앨리스는 이메일 피싱 외에도 다른 종류의 피싱 사기들을 밥에게 설명해 주었어요.\n스미싱(SMS 피싱) 스미싱은 문자 메시지를 이용한 피싱이에요. 해커가 문자 메시지(SMS)를 통해 링크를 보내서, 사용자가 클릭하도록 유도해 개인 정보를 빼앗으려 해요. 예를 들어, 무료 iPad 제공 같은 메시지로 유혹하여 사용자가 링크를 누르게 만들죠.\n위의 이미지에서 알 수 있듯이, 모르는 사람이 iPad 무료 제공에 관한 메시지를 보내 클릭하도록 유도하고 있어요.\n멀버타이징(Malvertising) 멀버타이징은 악성 광고로, 컴퓨터에 원하지 않는 콘텐츠를 강제로 띄우거나 악성 프로그램을 설치하도록 유도하는 광고예요.\n위의 이미지에서는 악성 광고가 진짜 웹사이트에 섞여 있는 모습을 볼 수 있어요. 이 광고는 사용자가 다운로드 버튼을 클릭하게 해서, 컴퓨터에 바이러스나 악성 소프트웨어를 설치하도록 유도해요.\n검색 엔진 피싱 일부 피싱 사기는 검색 엔진을 통해 이루어져요. 사용자가 값싼 제품이나 서비스를 제공하는 사이트로 유도되죠. 사용자가 제품을 사려고 신용카드 정보를 입력하면, 피싱 사이트가 그 정보를 가져가요. 가짜 은행 웹사이트나 가짜 상품 광고도 사용자들이 악성 링크를 클릭하도록 유도하는 방법이에요.\n많은 검색 엔진은 검색 결과에 광고 링크를 우선으로 보여줍니다. 링크를 클릭하기 전에 해당 링크가 정상적인 사이트인지 꼭 확인하세요. 위 이미지에서처럼 악성 사이트로 갈 위험이 있기 때문이에요.\n"
},
{
	"uri": "/kr/chatbot/activity-1/",
	"title": "활동 1: ALICE 만나기",
	"tags": [],
	"description": "",
	"content": "ALICE 만나기 챗봇만들기를 시작하기 전에, ALICE와 만나서 몇 가지 질문을 해보겠습니다. 이 웹페이지를 열어둔 채로 진행해 주세요.\nALICE 사용해보기\nALICE에 대해 어떻게 생각하시나요?\nALICE가 대답할 수 있었던 질문은 무엇인가요?\nALICE가 대답하지 못했던 질문은 무엇인가요?\n"
},
{
	"uri": "/kr/razor/razor-syntax/",
	"title": "Razor 기초2",
	"tags": [],
	"description": "",
	"content": "Razor 구문 Razor 구문의 주요 규칙 Razor는 C#을 지원하며, HTML에서 C#으로 전환하기 위해 @ 기호를 사용합니다. Razor는 C# 표현식을 평가한 후, 이를 HTML 출력에 렌더링 합니다.\n@ 기호와 Razor 전환\n@ 기호 뒤에 Razor 예약 키워드가 올 경우: Razor 전용 마크업으로 전환됩니다. 그렇지 않은 경우: 일반 HTML로 간주됩니다. @ 기호 이스케이프 처리\nRazor 마크업에서 @ 기호를 출력하려면 한 번 더 @를 사용합니다.\n\u0026lt;p\u0026gt;@@Username\u0026lt;/p\u0026gt; 위 코드의 HTML 출력은 다음과 같이 렌더링됩니다:\n\u0026lt;p\u0026gt;@Username\u0026lt;/p\u0026gt; Razor 코드를 작성할 때 기억해야 할 몇 가지 기본 규칙은 다음과 같습니다:\nRazor 코드 블록은 @{ \u0026hellip; }로 감쌉니다. 인라인 표현식(변수 및 함수)은 @로 시작합니다. 코드 문(statement)은 세미콜론(;)으로 끝납니다. 문자열(String)은 큰따옴표(\u0026quot;\u0026quot;)로 감쌉니다. C# 코드는 대소문자를 구분(case-sensitive)합니다. C# 파일 확장자는 .cshtml 또는 .razor입니다. 암묵적 Razor 표현식 암묵적(Implicit) Razor 표현식은 @로 시작하며 뒤에 C# 코드가 옵니다.\n\u0026lt;p\u0026gt;@DateTime.Now\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;@DateTime.IsLeapYear(2016)\u0026lt;/p\u0026gt; C# await 키워드를 제외하고는 암묵적 표현식에는 공백을 포함할 수 없습니다.\nC# 제네릭(Generic)은 사용할 수 없습니다. (\u0026lt; \u0026gt;) 안의 문자가 HTML 태그로 해석되기 때문입니다.\n명시적 Razor 표현식 명시적(Explicit) Razor 표현식은 @ 뒤에 괄호로 감싼 표현식을 사용합니다. 예를 들어, 지난주 같은 시간의 시간을 렌더링하려면 다음과 같은 Razor 마크업을 사용할 수 있습니다.\n\u0026lt;p\u0026gt;Last week this time: @(DateTime.Now - TimeSpan.FromDays(7))\u0026lt;/p\u0026gt; 괄호 안의 모든 내용은 평가된 후 출력됩니다. 명시적 표현식을 사용하면 텍스트와 표현식 결과를 연결할 수도 있습니다.\n@{ var joe = new Person(\u0026#34;Joe\u0026#34;, 33); } \u0026lt;p\u0026gt;Age@(joe.Age)\u0026lt;/p\u0026gt; 주의할 점:\n명시적 표현식 없이 작성된 경우: \u0026lt;p\u0026gt;Age@joe.Age\u0026lt;/p\u0026gt;는 이메일 주소처럼 처리되어 \u0026lt;p\u0026gt;Age@joe.Age\u0026lt;/p\u0026gt;로 렌더링됩니다. 명시적 표현식을 사용하면: \u0026lt;p\u0026gt;Age33\u0026lt;/p\u0026gt;로 렌더링됩니다. Razor 코드 블록 Razor 코드 블록은 @로 시작하며 { }로 감쌉니다. 표현식과는 달리, 코드 블록 내부의 C# 코드는 렌더링되지 않습니다. 뷰(View)에서 코드 블록과 표현식은 동일한 스코프(Scope)를 공유하며, 정의된 순서대로 실행됩니다. 코드 블록에서는 로컬 함수(Local Function)를 선언하고, 마크업과 함께 이를 템플릿 메서드로 사용할 수 있습니다.\n@{ void RenderName(string name) { \u0026lt;p\u0026gt;Name: \u0026lt;strong\u0026gt;@name\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; } RenderName(\u0026#34;Mahatma Gandhi\u0026#34;); RenderName(\u0026#34;Martin Luther King, Jr.\u0026#34;); } 다음 Razor 코드는 아래와 같은 HTML로 렌더링됩니다:\n\u0026lt;p\u0026gt;Name: \u0026lt;strong\u0026gt;Mahatma Gandhi\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Name: \u0026lt;strong\u0026gt;Martin Luther King, Jr.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; 조건부 속성 렌더링 Razor는 필요하지 않은 속성을 자동으로 생략합니다. 전달된 값이 null이거나 false인 경우 해당 속성은 렌더링되지 않습니다.\n예를 들어, 아래의 Razor 코드를 살펴보세요:\n\u0026lt;div class=\u0026#34;@false\u0026#34;\u0026gt;False\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;@null\u0026#34;\u0026gt;Null\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;@(\u0026#34;\u0026#34;)\u0026#34;\u0026gt;Empty\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;@(\u0026#34;false\u0026#34;)\u0026#34;\u0026gt;False String\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;@(\u0026#34;active\u0026#34;)\u0026#34;\u0026gt;String\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked=\u0026#34;@true\u0026#34; name=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked=\u0026#34;@false\u0026#34; name=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked=\u0026#34;@null\u0026#34; name=\u0026#34;null\u0026#34; /\u0026gt; 이 Razor 마크업은 다음과 같은 HTML을 생성합니다:\n\u0026lt;div\u0026gt;False\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Null\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;\u0026#34;\u0026gt;Empty\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;false\u0026#34;\u0026gt;False String\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;active\u0026#34;\u0026gt;String\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked=\u0026#34;checked\u0026#34; name=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;null\u0026#34;\u0026gt; 객체와 함께 작업하기 서버 코딩은 종종 객체(Object)와 관련됩니다.\nDateTime 객체는 ASP.NET에 내장된 대표적인 객체이지만, 객체는 웹 페이지, 텍스트 상자, 파일, 데이터베이스 레코드 등을 설명하기 위해 사용자 정의로 생성될 수도 있습니다. 객체는 수행할 수 있는 메서드(Method)를 가질 수 있습니다.\n예를 들어:\n데이터베이스 레코드 객체에는 Save 메서드가 있을 수 있습니다. 이미지 객체에는 Rotate 메서드가 있을 수 있습니다. 이메일 객체에는 Send 메서드가 있을 수 있습니다. 객체는 특성을 설명하는 속성(Property)도 가질 수 있습니다.\n예를 들어:\n데이터베이스 레코드 객체는 FirstName과 LastName 속성을 가질 수 있습니다. ASP.NET의 DateTime 객체는 Now라는 속성을 가지고 있습니다(DateTime.Now로 작성). Now 속성은 Day라는 하위 속성도 가집니다(DateTime.Now.Day로 작성). 아래 예제는 DateTime 객체의 일부 속성에 접근하는 방법을 보여줍니다:\n\u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th width=\u0026#34;100px\u0026#34;\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;td width=\u0026#34;100px\u0026#34;\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Day\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;@DateTime.Now.Day\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Hour\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;@DateTime.Now.Hour\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Minute\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;@DateTime.Now.Minute\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Second\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;@DateTime.Now.Second\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/table\u0026gt; 제어 구조 제어 구조는 코드 블록의 확장 형태입니다. 코드 블록의 모든 특성(마크업으로의 전환, 인라인 C# 등)이 다음 구조에도 적용됩니다:\n조건문(Conditionals) @if, else if, else, 그리고 @switch @if는 코드 실행 여부를 제어합니다.\n@if (value % 2 == 0) { \u0026lt;p\u0026gt;The value was even.\u0026lt;/p\u0026gt; } else와 else if는 @ 기호를 필요로 하지 않습니다.`\n@if (value % 2 == 0) { \u0026lt;p\u0026gt;The value was even.\u0026lt;/p\u0026gt; } else if (value \u0026gt;= 9876) { \u0026lt;p\u0026gt;The value is large.\u0026lt;/p\u0026gt; } else { \u0026lt;p\u0026gt;The value is odd and small.\u0026lt;/p\u0026gt; } 아래 마크업은 switch 문을 사용하는 방법을 보여줍니다:\n@switch (value) { case 1: \u0026lt;p\u0026gt;The value is 1!\u0026lt;/p\u0026gt; break; case 9876: \u0026lt;p\u0026gt;Your number is 9876!\u0026lt;/p\u0026gt; break; default: \u0026lt;p\u0026gt;Your number wasn\u0026#39;t 1 or 9876.\u0026lt;/p\u0026gt; break; } 반복문 @for, @foreach, @while, @do while 반복 제어문을 사용하여 템플릿 HTML을 렌더링할 수 있습니다. 예를 들어, 사람들의 목록을 렌더링하려면 다음과 같이 작성할 수 있습니다:\n@{ var people = new Person[] { new Person(\u0026#34;Jade\u0026#34;, 31), new Person(\u0026#34;Maxwell\u0026#34;, 29), ... }; } 지원되는 반복문은 다음과 같습니다:\n@for\n@for (var i = 0; i \u0026lt; people.Length; i++) { var person = people[i]; \u0026lt;p\u0026gt;Name: @person.Name\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: @person.Age\u0026lt;/p\u0026gt; } @foreach\n@foreach (var person in people) { \u0026lt;p\u0026gt;Name: @person.Name\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: @person.Age\u0026lt;/p\u0026gt; } @while\n@{ var i = 0; } @while (i \u0026lt; people.Length) { var person = people[i]; \u0026lt;p\u0026gt;Name: @person.Name\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: @person.Age\u0026lt;/p\u0026gt; i++; } @do while\n@{ var i = 0; } @do { var person = people[i]; \u0026lt;p\u0026gt;Name: @person.Name\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Age: @person.Age\u0026lt;/p\u0026gt; i++; } while (i \u0026lt; people.Length); "
},
{
	"uri": "/kr/java-tictactoe/activity-4/",
	"title": "4. 승자를 확인하기",
	"tags": [],
	"description": "write method to check the winner with an input board",
	"content": "승자를 확인하기 현재 게임 보드의 array 입력으로 String에서 승자를 반환하는 방법 \u0026lsquo;getWinner(String[] curBoard)\u0026lsquo;를 작성합니다.\n플레이어가 이기면 \u0026lsquo;\u0026ldquo;축하합니다!\\n당신은 게임에서 이겼습니다 :)\u0026rsquo;.(\u0026quot;Congratulations! \\nYou won the Game :)\u0026quot;)\n컴퓨터가 이기면 \u0026lsquo;\u0026ldquo;게임 오버!\u0026ldquo;를 반환하세요당신은 게임에서 졌습니다 :(\u0026rsquo;).(\u0026quot;Game Over! \\nYou lost the Game :(\u0026quot;.)\n동점일 경우 \u0026lsquo;It\u0026rsquo;s TIE! 다시 시도해 보세요\u0026rsquo;라고 답하세요.(\u0026quot;It's a TIE! Try again\u0026quot;.)\n아직 우승자가 없다면 \u0026quot;\u0026quot;.를 반환하세요.\n이 방법을 작성하는 방법에는 여러 가지가 있습니다.\n다음 리플릿에서 먼저 시도해 보세요. 방법이 올바르게 작성되었는지 알려줄 것입니다! Replit 실행하기\n\u0026lsquo;getWinner()\u0026rsquo; 방법 작성을 위한 아이디어 및 힌트 다음은 getWinner() 메서드를 작성하는 데 도움이 되는 몇 가지 힌트입니다:\n가로, 세로, 대각선의 각 3개의 위치를 연결하여 문자열을 만들어봅니다.\nequals() 메서드를 사용하여 각 연결된 문자열이 \u0026ldquo;XXX\u0026rdquo; 또는 \u0026ldquo;OOO\u0026rdquo; 인지 확인하여 승자를 판별합니다. (이 부분은 \u0026ldquo;XXX\u0026rdquo; 또는 **\u0026ldquo;OOO\u0026rdquo;**을 확인하는 또 다른 메서드를 만들 수도 있습니다.)\n게임판 배열이 모두 채워져 있지만 승자가 없으면 게임은 무승부로 끝납니다. 이 경우 for 루프를 사용하여 배열이 꽉 찼는지 확인할 수 있습니다\n승자 메서드 호출하기 main(), 메서드에서 플레이어의 움직임 **\u0026ldquo;X\u0026rdquo;**를 배치한 후 getWinner() 메서드를 호출하여 승자가 있는지 확인합니다.\n승자가 없거나 무승부인 경우 게임을 계속 진행합니다.\n승자나 무승부가 있을 경우, 마지막으로 게임판을 출력하고 결과를 출력한 후break;문을 사용하여 while 루프에서 빠져나옵니다.\n위 과정을 반복하기 이제 컴퓨터의 움직임 **\u0026ldquo;O\u0026rdquo;**를 배치한 후에도 동일한 코드를 사용하여 getWinner() 메서드를 호출하고, 승자가 있는지 확인합니다. 승자나 무승부가 있으면 게임 결과를 출력한 후 while 루프에서 빠져나옵니다.\nScanner 객체 닫기 while 루프 외부에 sc.close() 코드를 추가하여 더 이상 입력을 받지 않도록 Scanner 객체를 닫습니다.\nwhile 루프에서 break한 후 더 이상 입력을 받지 않을 경우 Scanner 객체를 닫는 것은 좋은 습관입니다!\n완료! :) 이제 완전히 작동하는 틱택토 게임을 완성하셨습니다! 워크숍을 완료한 자신에게 자부심을 느끼세요! 잘하셨습니다! 👍\n코드의 구조에 대한 개요는 다음과 같습니다: 게임판 설정: 처음 게임판을 설정하고, 플레이어와 번갈아 가며 움직임을 입력합니다. 입력 처리: 유효한 입력만 받아들이고, 잘못된 입력에 대해서는 다시 요청합니다. 게임판 업데이트: 플레이어와 컴퓨터의 움직임에 따라 게임판을 업데이트합니다. 승자 확인: 각 턴이 끝날 때마다 승자를 확인하고, 게임 결과를 출력합니다. "
},
{
	"uri": "/kr/supply-chain-analytics/challenge/",
	"title": "추가 도전 과제",
	"tags": [],
	"description": "",
	"content": "농장의 울타리 하나가 부서져 닭과 암탉들이 모두 도망갔어요! 그래서 계란이 부족해졌고, 계란의 최대 사용 가능 수량을 24개에서 15개로 변경해야 해요. ☹\n새로운 최적의 쿠키 생산량을 계산할 수 있나요? 계란 부족으로 인해 수익이 얼마나 변했는지 확인해 보세요.\n계란 수량 제한이 설정된 셀을 24에서 15로 변경한 다음, Solver를 다시 실행해 보세요! 공식을 제대로 설정했다면 Solver에서 셀 값만 변경해도 다른 설정을 바꿀 필요는 없어요.\n"
},
{
	"uri": "/kr/guidelines/formatting/",
	"title": "포맷팅(Formatting)",
	"tags": [],
	"description": "",
	"content": "워크숍을 새로 만들거나 수정할 때는 표준 마크다운(Markdown) 신텍스(syntax)와 일부 맞춤 신텍스(syntax)를 사용하여 작성합니다. 이 페이지는 워크숍에 특정 형식을 추가하기 위해 사용할 신텍스(syntax)를 설명합니다.\n포맷 참조(Formatting Reference) 표준 마크다운(Markdown) 치트시트(Cheatsheet)\r쇼트코드를 사용한 맞춤 형식 옵션(Custom Formatting Options using shortcodes)\r포맷 예제(Formatting Examples) 이 테마에는 사이트의 모양과 느낌을 사용자 지정할 수 있는 다양한 옵션이 포함되어 있습니다. 아래에 신텍스(syntax) 예제와 해당 신텍스를 사용하게 되면 페이지에 실제로 표시되는 결과를 확인할 수 있습니다.\n알림(Alerts) 정보(Info) {{\u0026lt; alert theme=\u0026quot;info\u0026quot; \u0026gt;}}**This** is an info {{\u0026lt; /alert \u0026gt;}}\rThis is an info\r성공(Success) {{\u0026lt; alert theme=\u0026quot;success\u0026quot; \u0026gt;}}**Yeahhh !** is a success{{\u0026lt; /alert \u0026gt;}}\rYeahhh ! is a success\r경고(Warning) {{\u0026lt; alert theme=\u0026quot;warning\u0026quot; \u0026gt;}}**Be careful** is a warning{{\u0026lt; /alert \u0026gt;}}\rBe careful is a warning\r위험(Danger) {{\u0026lt; alert theme=\u0026quot;danger\u0026quot; \u0026gt;}}**Beware !** is a danger{{\u0026lt; /alert \u0026gt;}}\rBeware ! is a danger\r버튼(Buttons) {{\u0026lt; button href=\u0026quot;https://nuevofoundation.org\u0026quot; \u0026gt;}} go to Nuevo Foundation {{\u0026lt; /button \u0026gt;}}\rgo to Nuevo Foundation 성공 버튼(Success Button) {{\u0026lt; button href=\u0026quot;https://nuevofoundation.org\u0026quot; theme=\u0026quot;success\u0026quot; \u0026gt;}} Success {{\u0026lt; /button \u0026gt;}}\rSuccess 정보 버튼(Info Button) {{\u0026lt; button href=\u0026quot;https://nuevofoundation.org\u0026quot; theme=\u0026quot;info\u0026quot; \u0026gt;}} Info {{\u0026lt; /button \u0026gt;}}\rInfo 경고 버튼(Warning Button) {{\u0026lt; button href=\u0026quot;https://nuevofoundation.org\u0026quot; theme=\u0026quot;warning\u0026quot; \u0026gt;}} Warning {{\u0026lt; /button \u0026gt;}}\rWarning 위험 버튼(Danger Button) {{\u0026lt; button href=\u0026quot;https://nuevofoundation.org\u0026quot; theme=\u0026quot;danger\u0026quot; \u0026gt;}} Danger ! {{\u0026lt; /button \u0026gt;}}\rDanger ! 기본 버튼(Default Button) {{\u0026lt; button href=\u0026quot;https://nuevofoundation.org\u0026quot; theme=\u0026quot;default\u0026quot; \u0026gt;}} Danger ! {{\u0026lt; /button \u0026gt;}}\rDanger ! 확장(Expand) {{\u0026lt;expand \u0026quot;Click here to expand!\u0026quot;\u0026gt;}}\rLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod\rtempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,\rquis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo\rconsequat. Duis aute irure dolor in reprehenderit in voluptate velit esse\rcillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non\rproident, sunt in culpa qui officia deserunt mollit anim id est laborum.\r{{\u0026lt; /expand\u0026gt;}}\rClick here to expand!\rLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n알림 노트 알림(Note Notice) {{\u0026lt; notice note \u0026gt;}}\rA notice disclaimer\r{{\u0026lt; /notice \u0026gt;}}\rA notice disclaimer\n정보 알림(Info Notice) {{\u0026lt; notice info \u0026gt;}}\rAn information disclaimer\r{{\u0026lt; /notice \u0026gt;}}\rAn information disclaimer\n팁 알림(Tip Notice) {{\u0026lt; notice tip \u0026gt;}}\rA tip disclaimer\r{{\u0026lt; /notice \u0026gt;}}\rA tip disclaimer\n경고 알림(Warning Notice) {{\u0026lt; notice warning \u0026gt;}}\rAn warning disclaimer\r{{\u0026lt; /notice \u0026gt;}}\rAn warning disclaimer\n아이콘 예제(Example icons available) Full list here\rIcon Icon Name Example Usage asterisk {{\u0026lt;icon name=\u0026quot;asterisk\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} plus {{\u0026lt;icon name=\u0026quot;plus\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} euro {{\u0026lt;icon name=\u0026quot;euro\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} eur {{\u0026lt;icon name=\u0026quot;eur\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} minus {{\u0026lt;icon name=\u0026quot;minus\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} cloud {{\u0026lt;icon name=\u0026quot;cloud\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} envelope {{\u0026lt;icon name=\u0026quot;envelope\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} pencil {{\u0026lt;icon name=\u0026quot;pencil\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} glass {{\u0026lt;icon name=\u0026quot;glass\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} music {{\u0026lt;icon name=\u0026quot;music\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} search {{\u0026lt;icon name=\u0026quot;search\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} heart {{\u0026lt;icon name=\u0026quot;heart\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} star {{\u0026lt;icon name=\u0026quot;star\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} star-empty {{\u0026lt;icon name=\u0026quot;star-empty\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} user {{\u0026lt;icon name=\u0026quot;user\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} film {{\u0026lt;icon name=\u0026quot;film\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} th-large {{\u0026lt;icon name=\u0026quot;th-large\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} th {{\u0026lt;icon name=\u0026quot;th\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} th-list {{\u0026lt;icon name=\u0026quot;th-list\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} ok {{\u0026lt;icon name=\u0026quot;ok\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} remove {{\u0026lt;icon name=\u0026quot;remove\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} zoom-in {{\u0026lt;icon name=\u0026quot;zoom-in\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} zoom-out {{\u0026lt;icon name=\u0026quot;zoom-out\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} off {{\u0026lt;icon name=\u0026quot;off\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} signal {{\u0026lt;icon name=\u0026quot;signal\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} cog {{\u0026lt;icon name=\u0026quot;cog\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} trash {{\u0026lt;icon name=\u0026quot;trash\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} home {{\u0026lt;icon name=\u0026quot;home\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} file {{\u0026lt;icon name=\u0026quot;file\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} time {{\u0026lt;icon name=\u0026quot;time\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} road {{\u0026lt;icon name=\u0026quot;road\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} download-alt {{\u0026lt;icon name=\u0026quot;download-alt\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} download {{\u0026lt;icon name=\u0026quot;download\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} upload {{\u0026lt;icon name=\u0026quot;upload\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} inbox {{\u0026lt;icon name=\u0026quot;inbox\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} play-circle {{\u0026lt;icon name=\u0026quot;play-circle\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} repeat {{\u0026lt;icon name=\u0026quot;repeat\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} refresh {{\u0026lt;icon name=\u0026quot;refresh\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} list-alt {{\u0026lt;icon name=\u0026quot;list-alt\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} lock {{\u0026lt;icon name=\u0026quot;lock\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} flag {{\u0026lt;icon name=\u0026quot;flag\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} headphones {{\u0026lt;icon name=\u0026quot;headphones\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} volume-off {{\u0026lt;icon name=\u0026quot;volume-off\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} volume-down {{\u0026lt;icon name=\u0026quot;volume-down\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} volume-up {{\u0026lt;icon name=\u0026quot;volume-up\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} qrcode {{\u0026lt;icon name=\u0026quot;qrcode\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} barcode {{\u0026lt;icon name=\u0026quot;barcode\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} tag {{\u0026lt;icon name=\u0026quot;tag\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} tags {{\u0026lt;icon name=\u0026quot;tags\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} book {{\u0026lt;icon name=\u0026quot;book\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} bookmark {{\u0026lt;icon name=\u0026quot;bookmark\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} print {{\u0026lt;icon name=\u0026quot;print\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} camera {{\u0026lt;icon name=\u0026quot;camera\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} font {{\u0026lt;icon name=\u0026quot;font\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} bold {{\u0026lt;icon name=\u0026quot;bold\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} italic {{\u0026lt;icon name=\u0026quot;italic\u0026quot; size=\u0026quot;large\u0026quot;\u0026gt;}} "
},
{
	"uri": "/kr/jsappybird/add-jump-sound/",
	"title": "새가 점프할 때 소리 추가하기 &amp; 보너스",
	"tags": [],
	"description": "",
	"content": "새가 점프할 때 소리가 나도록 만들어 봅시다.\n파일 [File: create-game.js] 에 다음 명령을 추가하세요. jumpSound.play();\n함께 해보기 아래 Replit 창에서 jumpSound.play();로 코드를 시작했습니다.\nrun 을 누르면, 여러분의 콘솔에 새가 점프하면서 소리를 내는 모습을 확인할 수 있습니다.\n보너스 활동 중력의 값을 더 높이면 어떻게 될까요? 중력 값을 음수로 만들면 무슨 일이 일어날까요? 새가 다른 재미있는 방법으로 점프하게 하려면 어떻게 해야 할까요? 새가 더 빠르게 회전하게 만들려면 어떻게 해야 할까요? 회전을 명령하는 “if(조건명령어)”를 제거하면 어떤 변화가 생길까요? "
},
{
	"uri": "/kr/secret-messages/activity-4/",
	"title": "Activity 4 - 조건문 (Conditions)",
	"tags": [],
	"description": "",
	"content": "\n좋아요!\n우리는 점점 비밀 메시지를 완성하는 데 가까워지고 있습니다. 하지만 이 메시지를 해독(decrypt)할 수 있어야 한다는 점도 잊지 마세요!\n이를 위해 콘솔에서 입력 값을 받을 것입니다:\n1을 입력하면 메시지를 암호화(encrypt)합니다. 2를 입력하면 메시지를 해독(decrypt)합니다. 이 작업을 위해 **조건문(Condition)**이 필요합니다. 조건문 if/else 프로그래밍에서 조건문이란 특정 조건이 참(true)인지에 따라 명령어 또는 명령어 그룹을 실행하거나 실행하지 않도록 지시하는 것입니다. 이는 다음과 같이 동작합니다: 만약(if) 특정 조건이 충족되면, 이 명령어를 실행합니다. 그렇지 않다면(if not)(else) 다른 명령어를 실행합니다.\nExample\nif(3 \u0026gt; 1){\rcout \u0026lt;\u0026lt; \u0026#34;3 is greater than 1\u0026#34; \u0026lt;\u0026lt; endl;\r}else{\rcout \u0026lt;\u0026lt; \u0026#34;3 is not greater than 1\u0026#34; \u0026lt;\u0026lt; endl;\r} 이 프로그램은 다음과 같이 출력됩니다:\n3 is greater than 1 if(3 \u0026gt; 1) o\t숫자 3이 1보다 큰지 확인합니다. 조건이 참(true)이라면, if 바로 뒤의 코드 블록이 실행됩니다. o\t위 코드에서는 \u0026ldquo;3 is greater than 1\u0026quot;이 출력됩니다. 조건이 거짓(false)이라면, else 뒤의 코드 블록이 실행됩니다. o\t하지만 위 예제에서는 조건이 참이므로, else 블록은 실행되지 않습니다 논리 연산자(Logical Operators) 조건을 만들 때는 if 옆의 괄호 () 안에서 논리 연산자를 주로 사용합니다. 예를 들어, a = 5와 b = 3일 때, 아래는 사용 가능한 논리 연산자들입니다: •\t작다: a \u0026lt; b (5는 3보다 작습니까?) •\t작거나 같다: a \u0026lt;= b (5는 3보다 작거나 같습니까?) •\t크다: a \u0026gt; b (5는 3보다 큽니까?) •\t크거나 같다: a \u0026gt;= b (5는 3보다 크거나 같습니까?) •\t같다: a == b (5는 3과 같습니까?) •\t같지 않다: a != b (5는 3과 같지 않습니까?)\n이번 활동에서는 입력된 값에 따라 메시지를 암호화(encrypt it)할지 해독할지(decrypt it)를 결정하는 조건문을 작성합니다. 그걸 위해서 이 과정을 따라야 합니다.:\n정수형(int) 변수를 만드세요. 사용자 입력을 요청하고, 입력된 데이터를 정수형 변수에 저장하세요. if/else 조건문을 사용하여 입력된 값이 1인지 확인하세요: 값이 1이라면, 메시지를 암호화(Encrypt) 합니다. 그렇지 않다면, 메시지를 해독(Decrypt) 합니다. 콘솔 출력: 값이 1일 경우, \u0026ldquo;Encrypt a message\u0026quot;를 출력합니다. 그 외의 경우, \u0026ldquo;Decrypt a message\u0026quot;를 출력합니다. 도움이 필요하면 이전 활동으로 돌아가서 검토할 수 있다는 점을 기억하세요.\nReplit 실행하기\n"
},
{
	"uri": "/kr/microbit-distance-checker/light-it-up/",
	"title": "시각적 표시",
	"tags": [],
	"description": "",
	"content": "이제 논리적 코드를 작성했으니, 6피트 이상 떨어졌는지 확인할 수 있도록 시각적 표시를 추가해 봅시다. Basic 섹션을 클릭하여 “show icon” 블록을 가져와 논리 블록의 if 부분 안에 넣습니다. 아이콘을 클릭하여 다른 아이콘 목록을 표시한 뒤, 슬픈 찡그린 얼굴을 선택하세요. 다시 Basic 메뉴로 돌아가 “show icon” 블록을 하나 더 가져온 뒤, 논리 블록의 else 부분 안에 배치합니다. 이번에는 웃는 얼굴 아이콘으로 변경하세요. 작업이 완료되면 코드가 다음과 같이 보여야 합니다:\n"
},
{
	"uri": "/kr/javascript-blocks-earsketch/activity-3-add-effects-to-your-songs/",
	"title": "활동 3 - 곡에 효과 추가하기",
	"tags": [],
	"description": "",
	"content": "EarSketch에서의 효과 효과 프로듀서가 오디오 클립의 소리를 독특하게 변형할 수 있게 합니다. 새로운 오디오 클립을 추가할 때 fitMedia() 함수를 사용한 것처럼, 우리는 특정 오디오 클립에 효과를 적용하기 위해 setEffect() 함수를 사용해야 합니다. 한 트랙에 여러 효과를 적용할 수 있다는 점이 중요합니다. 이는 여러 효과를 결합하여 독특한 사운드를 만들 수 있음을 의미합니다. EarSketch에는 다양한 효과가 내장되어 있습니다. 모든 효과를 참고하려면 이 링크\r를 방문하고 탐색 바에서 커리큘럼 창을 선택하세요.\n효과를 추가하기 전에 setEffect 함수의 각 요소를 살펴봅시다:\ntrack: ● 효과를 적용할 트랙 번호입니다. 참고: 마스터 트랙에 효과를 적용하려면, track 값으로 0을 사용합니다. 마스터 트랙은 모든 오디오가 함께 재생되는 곳입니다. 이곳에 효과를 적용하면, 처리 중인 모든 소리에 동일한 효과가 적용됩니다. effectType: 사용하려는 특정 효과입니다, effectParameter: 선택한 효과의 세부 설정입니다. effectValue: effectParameter에 적용될 값입니다. 곡에 효과 추가하기 이제 효과를 사용하는 방법을 알았으니, 곡에 효과를 추가해 봅시다.\nsetEffect 함수 블록을 찾으세요. 두 개의 setEffect 블록이 보일 텐데, 그중 첫 번째 블록을 선택하세요. 이 블록을 스크립트의 기존 코드 블록 아래로 드래그하세요. 매개변수를 자신의 값으로 교체해야 합니다. 드롭다운을 사용하여 track을 2로 변경하세요(또는 원하는 다른 숫자를 선택하세요). effectType 매개변수에 사용할 수 있는 다양한 효과를 드롭다운에서 선택해보세요. DELAY를 선택해봅시다. 이제 effectType을 선택했으니, effectParameter를 매개변수로 선택하세요. DELAY_FEEDBACK을 선택하세요. 마지막으로, 유효한 값을 입력하세요. DELAY_FEEDBACK을 선택했으므로, -120.0에서 -1.0 사이의 숫자를 지정해야 합니다. 예시: DELAY_FEEDBACK 값으로 -6.0을 사용하세요. 이제 코드가 아래와 같이 보일 것입니다:\n"
},
{
	"uri": "/kr/machine-learning/feature-selection/",
	"title": "Step 5: 특징 선택하기(Feature selection)",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "다음 단계는 적절한 특징(feature)을 선택하는 것입니다. 특징 선택은 머신러닝에서 모델을 학습하는 데 중요한 특징을 선택하는 방법과 과정을 설명하는 용어입니다. 특징(feature)이란 공식에서 사용되는 하나의 변수, 즉 x입니다. 이번 프로젝트에서 특징은 축구 선수의 속성 중 하나입니다. 우리는 선형 회귀(Linear Regression) 모델을 사용하고 있으므로, 각 속성이 목표값(즉, 종합 능력치(overall ratings))과 얼마나 상관관계가 있는지가 적절한 특징을 선택하는 기준이 됩니다. 우리는 피어슨 상관계수(Pearson correlation coefficient)를 사용하여 각 열의 상관관계를 계산할 것입니다. 사용할 수 있는 세 가지 방법은 다음과 같습니다:\n피어슨(Pearson): 표준 상관계수 켄달(Kendall): 켄달 타우 상관계수 스피어만(Spearman): 스피어만 순위 상관계수 이번 튜토리얼에서는 피어슨(Pearson) 방법을 사용할 것입니다.\n# 목표 변수 선택 target = \u0026#34;Overall\u0026#34; # 피어슨 방법을 사용하여 열 간의 상관관계 찾기 feature_corr = train_data.corr(method =\u0026#39;pearson\u0026#39;) [target] # 특징을 내림차순으로 정렬 feature_corr = feature_corr.sort_values(ascending = False) # 상위 20개의 특징을 출력 # 전체 목록에서 첫 번째는 항상 \u0026#34;종합 능력치(Overall)\u0026#34;이므로, 1부터 시작합니다. print(feature_corr[1:21]) 출력 결과:\nPositioning 0.904367\rSpecial 0.903856\rFinishing 0.899783\rBallControl 0.896988\rShotPower 0.877842\rReactions 0.861441\rVolleys 0.834433\rComposure 0.827529\rShortPassing 0.813074\rDribbling 0.802565\rLongShots 0.794059\rHeadingAccuracy 0.711129\rVision 0.671054\rSkill Moves 0.649300\rCurve 0.641426\rCrossing 0.603249\rPotential 0.593139\rPenalties 0.583906\rLongPassing 0.575092\rFKAccuracy 0.569704\rName: Overall, dtype: float64\r이제 상위 10개 또는 12개의 특징을 복사하고 붙여 넣습니다. (참고: 공백은 복사하지 마세요.)\n# 특징 선택 features = [\u0026#34;Positioning\u0026#34;, \u0026#34;Finishing\u0026#34;, \u0026#34;Special\u0026#34;, \u0026#34;BallControl\u0026#34;, \u0026#34;ShotPower\u0026#34;, \u0026#34;Reactions\u0026#34;, \u0026#34;Volleys\u0026#34;, \u0026#34;Composure\u0026#34;, \u0026#34;ShortPassing\u0026#34;] 또한, 우리는 index에서 특징 이름만 추출할 수 있습니다. 참고로, 목록에서 첫 번째는 항상 종합 능력치(Overall)이므로, 1부터 시작합니다.\n# 시리즈에서 특징 이름을 추출 features = feature_corr[1:21].index.tolist() # 특징 목록 출력 print(features) 출력 결과:\n['Positioning', 'Special', 'Finishing', 'BallControl', 'ShotPower', 'Reactions', 'Volleys', 'Composure', 'ShortPassing', 'Dribbling', 'LongShots', 'HeadingAccuracy', 'Vision', 'Skill Moves', 'Curve', 'Crossing', 'Potential', 'Penalties', 'LongPassing', 'FKAccuracy'] "
},
{
	"uri": "/kr/security/answer-key/",
	"title": "답안 - 보안",
	"tags": [],
	"description": "보안 커리큘럼에 대한 쉬운 참조 답안",
	"content": "해답 우리의 스파이 게임에서, 비밀번호 \u0026ldquo;Ilovemypet\u0026quot;은 숫자나 특수 문자가 포함되지 않았고, \u0026ldquo;12345678\u0026quot;은 숫자로 이루어진 단순한 순서입니다. 따라서 두 비밀번호 모두 약하며, 악의적인 사람이 쉽게 해킹하거나 추측할 수 있습니다.\n"
},
{
	"uri": "/kr/adafruit/answer-key/",
	"title": "답안지 - 아다프루트",
	"tags": [],
	"description": "아다프루트 커리큘럼을 위한 간단한 참조용 답안지",
	"content": "설정 요약:\n두 개의 악어 클립을 각각 오렌지 표면에 고정합니다. 클립의 양 끝 쪽을 아다프루트의 A1과 A2 입력 단자에 연결합니다. USB 케이블을 아다프루트에 연결하되, 아직 컴퓨터에는 연결하지 마세요. 설정이 완료되면, 오렌지와 아다프루트의 모습은 다음과 같아야 합니다:\n해결 방법 고급 해결 방법(조명 포함) 작동 원리 "
},
{
	"uri": "/kr/security-phishing/whats-phishy/",
	"title": "어떤 게 피싱일까?",
	"tags": [],
	"description": "",
	"content": "지난 부분에서 다양한 피싱 방법과 이를 인식하는 법을 배웠어요. 이제 어떤 게 피싱일까?라는 게임을 해볼 시간이에요!\n아래에 나오는 이미지들 중 어떤 것이 피싱처럼 보이는지 생각해 보세요.\n이 이메일이 피싱 같나요?\rYes\rNo\r이 배너 광고가 피싱 같나요?\rYes\rNo\r이 문자 메시지가 피싱 같나요?\rYes\rNo\r이 문자 메시지가 피싱 같나요?\rYes\rNo\r이 문자 메시지가 피싱 같나요?\rYes\rNo\r정답 확인! "
},
{
	"uri": "/kr/ml-machine-learning/05-making-predictions/",
	"title": "예측하기",
	"tags": [],
	"description": "",
	"content": "모델 학습시키기 모델이 값을 예측하려면 학습이 필요합니다. 그런데, 어떻게 학습을 시킬까요? 사실, 우리는 이미 이 작업을 하고 있었답니다!😉\n모델을 학습시키는 과정은 데이터와 모델 간의 관계가 적절한지 확인하는 것을 말합니다. 우리는 R2 값이 1에 가까운지 확인함으로써 이를 수행했습니다. 이제, 10,000개 이상의 데이터셋을 사용해 훈련 데이터와 테스트 데이터를 만들어야 합니다. 훈련 데이터는 초기 샘플 30개 대신 무작위 샘플을 사용합니다. 텍사스 엘파소 대학교에 따르면, 데이터의 30%를 샘플로 사용하는 것이 정확한 모델을 만드는 이상적인 방법이라고 합니다. (70/30 또는 80/20 훈련과 테스트 데이터 비율에 대한 자세한 내용은 여기를 참고하세요.\r) 직원 수가 증가하면 데이터셋도 함께 늘어나고 R2값도 변하게 됩니다. 따라서, 직원 데이터셋이 10,000개 이상으로 업데이트될 때마다 이 과정을 반복해야 가장 최신의 상태로 모델을 유지할 수 있습니다.\n예측하기 아래 Replit에서 코드는 10,000개 이상의 데이터를 나누어 훈련 데이터와 테스트 데이터를 생성하고, 각각의 데이터셋에 대해 예측을 실행합니다.\nReplit 실행하기\n결과 그래프를 보면, 훈련 데이터와 테스트 데이터에서 생성된 예측선(prediction line)이 매우 비슷하다는 것을 알 수 있습니다. 또한, 두 데이터셋에 대해 계산된 R2 값도 거의 동일하거나 때로는 완전히 동일합니다. 이제 아래 코드를 사용해 경력 변수를 원하는 값으로 변경해 보세요. 입력한 경력을 기준으로 예측된 급여를 그래프에서 확인할 수 있습니다.\nReplit 실행하기\n"
},
{
	"uri": "/kr/chatbot/activity-2/",
	"title": "활동 2: PandoraBots 설정",
	"tags": [],
	"description": "",
	"content": "AIML 이제 AIML을 사용하여 챗봇을 만들 것입니다. AIML은 인공지능 마크업 언어(Artificial Intelligence Markup Language)의 약자로, 웹사이트를 만들 때 사용하는 HTML과 매우 유사하게 보일 것입니다. AIML을 작성하기 전에, Pandorabots에 가입해야 합니다.\nPandorabots https://www.pandorabots.com/\r에 접속하여 Sign Up을 클릭하세요. 메일과 비밀번호를 입력하여 계정을 만드세요. 또는 Google, Facebook, Twitter, Github 계정으로 가입할 수도 있습니다. 프롬프트가 나타나면 무료 체험(free trial) 옵션을 선택하세요.\n새로운 봇 만들기 가입이 완료되면, 다음과 같은 페이지가 표시 됩니다:\n\u0026ldquo;My Bots\u0026rdquo; 옆에 있는 \u0026ldquo;+\u0026rdquo; 버튼을 눌러 새로운 봇을 만드세요. 이름을 지정하고 \u0026ldquo;Create Bot\u0026quot;를 클릭하세요.\n봇 편집하기 새로운 봇을 만들면, 봇의 이름이 탐색 창에 나타납니다. 봇 이름 아래의 Edit을 클릭한 다음, Code Editor를 선택하여 편집기로 이동하세요.\n편집기에서 AIML 파일과 카테고리를 작성하여, 여러분과 다른 사람들이 봇과 대화할 수 있도록 할 수 있습니다.\n파일 메뉴를 사용하여 greetings라는 새로운 AIML 파일을 만드세요.\nHello World 다음 카테고리 코드를 \u0026lt;aiml\u0026gt; 시작 태그와 \u0026lt;/aiml\u0026gt; 종료 태그 사이에 복사하세요:\n\u0026lt;category\u0026gt;\r\u0026lt;pattern\u0026gt;HELLO\u0026lt;/pattern\u0026gt;\r\u0026lt;template\u0026gt;\rHello, World!\r\u0026lt;/template\u0026gt;\r\u0026lt;/category\u0026gt; 완료되면, \u0026ldquo;파일(file)\u0026rdquo; 드롭다운 메뉴를 통해 파일을 저장하세요.\n봇 테스트하기 채팅 위젯(Chat Widget)을 사용하여 봇과 대화할 수 있습니다. 오른쪽 아래의 \u0026ldquo;채팅 말풍선(chat bubbles)\u0026rdquo; 아이콘을 클릭하여 봇과 대화를 시작하세요. Hello 라고 입력하면, 여러분이 방금 작성한 응답인 “Hello, world!”﻿가 표시될 것입니다.\n"
},
{
	"uri": "/kr/razor/directives/",
	"title": "Razor 지시문",
	"tags": [],
	"description": "",
	"content": "지시문 Razor 지시문은 @ 기호 뒤에 예약된 키워드가 따라오는 암묵적 표현식으로 표현됩니다. 지시문은 일반적으로 뷰(View)가 해석되는 방식을 변경하거나, 다양한 기능을 활성화합니다.\nRazor가 뷰에 대한 코드를 생성하는 방식을 이해하면 지시문의 동작을 더 쉽게 이해할 수 있습니다.\n@{ string quote = \u0026#34;Getting old ain\u0026#39;t for wimps! - Anonymous\u0026#34;; } \u0026lt;div\u0026gt;Quote of the Day: @quote\u0026lt;/div\u0026gt; 위 코드는 다음과 유사한 클래스를 생성합니다:\npublic class _Views_Something_cshtml : RazorPage\u0026lt;dynamic\u0026gt; { public override async Task ExecuteAsync() { string output = \u0026#34;Getting old ain\u0026#39;t for wimps! - Anonymous\u0026#34;; WriteLiteral(\u0026#34;/r/n\u0026lt;div\u0026gt;Quote of the Day: \u0026#34;); Write(output); WriteLiteral(\u0026#34;\u0026lt;/div\u0026gt;\u0026#34;); } } @attribute @attribute 지시문은 생성된 페이지나 뷰 클래스에 지정된 속성을 추가합니다. 다음 예제는 [Authorize] 속성을 추가하는 방법을 보여줍니다:\n@attribute [Authorize] @attribute 지시문은 Razor 컴포넌트에서 상수 기반 경로 템플릿(constant-based route template)을 제공하는 데에도 사용할 수 있습니다. 다음 예제에서는 컴포넌트에서 @page 지시문이 @attribute 지시문과 Constants.CounterRoute의 상수 기반 경로 템플릿으로 대체됩니다. Constants.CounterRoute는 앱의 다른 곳에서 \u0026ldquo;/counter\u0026quot;로 설정되어 있습니다:\n@page \u0026#34;/counter\u0026#34; @attribute [Route(Constants.CounterRoute)] @code @code 블록은 Razor 컴포넌트(.razor)에만 해당됩니다. @code 블록을 사용하면 Razor 컴포넌트에 C# 멤버(필드, 속성, 메서드)를 추가할 수 있습니다.\n@code { // C# members (fields, properties, and methods) } Razor 컴포넌트에서 @code는 @functions의 별칭으로, @functions 대신 사용하는 것이 권장됩니다. @code 블록은 여러 개 작성이 가능합니다.\n@functions @functions 지시문은 생성된 클래스에 C# 멤버(필드, 속성, 메서드)를 추가할 수 있도록 합니다.\n@functions { // C# members (fields, properties, and methods) } Razor 컴포넌트에서는 C# 멤버를 추가할 때 @functions 대신 @code를 사용하는 것이 권장됩니다.\n@functions { public string GetHello() { return \u0026#34;Hello\u0026#34;; } } \u0026lt;div\u0026gt;From method: @GetHello()\u0026lt;/div\u0026gt; 위 코드는 다음과 같은 HTML을 생성합니다:\n\u0026lt;div\u0026gt;From method: Hello\u0026lt;/div\u0026gt; 다음은 Razor 코드가 생성하는 C# 클래스입니다:\nusing System.Threading.Tasks; using Microsoft.AspNetCore.Mvc.Razor; public class _Views_Home_Test_cshtml : RazorPage\u0026lt;dynamic\u0026gt; { // Functions placed between here public string GetHello() { return \u0026#34;Hello\u0026#34;; } // And here. #pragma warning disable 1998 public override async Task ExecuteAsync() { WriteLiteral(\u0026#34;\\r\\n\u0026lt;div\u0026gt;From method: \u0026#34;); Write(GetHello()); WriteLiteral(\u0026#34;\u0026lt;/div\u0026gt;\\r\\n\u0026#34;); } #pragma warning restore 1998 @functions 방식은 마크업을 포함하는 경우, 템플릿 방식으로 동작할 수 있습니다:\n@{ RenderName(\u0026#34;Mahatma Gandhi\u0026#34;); RenderName(\u0026#34;Martin Luther King, Jr.\u0026#34;); } @functions { private void RenderName(string name) { \u0026lt;p\u0026gt;Name: \u0026lt;strong\u0026gt;@name\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; } } 위 코드는 다음과 같은 HTML로 렌더링됩니다:\n\u0026lt;p\u0026gt;Name: \u0026lt;strong\u0026gt;Mahatma Gandhi\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Name: \u0026lt;strong\u0026gt;Martin Luther King, Jr.\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; @implements @implements 지시문은 생성된 클래스에 인터페이스를 구현하도록 설정합니다. 다음 예제는 System.IDisposable인터페이스를 구현하여 Dispose 메서드를 호출할 수 있도록 합니다:\n@implements IDisposable \u0026lt;h1\u0026gt;Example\u0026lt;/h1\u0026gt; @functions { private bool _isDisposed; ... public void Dispose() =\u0026gt; _isDisposed = true; } @inherits @inherits 지시문은 뷰(View)가 상속받는 클래스를 완전히 제어할 수 있도록 설정합니다:\n@inherits TypeNameOfClassToInheritFrom 커스텀 Razor 페이지 타입의 사용 예시는 다음과 같습니다.\nusing Microsoft.AspNetCore.Mvc.Razor; public abstract class CustomRazorPage\u0026lt;TModel\u0026gt; : RazorPage\u0026lt;TModel\u0026gt; { public string CustomText { get; } = \u0026#34;Gardyloo! - A Scottish warning yelled from a window before dumping\u0026#34; + \u0026#34;a slop bucket on the street below.\u0026#34;; } 뷰에서 CustomText 출력하기:\n@inherits CustomRazorPage\u0026lt;TModel\u0026gt;\r\u0026lt;div\u0026gt;Custom text: @CustomText\u0026lt;/div\u0026gt; 위 코드는 다음과 같은 HTML을 생성합니다:\n\u0026lt;div\u0026gt; Custom text: Bumbershoot - Another word for an umbrella. \u0026lt;/div\u0026gt; @model과 @inherits는 동일한 뷰에서 함께 사용할 수 있습니다. @inherits는 _ViewImports.cshtml 파일에 정의되어 뷰가 이를 가져올 수 있습니다.\n@inherits CustomRazorPage\u0026lt;TModel\u0026gt; 다음 코드는 강력한 형식(strongly-typed)의 뷰 예제입니다:\n@inherits CustomRazorPage\u0026lt;TModel\u0026gt; \u0026lt;div\u0026gt;The Login Email: @Model.Email\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Custom text: @CustomText\u0026lt;/div\u0026gt; Model에 \u0026ldquo;jade@nuevofoundation.org\r\u0026rdquo; 값이 전달되었을 때, 뷰는 다음과 같은 HTML을 생성합니다:\n\u0026lt;div\u0026gt;The Login Email: jade@nuevofoundation.org\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; Custom text: Bumbershoot - Another word for an umbrella. \u0026lt;/div\u0026gt; @inject @inject 지시문은 Razor 페이지가 서비스 컨테이너로부터 서비스를 뷰에 주입할 수 있도록 합니다.\n@layout @layout 지시문은 Razor 컴포넌트(.razor)에만 해당됩니다. 이 지시문은 @page 지시문이 있는 라우팅 가능한 Razor 컴포넌트에 대해 레이아웃을 지정합니다.\n레이아웃 컴포넌트는 코드 중복과 일관성 부족을 방지하기 위해 사용됩니다.\n@model @model 지시문은 MVC 뷰와 Razor 페이지(.cshtml)에만 해당됩니다. 다음 지시문은 뷰(View)나 페이지(Page)에 전달되는 모델의 타입을 지정합니다:\n@model TypeNameOfModel ASP.NET Core MVC 또는 Razor Pages 앱에서 개별 사용자 계정을 사용하는 경우, Views/Account/Login.cshtml 파일은 다음과 같은 모델 선언을 포함합니다:\n@model LoginViewModel @model 선언은 다음과 같이 RazorPage를 상속하는 클래스를 생성합니다:\npublic class _Views_Account_Login_cshtml : RazorPage\u0026lt;LoginViewModel\u0026gt; Razor는 뷰에 전달된 모델에 접근할 수 있도록 Model 속성을 제공합니다:\n\u0026lt;div\u0026gt;The Login Email: @Model.Email\u0026lt;/div\u0026gt; @model 지시문은 Model 속성의 타입을 지정합니다. 이 지시문은 생성된 클래스에서 RazorPage\u0026lt;T\u0026gt;의 T 타입을 정의합니다.\n@model 지시문이 없는 경우, Model 속성의 타입은 dynamic으로 설정됩니다. 강력한 형식 모델(strongly typed models)과 @model 키워드에 대한 자세한 내용은 관련 문서를 참조해주세요.\n@namespace @namespace 지시문은 다음과 같은 역할을 합니다:\n생성된 Razor 페이지, MVC 뷰 또는 Razor 컴포넌트 클래스의 네임스페이스를 설정합니다. 디렉터리 트리에서 가장 가까운 imports 파일(_ViewImports.cshtml 또는 _Imports.razor)에 따라 페이지, 뷰 또는 컴포넌트 클래스의 루트 네임스페이스를 설정합니다. @namespace Your.Namespace.Here Razor Pages 예제\n다음 표에서 보여주는 Razor Pages 예제의 특징은 다음과 같습니다:\n각 페이지는 Pages/_ViewImports.cshtml을 가져옵니다. 각 페이지는 Hello.World를 네임스페이스의 루트로 설정합니다. Pages/_ViewImports.cshtml 파일에는 다음과 같은 내용이 포함됩니다: Page Namespace Pages/Index.cshtml Hello.World Pages/MorePages/Page.cshtml Hello.World.MorePages Pages/MorePages/EvenMorePages/Page.cshtml Hello.World.MorePages.EvenMorePages 앞서 설명한 관계는 MVC 뷰와 Razor 컴포넌트에서 사용되는 import 파일에도 동일하게 적용됩니다. 디렉터리 트리에서 페이지, 뷰, 또는 컴포넌트와 가장 가까운 import 파일에 @namespace 지시문이 있을 경우, 해당 파일이 루트 네임스페이스를 설정합니다.\n예를 들어, 이전 예제에서 EvenMorePages 폴더에 @namespace Another.Planet을 포함한 import 파일이 있거나, Pages/MorePages/EvenMorePages/Page.cshtml 파일에 @namespace Another.Planet 지시문이 포함된 경우 결과는 다음 표와 같습니다.\nPage Namespace Pages/Index.cshtml Hello.World Pages/MorePages/Page.cshtml Hello.World.MorePage Pages/MorePages/EvenMorePages/Page.cshtml Another.Planet @page @page 지시문은 나타나는 파일 유형에 따라 다른 동작을 수행합니다:\n.cshtml 파일에서: 해당 파일이 Razor 페이지임을 나타냅니다. Razor 컴포넌트에서: 해당 컴포넌트가 요청을 직접 처리해야 함을 지정합니다. @preservewhitespace 이 지시문은 Razor 컴포넌트(.razor)에만 적용됩니다.\n기본값은 false이며, 다음 조건에 해당하는 경우 렌더링된 마크업에서 공백이 제거됩니다:\n요소 안의 앞뒤 공백. RenderFragment 매개변수 안의 앞뒤 공백(예: 다른 컴포넌트에 전달된 자식 콘텐츠). @if 또는 @foreach와 같은 C# 코드 블록 앞뒤의 공백. @section @section 지시문은 MVC 뷰와 Razor 페이지(.cshtml)에만 적용됩니다.\n이 지시문은 MVC 및 Razor Pages 레이아웃과 함께 사용되어, 뷰(View)나 페이지(Page)가 HTML 페이지의 서로 다른 부분에 콘텐츠를 렌더링할 수 있도록 합니다.\n@typeparam @typeparam 지시문은 Razor 컴포넌트(.razor)에만 적용됩니다.\n이 지시문은 생성된 컴포넌트 클래스에 제네릭(Generic) 타입 매개변수 를 선언합니다:\n@typeparam TEntity 제약 조건(type constraints)이 있는 제네릭 타입도 지원됩니다:\n@typeparam TEntity where TEntity : IEntity @using @using 지시문은 생성된 뷰(View)에 C#의 using 지시문을 추가합니다:\n@using System.IO @{ var dir = Directory.GetCurrentDirectory(); } \u0026lt;p\u0026gt;@dir\u0026lt;/p\u0026gt; 위 코드는 현재 디렉터리 경로를 출력하는 HTML을 생성합니다.\nRazor 컴포넌트에서는 @using이 컴포넌트의 범위(scope) 내에 있는 컴포넌트를 제어하는 데에도 사용됩니다.\nDirective attributes Razor 지시문 속성은 @ 기호 뒤에 예약 키워드가 따라오는 암묵적 표현식으로 쓸 수 있습니다. 지시문 속성은 일반적으로 요소가 해석되는 방식을 변경하거나, 다른 기능을 활성화합니다.\n@attributes @attributes 지시문은 Razor 컴포넌트(.razor)에만 적용됩니다.\n이 지시문은 선언되지 않은 속성을 컴포넌트에서 렌더링할 수 있도록 합니다.\n@bind @bind 지시문은 Razor 컴포넌트(.razor)에만 적용됩니다.\n데이터 바인딩은 @bind 속성을 사용하여 수행됩니다.\n\u0026lt;input type=\u0026#34;checkbox\u0026#34; @bind=\u0026#34;todo.IsDone\u0026#34; /\u0026gt; This example binds the todo Object\u0026rsquo;s IsDone property to the checkbox.\n@bind:culture @bind:culture 지시문은 Razor 컴포넌트(.razor)에만 적용됩니다.\n이 속성은 @bind 속성과 함께 사용되어 값을 파싱 하거나 포맷할 때System.Globalization.CultureInfo를 제공합니다.\n@on{EVENT} 이 지시문은 Razor 컴포넌트(.razor)에만 적용됩니다.\nRazor는 컴포넌트를 위한 이벤트 처리 기능을 제공합니다.\n\u0026lt;button @onclick=\u0026#34;AddTodo\u0026#34;\u0026gt;Add todo\u0026lt;/button\u0026gt; 위 코드에서 버튼을 클릭하면 AddTodo 메서드가 호출됩니다.\n@ref @ref 지시문은 Razor 컴포넌트(.razor)에만 적용됩니다. 컴포넌트 참조(@ref)는 컴포넌트 인스턴스를 참조하여 해당 인스턴스에 명령을 전달할 수 있는 방법을 제공합니다.\nRazor 예약 키워드 Razor에서 사용되는 키워드: page namespace functions inherits model section Razor 키워드는 @(키워드)형태로 이스케이프됩니다. (예를 들어 @(functions))\nC# Razor 키워드 case do default for foreach if else lock switch try catch finally using while C# Razor 키워드는 @(@C# 키워드) 형태로 이중 이스케이프해야 합니다.\n첫 번째 @는 Razor 파서를 이스케이프합니다. 두 번째 @는 C# 파서를 이스케이프합니다. 예: @(@case) Razor에서 사용되지 않는 예약 키워드 class "
},
{
	"uri": "/kr/java-tictactoe/activity-5/",
	"title": "5. (선택 사항) AI 움직임",
	"tags": [],
	"description": "Use Minimax algorithm to pick move for the computer",
	"content": "컴퓨터가 생각하게 만들기 이전 단계에서는 컴퓨터가 랜덤으로 움직임을 선택하도록 만들었습니다. 그러나 이 방법으로는 컴퓨터의 경쟁력이 낮습니다.\n이 단계에서는 Minimax 알고리즘을 사용하여 인공지능을 프로그램에 추가함으로써 게임의 난이도를 높이겠습니다.\nMinimax 알고리즘 Minimax 알고리즘은 두 플레이어가 있는 게임에서 각 플레이어가 최선의 결정을 내리도록 도와줍니다.\n두 플레이어는 각각 maximizer와 minimizer로 분류됩니다. maximizer는 승리할 확률을 극대화하는 반면, minimizer는 패배를 최소화하려고 노력합니다.\n알고리즘은 현재 게임 보드를 기반으로 가능한 모든 미래 게임 상태를 검토하며, maximizer와 minimizer가 자신에게 가장 유리한 선택을 할 것이라고 가정합니다.\n우리의 경우 컴퓨터를 maximizer로, 플레이어를 minimizer로 설정할 것입니다. 컴퓨터가 승리 가능성을 극대화하도록 최적의 결정을 내릴 것입니다.\nMinimax 알고리즘이 틱택토에서 작동하는 방식 컴퓨터 **\u0026ldquo;O\u0026rdquo;**의 움직임에 따른 모든 가능한 게임 상태를 검사하고, 승자 또는 무승부가 발생한 게임판에 점수를 매깁니다.\n점수는 다음과 같이 계산됩니다: •\t컴퓨터가 승리한 경우: 1 * (남은 빈 칸의 개수 + 1) •\t플레이어가 승리한 경우: -1 * (남은 빈 칸의 개수 + 1) •\t무승부인 경우: 0\n컴퓨터가 가장 적은 수의 턴으로 이기도록 하기 위해, 컴퓨터가 이기는 게임 상태에 더 높은 점수를 부여합니다.\n다음은 예시입니다:\n첫 번째 행에서의 컴퓨터의 가능한 수: 컴퓨터 \u0026ldquo;O\u0026quot;는 첫 번째 행에서 3가지 가능한 수를 고려합니다.\n모든 게임 상태를 검사: 모든 게임 상태를 검사하여 컴퓨터가 이기거나, 플레이어가 이기거나, 무승부가 될 때까지 진행합니다. 각 상태에 대해 해당 점수를 부여합니다. 예를 들어, 두 번째 보드에서 컴퓨터는 위치 8에 \u0026ldquo;O\u0026quot;를 놓아 승리합니다. 이 상태는 점수 1 * (보드의 남은 자리 수 + 1)로 계산됩니다. 즉, 1 * (2 + 1) = 3이 됩니다.\n승자나 무승부가 없는 상태에서의 점수 선택: 승자나 무승부가 없는 상태에서는 \u0026ldquo;X\u0026quot;가 수를 두는 최소화 라운드에서 가장 작은 점수를 선택하고, \u0026ldquo;O\u0026quot;가 수를 두는 최대화 라운드에서 가장 큰 점수를 선택합니다.\n최적의 수: 위의 과정을 통해 최적의 수를 찾으면, 컴퓨터는 위치 8에 \u0026ldquo;O\u0026quot;를 놓는 것이 최적의 수임을 알 수 있습니다. 이렇게 하면 컴퓨터는 시작 게임 보드에서 1수 만에 승리할 수 있습니다.\n코드 구조 activity-3에서 getComputerMove(String[] curBoard) 메서드를 작성하여 컴퓨터의 움직임을 랜덤하게 선택했습니다. 이번에는 최적의 움직임을 반환하는 getComputerMoveAI(String[] curBoard) 메서드를 작성합니다. 이 메서드는 내부에서 int minimax(String[] curBoard, boolean isMaximizing) 메서드를 호출하여 최적의 결과를 얻습니다.\nint getComputerMove(String[] curBoard){ // 1. this method calls minimax() on all the possible moves the computer can pick // 2. it takes the maximum out of all of them // 3. return the optimal move } int minimax(String[] curBoard, boolean isMaximizing){ // 1. In the maximizing round, it calls minimax() on all the possible moves for the computer, \u0026#34;O\u0026#34;, return the maximum score // 2. In the minimizing round, it calls minimax() on all the possible moves for the player, \u0026#34;X\u0026#34;, return the minimum score } minimax() 메서드는 재귀 함수로, 자기 자신을 호출하면서 다른 가능한 게임 상태들을 검사합니다. 이 메서드는 \u0026ldquo;X\u0026rdquo; 또는 **\u0026ldquo;O\u0026rdquo;**를 각각 가능한 위치에 배치한 후 **minimax()**를 다시 호출하여 최적의 점수를 계산합니다.\ngetComputerMoveAI() 메서드 작성하기 게임 보드에서 사용 가능한 각 위치에 대해 해당 위치에 \u0026quot;O\u0026quot;를 배치하고 minimax()를 호출하여 해당 보드의 점수를 얻습니다.\n두 번째 인수로 false를 전달해야 하는데, 그때는 최소화자(minimizer)의 차례이기 때문입니다. 점수를 얻은 후에는 그 자리를 다시 \u0026quot; \u0026ldquo;로 바꿔야 합니다. 그래야 다음 반복(iteration)에서 게임 보드의 원래 상태를 유지할 수 있습니다.\n각 반복에서 최대 점수와 해당 위치를 추적합니다. 최대 점수를 가진 위치를 반환합니다. \u0026ldquo;현재 최고의 점수를 저장하는 bestScore라는 변수를 만들고, 초기 값으로 Integer.MIN_VALUE(정수의 최소값)를 설정합니다. 이는 데이터 구조에서 최대 값을 찾는 유용한 방법입니다. 예를 들어:\npublic int getLargestNum() { // the following code find the maximum value in the array \u0026#34;nums\u0026#34; int[] nums = {3, 5, -2, 10}; int largestNum = Integer.MIN_VALUE; for(int i = 0; i \u0026lt; nums.length; i++){ if(nums[i] \u0026gt; largestNum){ largestNum = nums[i]; } } return largestNum; } 메서드 \u0026lsquo;minimax()\u0026lsquo;를 작성하기 위에서 논의한 바와 같이, \u0026lsquo;minimax()\u0026rsquo; 메서드는 \u0026lsquo;int minimax(String[] curBoard, boolean isMaximizing)\u0026rsquo; 헤더를 가지고 있습니다.\n보드에서 \u0026lsquo;getWinner()\u0026lsquo;를 호출하여 우승자가 있는지 확인합니다. 그렇다면 해당 점수를 반환합니다. 점수: 컴퓨터 승리 (\u0026lsquo;1 * 보드에서 사용 가능한 자리 수 + 1\u0026rsquo;), 플레이어 승리 (\u0026rsquo;-1 * 보드에서 사용 가능한 자리 수 + 1\u0026rsquo;), 동점 (\u0026lsquo;0\u0026rsquo;).\n\u0026ldquo;최소 최대 점수 얻기 만약 최대화자(maximizer)의 차례(\u0026ldquo;O\u0026rdquo;)라면, 게임 보드의 각 가능한 위치에 \u0026ldquo;O\u0026quot;를 놓고 minimax()를 호출하여 해당 보드의 점수를 얻습니다.\n만약 최소화자(minimizer)의 차례(\u0026ldquo;X\u0026rdquo;)라면, 게임 보드의 각 가능한 위치에 \u0026ldquo;X\u0026quot;를 놓고 minimax()를 호출하여 해당 보드의 점수를 얻습니다.\u0026rdquo;\n최대 점수 반환 만약 최대화자의 차례(\u0026ldquo;O\u0026rdquo;)라면, 각 반복에서 가장 큰 점수와 해당 위치를 추적하고 그 점수를 반환합니다. 만약 최소화자의 차례(\u0026ldquo;X\u0026rdquo;)라면, 각 반복에서 가장 작은 점수와 해당 위치를 추적하고 그 점수를 반환합니다 메서드 테스트하기 main() 아래에 두 개의 메서드를 복사하여 붙여넣으세요.\nRun을 클릭하여 메서드를 테스트하세요. 위 그림의 예제에 대한 주어진 테스트가 제공됩니다.\n원하는 출력이 나오는지 확인하기 위해 다른 보드를 입력해 볼 수 있습니다 Replit 실행하기\nRemember to test your methods!\n프로그램 업데이트 메서드를 테스트한 후, TicTacToe 프로그램의 모든 getComputerMove() 호출을 getComputerMoveAI()로 업데이트하세요.\n이번에는 이기는 것이 훨씬 더 어려울 겁니다 😀!\n"
},
{
	"uri": "/kr/secret-messages/activity-5/",
	"title": "Activity 5 - ASCII 코드",
	"tags": [],
	"description": "",
	"content": "\n좋아요! 이번 활동에서는 수신자의 이름을 암호화(Encrypt)해 보겠습니다.\nASCII Code 써 봅시다!\nASCII 코드 ASCII 코드는 각 문자에 숫자 값이 있음을 보여줍니다. 예를 들어 \u0026lsquo;A\u0026rsquo; 문자는 숫자 65, \u0026lsquo;B\u0026rsquo;는 66, \u0026lsquo;C\u0026rsquo;는 67 등입니다.\n다음 목록은 가장 일반적으로 사용되는 문자의 값을 보여줍니다:\n각 문자에는 숫자 값이 있으므로 이를 사용하여 이 문자에 값을 더하거나 뺄 수 있으므로 특정 방식으로 문자의 순서를 변경할 수 있습니다. 문자(\u0026lsquo;char\u0026rsquo;)를 숫자(\u0026lsquo;int\u0026rsquo;)로 변환하거나 그 반대로 변환할 수 있습니다.\nExample\nchar letter = \u0026#39;A\u0026#39;;\rint letter_value = letter;\rcout \u0026lt;\u0026lt; letter \u0026lt;\u0026lt; \u0026quot; = \u0026quot; \u0026lt;\u0026lt; letter_value \u0026lt;\u0026lt; endl; This will print:\nA = 65 이 예제에서는 문자를 변수 유형 char에 저장합니다. 그런 다음 int 유형 변수에서는 문자 유형 변수를 저장하지만, 두 번째 변수는 숫자를 저장하므로 ASCII 코드에 따라 문자를 숫자 값으로 변환합니다.\n우리는 반대로 할 수 있습니다. 예를 들어:\nint letter_value = 67;\rchar letter = letter_value;\rcout \u0026lt;\u0026lt; letter_value \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; letter \u0026lt;\u0026lt; endl; This will print:\n67 = C 암호화 방법 이제 우리는 키워드(keyword)를 사용하여 이름을 암호화할 것입니다. 프로그램은 다음과 같은 방식으로 작동합니다: •\t이름의 각 문자와 키워드의 각 문자를 더합니다. •\t결과로 나온 새 문자를 암호화된 메시지에 저장합니다. •\t키워드의 길이가 끝나면 다시 처음으로 돌아갑니다.\n예제: •\t키워드: \u0026ldquo;queen\u0026rdquo; •\t암호화할 이름: \u0026ldquo;programmer\u0026rdquo;\n첫 번째 문자 \u0026lsquo;p\u0026rsquo;와 키워드의 첫 번째 문자 \u0026lsquo;q\u0026rsquo;를 더합니다. 결과는 새 문자로 저장됩니다. 두 번째 문자 \u0026lsquo;r\u0026rsquo;과 키워드의 두 번째 문자 \u0026lsquo;u\u0026rsquo;를 더합니다. 키워드가 끝나면 다시 처음 문자 \u0026lsquo;q\u0026rsquo;로 돌아갑니다. 이를 위해 우리는 이미 수행한 작업의 일부를 수집할 것이며 다음 단계를 따라야 합니다:\n먼저, 키워드가 될 \u0026lsquo;string\u0026rsquo; 유형의 변수를 생성합니다. 콘솔에서 받은 입력을 이 변수에 저장합니다. 이것이 이름이 될 것입니다. 처음 두 단계를 반복하면 키워드가 저장됩니다. \u0026lsquo;for\u0026rsquo; 루프를 선언하고 0으로 초기화된 유형의 변수 \u0026lsquo;int\u0026rsquo;를 사용합니다. 루프의 각 사이클에 대해 이 변수에 \u0026lsquo;1\u0026rsquo;을 추가하고 변수가 \u0026lsquo;끈\u0026rsquo; 변수의 \u0026lsquo;크기\u0026rsquo;보다 작을 때 루프를 계속합니다. \u0026lsquo;for\u0026rsquo; 루프의 본문에서 이름 문자 (name[i])와 카운터 위치의 키워드 문자 (key[counter])의 합과 같은 \u0026lsquo;int\u0026rsquo; 변수를 만듭니다. 이 합에서 소문자 \u0026lsquo;a\u0026rsquo;를 빼서 합이 ASCII 코드의 다른 임의 문자가 아닌 문자에 해당하도록 해야 합니다. \u0026lsquo;if\u0026rsquo; 문을 사용하여 문자의 합이 \u0026lsquo;z\u0026rsquo;보다 큰 문자에 해당하는지 확인합니다. 그렇다면 알파벳에서 참된 문자를 얻으려면 \u0026lsquo;25\u0026rsquo;(알파벳의 문자 수)를 빼야 합니다. 문자 name[i]을 \u0026lsquo;합\u0026rsquo; 변수에 포함된 값으로 설정합니다. 이렇게 하면 원래 문자가 새 문자로 변경됩니다. 키워드에서 가져온 카운터에 \u0026lsquo;1\u0026rsquo;을 추가합니다. 키워드 카운터가 \u0026lsquo;키\u0026rsquo; 문자열의 길이보다 크거나 같은지 확인합니다. 그렇다면 카운터를 \u0026lsquo;0\u0026rsquo;으로 재설정합니다. 마지막으로 \u0026lsquo;for\u0026rsquo; 문 뒤에 암호화된 메시지를 콘솔에 인쇄합니다. 언제든지 이전 활동으로 돌아가서 무엇이든 복습할 수 있다는 점을 기억하세요!\n단계가 완료되면 단어 재생 및 암호화를 시작하세요! Run을 누르고 콘솔에 키워드를 입력한 다음 엔터 키, 암호화할 이름 또는 단어, 엔터 키를 입력합니다. 예를 들어, 다음을 복사하여 콘솔에 붙여넣을 수 있습니다:\nprogrammer\rqueen 경고: 이 프로그램에서는 항상 소문자로 문자열과 문자를 작성해야 합니다..\rReplit 실행하기\n중요: 콘솔에 붙여넣으려면 콘솔을 마우스 오른쪽 버튼으로 클릭하고 \u0026ldquo;붙여넣기\u0026quot;를 클릭합니다. 그렇지 않으면 붙여넣기 작업이 제대로 작동하지 않을 수 있습니다.\r© 2022 GitHub, Inc.\n"
},
{
	"uri": "/kr/microbit-distance-checker/running-code/",
	"title": "코드 다운로드 및 테스트",
	"tags": [],
	"description": "",
	"content": "코드를 작성했으니 이제 실행해 보겠습니다. 먼저 마이크로빗을 컴퓨터와 연결해야 합니다. USB 케이블을 찾아 마이크로빗 상단의 은색 USB 포트에 작은 쪽을 연결하고, 다른 큰 쪽은 컴퓨터의 USB 포트에 연결하세요. MakeCode 작업 공간에서 Download 버튼 옆의 작은 … 아이콘을 클릭하여 메뉴를 엽니다. 이 메뉴에서 “Pair device”를 선택하세요.\n새로 뜨는 창에서 오른쪽 하단의 보라색 “Pair device” 버튼을 클릭합니다. 마지막으로 또 다른 창이 나타나면 “BBC micro:bit CMSIS-DAP”를 클릭한 뒤 하단의 “Connect” 버튼을 선택하세요. 이제 마이크로빗이 연결되었으며 코드를 다운로드할 준비가 되었습니다. 이 연결 과정은 한 번만 수행하면 됩니다.\n이제 Download 버튼 옆의 작은 … 아이콘을 다시 클릭합니다. 이번에는 “Download to micro:bit” 옵션을 선택하세요. 다운로드 버튼이 회전을 멈추고 “Download complete” 메시지가 나타나면, 모든 과정이 완료된 것입니다. 같은 라디오 채널에 있는 다른 마이크로빗들로부터 멀리 떨어져 움직여 보세요. 마이크로빗의 찡그린 얼굴이 웃는 얼굴로 바뀌는 것을 확인할 수 있습니다!\n끝났습니다! 축하합니다! 이제 여러분은 두 개의 하드웨어 장치를 무선으로 연결하고, 거리를 측정할 수 있는 코드를 작성했습니다. 정말 잘하셨습니다!👏🏽👏🏽👏🏽\n"
},
{
	"uri": "/kr/javascript-blocks-earsketch/activity-4-use-effects-to-fade-in/",
	"title": "활동 4 - 페이드 인 효과 사용하기",
	"tags": [],
	"description": "",
	"content": "이제 곡에 하나의 효과를 추가했으니, 이번에는 곡의 도입부에 페이드 인 효과를 적용해 보겠습니다.\n활동 3에서는 setEffect 함수를 사용하여 특정 트랙에 곡 전체에 걸쳐 효과를 적용했습니다. 그러나 곡의 특정 부분에만 효과를 적용하고 싶다면 어떻게 해야 할까요? 이때는 매개변수를 더 많이 사용하는 setEffect 함수를 사용해야 합니다.\nstartValue: 매개변수에 적용되는 시작 값 start: 시작 값을 설정할 마디 endValue: 매개변수에 적용되는 끝 값 end: 끝 값을 설정할 마디 이 setEffect함수 버전을 사용하면 곡의 특정 부분에서 자동화를 실행할 수 있습니다. 자동화란 효과의 값을 시간이 지남에 따라 변경하는 방법입니다. 자동화의 한 가지 예로 곡을 페이드 인 또는 페이드 아웃하는 방법이 있습니다. 이를 위해서는 VOLUME effectType에서 GAIN매개변수(parameter)를 사용하여 음량을 시간에 따라 조절할 수 있습니다. 예를 들어, startValue 를 -60db로, endValue 를 0db로 정의하면, 시간이 지나면서 곡이 점점 커지는 페이드 인 효과가 나타납니다. 시작 지점과 효과의 길이를 조정하려면 start 와 end매개변수를 설정하세요.\n곡에 또 다른 setEffect 함수 추가하기 또 다른 setEffect 블록을 코드에 추가하세요. 이때 블록에 7개의 매개변수가 있는지 확인하세요. 드롭다운을 사용하여 effectType을 VOLUME으로 선택하세요. 드롭다운에서 매개변수(parameter)로 GAIN을 선택하세요. 4.페이드 인 효과를 적용하려면, 음량을 매우 낮게 시작해서 점차 증가시켜야 합니다.startValue 를 -60과 같은 낮은 값으로 설정하고, endValue 를 0과 같은 높은 값으로 설정하세요. 힌트: 음량은 데시벨(decibel)로 측정됩니다. 숫자가 클수록 소리가 커집니다. 또한, 0 데시벨을 초과하지 않도록 주의하세요.\nstart 및 end 매개변수에 값을 설정하여 페이드 인 효과가 시작되고 끝나는 시점을 지정하세요. 이제 코드가 아래와 같이 보일 것입니다:\n"
},
{
	"uri": "/kr/machine-learning/train-model/",
	"title": "Step 6: 모델 훈련하기(Train the model)",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "이제 모델을 훈련시킬 준비가 되었습니다. 우리는 LinearRegression().fit()을 사용하여 모델을 훈련할 것입니다. 이 모델은 score()라는 함수를 가지고 있으며, 이는 예측의 결정 계수 R²를 반환합니다. 지금은 R² 값이 높을수록 더 좋은 모델이라는 것만 기억하면 됩니다.\n# 훈련 데이터 준비 x_train = train_data[features] y_train = train_data[target] # 선형 회귀 적용 # fit()는 모델을 훈련하는 함수입니다. model = LinearRegression().fit(x_train,y_train) # 모델의 점수 출력 print(\u0026#34;Score: \u0026#34; + str(model.score(x_train,y_train))) 출력 결과:\nScore: 0.9875123836174596 "
},
{
	"uri": "/kr/security-phishing/summary/",
	"title": "요약",
	"tags": [],
	"description": "",
	"content": "결론 다음은 피싱 사기의 일반적인 특징이에요:\n너무 좋은 제안이나 관심을 끌 만한 문구. 평소와 다른 발신자이거나 예상치 못한 메시지. 시간을 제한하며 빨리 행동하라고 재촉하는 문구. 예: \u0026ldquo;비밀번호가 곧 만료됩니다. 즉시 변경하려면 여기를 클릭하세요.\u0026rdquo; 수상한 하이퍼링크. 링크 위에 마우스를 올려두면 실제로 연결될 URL을 볼 수 있어요. 맞춤법 오류나 문법적 실수. 예: mail@g00gle.com\r(g00gle 대신 google). 알 수 없는 파일 이름이나 확장자를 가진 이메일 첨부 파일. 해결 방법 \u0026ldquo;어떤 게 피싱일까?\u0026rdquo; 활동에서 다음 이메일과 문자가 피싱일 가능성이 높았어요:\nspotifyaccounts에서 온 이메일. 무료 AirPods 제공을 약속하는 Amazon의 문자. 음성 알림이 있다는 이메일. 인터넷에서 무엇을 업로드하거나 다운로드할 때는 항상 주의하세요!\n"
},
{
	"uri": "/kr/chatbot/categories/",
	"title": "카테고리",
	"tags": [],
	"description": "",
	"content": "AIML 기초 AIML의 기본 단위는 카테고리입니다. 카테고리는 **패턴(pattern)**과 **템플릿(template)**으로 구성됩니다. 패턴은 사용자가 봇에게 말하는 내용이고, 템플릿은 봇이 사용자에게 제공하는 응답입니다.\n다음 예시를 보면, 패턴은 \u0026ldquo;HELLO\u0026quot;이고 템플릿은 \u0026ldquo;Hello, World!\u0026ldquo;입니다. 사용자가 \u0026ldquo;HELLO\u0026quot;라고 말하면, 봇은 \u0026ldquo;Hello, World!\u0026ldquo;라고 응답합니다. 패턴 매칭은 대소문자를 구분하지 않으므로, \u0026ldquo;hello\u0026rdquo;, \u0026ldquo;HELLO\u0026rdquo;, \u0026ldquo;Hello\u0026rdquo;, \u0026ldquo;HeLlo\u0026rdquo; 등 다양한 형태의 입력에도 동일한 응답이 나옵니다.\n\u0026lt;category\u0026gt;\r\u0026lt;pattern\u0026gt;HELLO\u0026lt;/pattern\u0026gt;\r\u0026lt;template\u0026gt;\rHello, World!\r\u0026lt;/template\u0026gt;\r\u0026lt;/category\u0026gt; 패턴을 작성할 때는 모든 문자를 대문자로 작성하고, 구두점 사용을 피하는 것이 좋습니다. 예를 들어, \u0026ldquo;What is your name?\u0026ldquo;이라는 패턴을 만들고 싶다면 \u0026ldquo;WHAT IS YOUR NAME\u0026quot;으로 작성해야 합니다. Pandora는 패턴 매칭을 수행하기 전에 사용자 입력에서 구두점을 제거합니다.\n"
},
{
	"uri": "/kr/razor/activity-3/",
	"title": "활동 3 - 웹 애플리케이션 만들기",
	"tags": [],
	"description": "",
	"content": "활동 지침 프로젝트 생성 Visual Studio Code가 열려 있는지 확인합니다.\n액티비티 바(Activity Bar)에서 Explorer 아이콘을 선택합니다.\nCreate .NET Project 버튼을 클릭합니다.\n명령 팔레트(Command Palette)가 드롭다운 형태로 나타나며 프로젝트 유형 목록이 표시됩니다.\n제공된 목록에서 Blazor Server App을 선택합니다.\n새 애플리케이션을 저장할 폴더를 선택합니다.\n애플리케이션에 이름을 지정합니다.\n애플리케이션이 생성되며, 탐색기(Explorer)에서 Solution 메뉴가 표시됩니다.\n이제 여러분이 직접 만든 페이지가 생겼습니다!\nRazor Pages 프로젝트 구조 검토 아래 표는 생성된 Razor Pages 프로젝트 구조를 설명합니다:\n이름 설명 Pages/ Razor 페이지와 지원 파일을 포함합니다. 각 Razor 페이지는 .cshtml 파일과 .cshtml.cs PageModel 클래스 파일을 가집니다. wwwroot/ HTML, JavaScript, CSS와 같은 정적 자산 파일을 포함합니다. ContosoPizza.csproj 프로젝트의 종속성과 같은 구성 메타데이터를 포함합니다. Program.cs 앱의 진입점 역할을 하며, 라우팅과 같은 앱의 동작을 구성합니다. 기타 주요 관찰 사항:\nRazor 페이지 파일과 PageModel 클래스 파일의 쌍\nRazor 페이지는 Pages 디렉터리에 저장됩니다. 각 Razor 페이지는 다음 두 가지 파일로 구성됩니다: .cshtml 파일: 프레젠테이션(HTML 마크업) 담당. .cshtml.cs 파일(PageModel 클래스): 로직 분리를 담당. PageModel 클래스의 역할: Razor 페이지의 로직과 프레젠테이션을 분리. 요청을 처리하기 위한 페이지 핸들러(page handlers) 정의. Razor 페이지에 한정된 데이터 속성과 로직을 캡슐화. Pages 디렉터리 구조와 요청 라우팅\nPages 디렉터리는 Razor Pages의 파일과 구조를 관리하며, 라우팅 요청을 처리합니다. Razor Pages는 Pages 디렉터리 구조를 사용하여 요청 라우팅 규칙을 정합니다.\n다음 표는 URL이 파일명으로 매핑되는 방식을 보여줍니다:\nURL 매핑되는 Razor 페이지 www.domain.com\rPages/Index.cshtml www.domain.com/Index\rPages/Index.cshtml www.domain.com/Privacy\rPages/Privacy.cshtml www.domain.com/Error\rPages/Error.cshtml Pages 디렉터리의 하위 폴더는 Razor 페이지를 체계적으로 구성하는 데 사용됩니다. 예를 들어, Pages/Products 디렉터리가 있다면 URL은 아래와 같이 매핑됩니다:\nURL 매핑되는 Razor 페이지 www.domain.com/Products\rPages/Products/Index.cshtml www.domain.com/Products/Index\rPages/Products/Index.cshtml www.domain.com/Products/Create\rPages/Products/Create.cshtml 레이아웃 및 공용 파일 Razor Pages는 여러 페이지에서 공통으로 사용되는 파일들을 지원합니다. 이 파일들은 공통 레이아웃 요소와 페이지에서 공유되는 설정을 정의합니다. 다음 표는 주요 공용 파일의 목적을 설명합니다:\n파일명 설명 _ViewImports.cshtml 여러 페이지에서 사용되는 네임스페이스와 클래스를 가져옵니다. _ViewStart.cshtml 모든 Razor 페이지에 적용되는 기본 레이아웃을 지정합니다. Pages/Shared/_Layout.cshtml _ViewStart.cshtml 파일에 의해 지정된 레이아웃으로, 여러 페이지에서 공통 레이아웃 요소를 구현합니다. Pages/Shared/_ValidationScriptsPartial.cshtml 모든 페이지에 유효성 검사 기능을 제공합니다. 프로젝트 실행 Visual Studio Code 열기 및 탐색기 선택 확인\nVisual Studio Code가 열려 있는지 확인하고, 액티비티 바(Activity bar)에서 탐색기(Explorer)가 선택되어 있는지 확인합니다. 솔루션 탐색기에서 프로젝트 실행\n솔루션 탐색기(Solution Explorer)에서 프로젝트 이름을 마우스 오른쪽 버튼으로 클릭합니다.\nDebug(디버그)를 선택한 후, Start new instance(새 인스턴스 시작)를 선택합니다.\n이 작업은 새 웹사이트를 빌드하고 실행합니다.\n웹사이트에서 Counter 및 Fetch Data 링크를 클릭하여 페이지를 탐색합니다. 랜딩 페이지 사용자 지정 웹 애플리케이션에 더 적합하도록 랜딩 페이지를 변경해 봅시다.\nPages/Index.razor 파일에서 아래 C# 코드를 추가합니다: @code { TimeSpan timeInBusiness = DateTime.Now - new DateTime(2010, 01, 17); } 위 코드는 비즈니스가 시작된 이후 경과한 시간을 계산합니다.\nPageTitle 요소를 “Welcome to my first web page” 로 변경합니다.\nh1 요소를 “Welcome to my first Razor web app” 로 변경합니다.\n나머지 텍스트를 아래 코드로 대체합니다:\n\u0026lt;p class=\u0026#34;lead\u0026#34;\u0026gt;The best website in town for @Convert.ToInt32(timeInBusiness.TotalDays) days!\u0026lt;/p\u0026gt; 코드 설명:\n텍스트의 의미: 2010년 1월 17일부터 경과한 일수를 표시합니다. Razor 구문 사용: 기호를 사용하여 HTML에서 Razor 구문으로 전환합니다. Convert.ToInt32 메서드: timeInBusiness 변수의 TotalDays 속성을 정수로 변환합니다. Convert 클래스: System 네임스페이스의 일부이며, .csproj 파일의 \u0026lt;ImplicitUsings\u0026gt; 요소에 의해 자동으로 가져옵니다. 파일을 저장한 후, 앱이 실행 중인 브라우저 탭을 새로고침하여 변경 내용을 확인합니다. "
},
{
	"uri": "/kr/secret-messages/activity-6/",
	"title": "Activity 6 - 함수 (Functions)",
	"tags": [],
	"description": "",
	"content": "\n좋아요!\n여러분은 이미 프로그램의 많은 부분을 완성했습니다!\n이번 활동에서는 **함수(Function)**를 사용하여 코드를 섹션 별로 그룹화합니다.\n함수(Function) 함수를 사용하면 프로그램의 작업을 작은 작업 단위로 나누어 메인 함수(main function)와 분리할 수 있습니다.\n함수를 하나의 기계로 생각할 수 있습니다. •\t기계를 켜면 명령어가 실행되어 최종 결과를 반환합니다. •\t서로 다른 프로세스를 수행하는 여러 기계를 만들 수 있으며, 각각의 기계는 이름과 반환 결과 유형으로 구별됩니다.\n이번 활동에서는 반환 값이 없는 void 유형의 함수를 사용합니다. 이 함수들은 명령어만 처리하며 아무것도 반환하지 않습니다.\n수를 선언(생성)하려면 주 함수 외부를 사용해야 합니다:\nvoid name_function(){\r//Code here\r} 코드 분석:\n반환 유형(Return type): 함수가 반환할 객체의 유형을 나타냅니다. 여기서는 void를 사용하여 반환값이 반환 값이(띄어쓰기) 없음을 지정합니다.\n함수 이름(Function name): 이 예에서는 name_function입니다.\n괄호 (): 함수임을 나타내기 위해 함수 이름 뒤에 추가합니다.\n중괄호 {}: 함수 실행 시 수행할 명령어 블록을 나타냅니다.\n함수 호출하기 우리가 선언한 함수는 main() 함수 외부에 있으므로, Run을 눌러도 함수 내부의 명령어가 실행되지 않습니다. 따라서 main() 함수 내에서 함수를 호출해야 합니다. 함수를 호출하려면 아래와 같이 작성합니다:\nname_function(); 함수 이름 뒤에 괄호를 추가하고 세미콜론(;)으로 끝냅니다.\n이렇게 하면 name_function() 내부의 명령어가 실행됩니다.\n함수의 매개변수(Parameters) 함수를 선언할 때 **매개변수(parameters)**를 전달할 수 있습니다. 매개변수는 함수가 명령어를 실행하는 데 사용할 추가 객체들입니다. 매개변수는 함수의 괄호 안에 작성합니다.\n예제:\nvoid name_function(int sum, int \u0026amp;number){\rnumber += sum;\r} 그리고 main() 함수에서는 몇 가지 매개변수를 사용하여 \u0026lsquo;이름_함수\u0026rsquo;라고 부를 수 있습니다:\nint main(){\rint x = 25;\rint y = 5;\rname_function(y, x);\r} 우리가 무엇을 했는지 자세히 이해해 봅시다:\nname_function을 선언할 때 괄호 안에 어떤 변수를 함수에 전달할지 적습니다. 그런 다음 함수 본문에서 이러한 변수를 사용할 수 있습니다. main에는 이미 두 개의 변수가 선언되어 있었고, 이 변수를 매개변수로 변환하여 생성된 함수 name_function에 전달했습니다. 이렇게 하면 변수 sum 은 변수 y와 같습니다. 변수 \u0026lsquo;숫자\u0026rsquo; 앞에는 이 기호 \u0026lsquo;\u0026amp;\u0026lsquo;이 있습니다. 즉, 함수 내에서 변수를 수정하면 주 함수에서 변수로 전달하는 변수도 수정됩니다. 즉, 변수 \u0026lsquo;x\u0026rsquo;는 앞에 기호를 쓸 때 참고로 전달하기 때문에 함수에 의해 수정됩니다. 이 기호를 넣지 않으면 함수에 값을 수정하더라도 main의 변화를 볼 수 없습니다. 좋아요!\n이제 메시지를 암호화하는 함수와 복호화하는 함수 두 가지를 만들어 보겠습니다. 이를 위해 이미 가지고 있던 코드를 사용하고 새로운 것도 프로그래밍할 것입니다.\n먼저 암호화와 마찬가지로 이름을 복호화하는 void 유형의 반환 함수를 선언합니다. 이 함수의 이름을 \u0026lsquo;decrypt()\u0026lsquo;로 지정합니다.\n\u0026lsquo;암호화()\u0026rsquo;encrypt() 함수의 내용을 새로운 \u0026lsquo;복호화\u0026rsquo; 함수에 복사합니다.\n\u0026lsquo;합\u0026rsquo;sum 변수에서는 키워드의 이름과 문자를 추가하는 대신 문자 \u0026lsquo;a\u0026rsquo;를 추가하고, 마지막 문자가 임의 문자가 아닌 알파벳의 문자가 되도록 문자 \u0026lsquo;a\u0026rsquo;를 추가합니다.\n조건을 변경하여 알파벳을 입력합니다. \u0026lsquo;합\u0026rsquo;이 문자 \u0026lsquo;z\u0026rsquo;보다 큰지 확인하는 대신 \u0026lsquo;합\u0026rsquo;이 \u0026lsquo;a\u0026rsquo;보다 작은지 확인합니다. 그렇다면 뺄셈 대신 변수에 \u0026lsquo;25\u0026rsquo;를 추가합니다.\nmain 함수에서 메시지를 암호화할지 복호화할지에 따라 해당 함수를 \u0026lsquo;if\u0026rsquo; 조건으로 호출합니다.\n완료되면 Run 키를 누르고 다음 예제를 시도해 볼 수 있습니다:\nprogrammer\r1\rreina witvczxipigrmg\r2\rreina 당신도 자신만의 비밀 단어를 사용해 보세요!\n경고: 이 프로그램에서는 항상 소문자로 문자열과 문자를 작성해야 합니다.\r항상 이전 활동으로 돌아갈 수 있다는 점을 기억하세요\nReplit 실행하기\n중요: 콘솔에 붙여넣으려면 콘솔을 마우스 오른쪽 버튼으로 클릭하고 \u0026ldquo;붙여넣기\u0026quot;를 클릭합니다. 그렇지 않으면 붙여넣기 작업이 제대로 작동하지 않을 수 있습니다.\r"
},
{
	"uri": "/kr/machine-learning/model-testing-data/",
	"title": "Step 7: 테스트 데이터로 모델 평가하기",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "이제 훈련된 모델을 사용하여 테스트 데이터에 있는 선수들의 종합 능력치를 예측해보겠습니다. 훈련 데이터와 동일한 방식으로 x_test와 y_test를 생성합니다. model.predict()는 예측 결과 목록을 생성합니다. 예측된 결과와 실제 종합 능력치를 비교해봅시다.\n# 목표값(종합 능력치)을 기준으로 테스트 데이터를 정렬 test_data = test_data.sort_values([target], ascending=False) x_test = test_data[features] y_test = test_data[target] # 예측된 결과 생성 y_pred = model.predict(x_test) # 예측된 종합 능력치 열을 테스트 데이터에 추가 test_data[\u0026#39;Predicted Overall\u0026#39;] = y_pred.copy() # 예측 차이 비율을 계산하여 테스트 데이터에 추가 difference = (y_pred - y_test) / y_test * 100 test_data[\u0026#39;Difference (%)\u0026#39;] = difference # 결과 출력 test_data[[\u0026#34;Name\u0026#34;, \u0026#34;Nationality\u0026#34;, \u0026#34;Club\u0026#34;, \u0026#34;Overall\u0026#34;, \u0026#34;Predicted Overall\u0026#34;, \u0026#34;Difference (%)\u0026#34;]] Name\rNationality\rClub\rOverall\rPredicted Overall\rDifference (%)\r1\rCristiano Ronaldo\rPortugal\rJuventus\r94\r91.973701\r-2.155638\r10\rR. Lewandowski\rPoland\rFC Bayern München\r90\r88.135513\r-2.071652\r23\rS. Agüero\rArgentina\rManchester City\r89\r87.807637\r-1.339733\r48\rC. Immobile\rItaly\rLazio\r87\r85.933234\r-1.226168\r159\rLouri Beretta\rBrazil\rAtlético Mineiro\r83\r81.583941\r-1.706096\r193\rRodrigo\rSpain\rValencia CF\r83\r81.784946\r-1.463921\r179\rS. Gnabry\rGermany\rFC Bayern München\r83\r79.978980\r-3.639783\r315\rDavid Villa\rSpain\rNew York City FC\r82\r81.259066\r-0.903578\r362\rPaco Alcácer\rSpain\rBorussia Dortmund\r81\r81.836532\r1.032756\r518\rAlexandre Pato\rBrazil\rTianjin Quanjian FC\r80\r78.322831\r-2.096461\r499\rL. de Jong\rNetherlands\rPSV\r80\r79.993062\r-0.008672\r523\rK. Gameiro\rFrance\rValencia CF\r80\r79.130702\r-1.086622\r721\rB. Yılmaz\rTurkey\rTrabzonspor\r79\r78.092396\r-1.148866\r693\rS. Jovetić\rMontenegro\rAS Monaco\r79\r79.353044\r0.446891\r591\rL. Alario\rArgentina\rBayer 04 Leverkusen\r79\r79.066446\r0.084109\r569\rAndré Silva\rPortugal\rSevilla FC\r79\r79.925229\r1.171175\r588\rM. Philipp\rGermany\rBorussia Dortmund\r79\r78.962674\r-0.047248\r561\rL. Martínez\rArgentina\rInter\r79\r79.411940\r0.521443\r874\rA. Dzyuba\rRussia\rNaN\r78\r76.855093\r-1.467829\r825\rS. García\rUruguay\rGodoy Cruz\r78\r77.375588\r-0.800528\r909\rV. Germain\rFrance\rOlympique de Marseille\r77\r77.509005\r0.661045\r1095\rN. Jørgensen\rDenmark\rFeyenoord\r77\r76.745918\r-0.329976\r992\rJ. Sand\rArgentina\rDeportivo Cali\r77\r78.886169\r2.449570\r1137\rRubén Castro\rSpain\rUD Las Palmas\r77\r77.797984\r1.036343\r895\rM. Harnik\rAustria\rSV Werder Bremen\r77\r76.926679\r-0.095222\r1413\rAlan Carvalho\rBrazil\rGuangzhou Evergrande Taobao FC\r76\r75.922866\r-0.101492\r1327\rK. Dolberg\rDenmark\rAjax\r76\r76.060831\r0.080041\r1496\rF. Montero\rColombia\rSporting CP\r76\r77.017187\r1.338404\r1240\rI. Popov\rBulgaria\rSpartak Moscow\r76\r75.734350\r-0.349540\r1357\rI. Slimani\rAlgeria\rFenerbahçe SK\r76\r76.494507\r0.650667\r...\r...\r...\r...\r...\r...\r...\r17484\rJ. Lankester\rEngland\rIpswich Town\r54\r56.121884\r3.929415\r17469\rJ. Gallagher\rRepublic of Ireland\rAtlanta United\r54\r54.692444\r1.282304\r17501\rM. Saavedra\rChile\rAudax Italiano\r54\r54.137463\r0.254561\r17361\rE. McKeown\rEngland\rColchester United\r54\r52.796085\r-2.229473\r17399\rMao Haoyu\rChina PR\rTianjin TEDA FC\r54\r53.964477\r-0.065783\r17313\rM. Howard\rEngland\rPreston North End\r54\r53.339370\r-1.223389\r17355\rV. Barbero\rArgentina\rBelgrano de Córdoba\r54\r54.011344\r0.021008\r17422\rY. Ogaki\rJapan\rNagoya Grampus\r54\r54.041024\r0.075970\r17447\rXie Weijun\rChina PR\rTianjin TEDA FC\r54\r53.452376\r-1.014118\r17367\rT. Lauritsen\rNorway\rOdds BK\r54\r54.944641\r1.749336\r17482\rF. Al Birekan\rSaudi Arabia\rAl Nassr\r54\r52.727175\r-2.357084\r17609\rS. Jamieson\rScotland\rSt. Mirren\r53\r53.509650\r0.961604\r17716\rM. Knox\rScotland\rLivingston FC\r53\r52.826053\r-0.328201\r17578\rLei Wenjie\rChina PR\rShanghai SIPG FC\r53\r52.770581\r-0.432867\r17665\rJ. Smylie\rAustralia\rCentral Coast Mariners\r53\r52.469974\r-1.000049\r17611\rFelipe Ferreyra\rBrazil\rCuricó Unido\r53\r52.861431\r-0.261451\r17765\rA. Georgiou\rCyprus\rStevenage\r52\r52.167786\r0.322665\r17757\rL. Smyth\rNorthern Ireland\rStevenage\r52\r51.999942\r-0.000111\r17923\rA. Reghba\rRepublic of Ireland\rBohemian FC\r51\r51.075501\r0.148041\r17956\rC. Murphy\rRepublic of Ireland\rCork City\r51\r51.731985\r1.435265\r17971\rM. Najjar\rAustralia\rMelbourne City FC\r51\r51.035541\r0.069688\r18013\rW. Møller\rDenmark\rEsbjerg fB\r51\r50.796960\r-0.398118\r18062\rGao Dalun\rChina PR\rJiangsu Suning FC\r50\r49.677371\r-0.645259\r18094\rM. Al Dhafeeri\rSaudi Arabia\rAl Batin\r50\r51.553964\r3.107928\r18063\rR. Hackett-Fairchild\rEngland\rCharlton Athletic\r50\r50.140762\r0.281524\r18028\rD. Asonganyi\rEngland\rMilton Keynes Dons\r50\r50.349896\r0.699792\r18140\rK. Hawley\rEngland\rMorecambe\r49\r49.787332\r1.606799\r18166\rN. Ayéva\rSweden\rÖrebro SK\r48\r48.802935\r1.672781\r18177\rR. Roache\rRepublic of Ireland\rBlackpool\r48\r49.226015\r2.554197\r18200\rJ. Young\rScotland\rSwindon Town\r47\r48.019387\r2.168908\r538 열 × 6 칸\n놀랍지 않나요? 이제 여러분이 만든 이 모델을 사용하면 전 세계 어떤 축구 선수의 종합 능력치도 예측할 수 있습니다!\n이제 결과를 시각화하는 작업을 해보겠습니다.\n# 결과 시각화 plt.scatter(range(0,y_test.shape[0]), y_test, color=\u0026#39;blue\u0026#39;, label=\u0026#34;Actual\u0026#34;) plt.plot(range(0,y_test.shape[0]), y_pred, color=\u0026#39;red\u0026#39;, label=\u0026#34;Predicted\u0026#34;) # 눈금, 라벨, 범례 추가 plt.xticks(()) plt.xlabel(\u0026#34;Players (Sorted by Actual Overall ratings)\u0026#34;) plt.ylabel(\u0026#34;Overall ratings\u0026#34;) plt.legend(loc=\u0026#39;upper right\u0026#39;) plt.show() "
},
{
	"uri": "/kr/chatbot/activity-3/",
	"title": "활동 3: 나만의 카테고리 추가",
	"tags": [],
	"description": "",
	"content": "카테고리 추가하기 지금까지는 봇이 \u0026ldquo;Hello\u0026quot;라는 말에만 응답할 수 있었습니다. 이제 더 많은 카테고리를 추가하여 봇이 더 많은 질문에 응답할 수 있도록 해봅시다.\n여러분이 \u0026ldquo;What is your name?\u0026ldquo;이라고 입력하면, 봇이 \u0026ldquo;My name is Chatbot\u0026quot;이라고 응답합니다. 여러분이 \u0026ldquo;What is your favorite color?\u0026ldquo;라고 입력하면, 봇이 \u0026ldquo;My favorite color is blue\u0026quot;라고 응답합니다. 여러분이 \u0026ldquo;What is your favorite food?\u0026ldquo;라고 입력하면, 봇이 \u0026ldquo;My favorite food is pizza\u0026quot;라고 응답합니다. 카테고리의 기본 구조는 다음과 같습니다:\n\u0026lt;category\u0026gt;\r\u0026lt;pattern\u0026gt;HELLO\u0026lt;/pattern\u0026gt;\r\u0026lt;template\u0026gt;\rHello, World!\r\u0026lt;/template\u0026gt;\r\u0026lt;/category\u0026gt; 패턴을 작성할 때는 항상 대문자로 작성하고, 구두점은 사용하지 마세요. 예를 들어, \u0026ldquo;What is your name?\u0026ldquo;이라는 패턴을 작성할 때는 \u0026ldquo;WHAT IS YOUR NAME\u0026quot;으로 작성해야 합니다.\n카테고리를 수정한 후에는 파일을 저장해야 봇과 상호작용할 수 있습니다.\n이제 이러한 카테고리들을 여러분의 봇에 추가하고, 채팅 위젯을 사용하여 테스트해 보세요. 이제 봇은 \u0026ldquo;Hello\u0026rdquo;, \u0026ldquo;What is your name?\u0026rdquo;, \u0026ldquo;What is your favorite color?\u0026rdquo;, \u0026ldquo;What is your favorite food?\u0026ldquo;에 응답할 수 있어야 합니다.\n"
},
{
	"uri": "/kr/razor/activity-4/",
	"title": "활동 4 - 새로운 Razor 페이지 추가",
	"tags": [],
	"description": "",
	"content": "활동 지침 새 페이지 생성하기 Visual Studio Code가 열려 있는지 확인합니다.\n액티비티 바(Activity bar) 에서 탐색기(Explorer) 가 선택되어 있는지 확인합니다.\n솔루션 탐색기(Solution Explorer) 에서 Pages 디렉터리 옆에 있는 Add new file… 버튼을 선택합니다.\n그럼 파일 유형을 선택할 수 있습니다.\n나타나는 파일 유형 목록에서 Razor component 를 선택합니다. 새 파일의 이름을 todo 로 지정하고 Enter를 누릅니다.\n파일이 생성되며, 편집기(Editor)에서 열립니다.\n파일을 업데이트하여 @page 지시문을 추가합니다. 이를 통해 페이지가 /todo 경로에 응답하도록 설정합니다.\n페이지 제목을 설정하려면 \u0026lt;PageTitle\u0026gt; 태그를 사용합니다.\n네비게이션에 페이지 링크 추가 Shared 디렉터리에서 NavMenu.razor 파일을 찾아 엽니다.\nFetch Data 항목 위에 Fetch Data \u0026lt;div\u0026gt;를 복사한 후 Todo 링크로 수정합니다.\n솔루션 탐색기(Solution Explorer) 에서 프로젝트 이름을 오른쪽 클릭합니다.\nDebug(디버그) 를 선택하고 **Start new instance(새 인스턴스 시작)**를 선택합니다.\n브라우저에서 앱을 열어 To Do List 페이지가 추가되었는지 확인합니다.\nTo Do List 만들기 TodoItem.cs 라는 새 클래스 파일을 만들어 todo 객체를 나타내는 클래스를 생성해주세요.\n프로젝트 창의 맨 윗부분에서 Add new file… 버튼을 클릭하고 목록에서 Class를 선택해주세요. 이름을 TodoItem으로 지정해주세요.\nTodoItem에 문자열 타입의 Title과 IsDone이라는 boolean(불리언 속성)을 추가하려면 다음 코드를 추가해주세요.\npublic class TodoItem { public string? Title { get; set; } public bool IsDone { get; set; } } todo.razor 파일로 돌아가서 다음을 수행해주세요:\n@code 블록에서 TodoItem의 리스트 객체(List object)인 todos를 추가해주세요. Todo 컴포넌트는 이 필드를 사용하여 todo 리스트 상태를 유지합니다. “Todo”라는 제목(\u0026lt;h3\u0026gt;)을 추가해주세요. 제목 아래에 순서 없는 목록 마크업(\u0026lt;ul\u0026gt;)과 foreach 루프를 추가하여 각 todo 항목을 목록 항목(\u0026lt;li\u0026gt;)으로 렌더링해주세요. 순서 없는 목록 아래에 “Something todo”라는 placeholder를 포함하는 텍스트 입력 필드(\u0026lt;input\u0026gt;)와 “Add todo”라는 텍스트를 가진 버튼(\u0026lt;button\u0026gt;)을 추가해주세요. Add todo 버튼을 클릭하면 현재는 아무 일도 일어나지 않습니다. 이제 이벤트 핸들러를 추가해야 합니다.\n버튼에 onclick 액션을 포함하도록 변경해주세요. @code 블록에서: 새 todo의 이름을 저장할 새로운 문자열을 추가해주세요. AddTodo 메서드를 추가하여 새 문자열에 텍스트가 있는지 확인해주세요. 이는 문자열의 IsNullOrWhiteSpace 메서드를 사용하여 수행할 수 있습니다. 텍스트가 있으면 해당 텍스트를 제목으로 사용하는 TodoItem 인스턴스를 생성하고, 이전에 생성한 리스트 객체에 해당 인스턴스를 추가해주세요. newTodo를 빈 문자열로 설정하여 텍스트 입력 필드의 값을 지우세요. 텍스트 \u0026lt;input\u0026gt; 요소를 수정하여 @bind 속성을 사용해 newTodo와 바인딩해주세요. 목록을 업데이트하여 제목을 편집 가능한 입력 필드(\u0026lt;input\u0026gt;)로 만들고, 완료된 항목을 추적할 체크박스를 추가해주세요. 체크박스를 todo의 IsDone 속성에 @bind 해주세요.\n\u0026lt;h3\u0026gt;를 업데이트하여 완료되지 않은 todo 항목의 수를 표시해주세요.\n앱의 새 인스턴스를 저장하고 실행하여 테스트해주세요.\n"
},
{
	"uri": "/kr/secret-messages/activity-7/",
	"title": "Activity 7 - 입력 줄 (Input Line)",
	"tags": [],
	"description": "",
	"content": "\n축하합니다!\n여러분은 이제 왕국을 완전히 구해내는 것에 아주 가까워졌습니다. 이제 남은 것은 전체 문장을 입력할 수 있는 기능을 추가하는 것뿐입니다! 이를 위해 몇 가지만이 필요합니다. 먼저, string:getline() 문장을 사용하여 입력을 받아야 합니다.\nstring phrase;\rgetline(cin, phrase); 이 방법을 사용하면 콘솔에서 한 단어만이 아니라 전체 메시지를 입력할 수 있게 됩니다.\n다음 단계를 따라 프로그램을 완성하여 왕국을 구하세요:\nmain 함수에서 cin \u0026gt;\u0026gt; name; 문장을 getline(cin, name);으로 변경하세요.\n두 함수 모두에서 for 루프에 if 조건문을 추가하세요. 이 조건문은 현재 문자가 \u0026lsquo;a\u0026rsquo; 이상이고 \u0026lsquo;\u0026gt;=\u0026rsquo; \u0026lsquo;z\u0026rsquo; 이하인 \u0026lsquo;\u0026lt;=\u0026rsquo; 경우에만 루프의 내용을 실행하도록 하세요. 이렇게 하면 느낌표, 쉼표, 공백, 기타 특수 문자를 암호화하거나 복호화하는 것을 무시할 수 있습니다.\n프로그램이 작동하는 방식을 잊지 마세요:\n먼저 프로그램이 사용자에게 이름을 요청합니다. 다음으로, 메시지를 1 암호화 (for encryption) 또는 2 복호화(for decryption) 해야 할 지 결정해야 합니다. 마지막으로, 암호화하거나 복호화할 메시지를 입력합니다. 이 프로그램으로 자신만의 비밀 메시지를 만들어보거나 친구들의 메시지를 복호화해보세요!\n경고: 이 프로그램에서는 항상 문자열과 문자를 소문자로 작성해야 합니다..\r이전 활동으로 돌아가 필요한 내용을 언제든지 다시 검토할 수 있다는 것을 기억하세요!\nReplit 실행하기\n"
},
{
	"uri": "/kr/machine-learning/closing/",
	"title": "마무리하기",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "잘하셨습니다! 여러분이 해냈습니다!\n이제 이 데이터셋을 조금 더 다뤄볼 수 있습니다.\n다른 포지션의 선수들, 예를 들어 골키퍼(GK)를 선택해 보세요. 상위 상관관계가 높은 특징들은 무엇일까요? 여러분이 선택한 특징들은 어떤 것인가요? 선택한 특징을 변경해보세요. 그러면 모델 예측 결과가 달라질까요? 훈련/테스트 데이터 비율을 변경해보세요. 어떤 변화가 생기나요? 목표 변수를 변경해보세요. 예를 들어, 가치(Value)나 임금(Wage)을 예측해보세요. 숫자로 변환하는 방법을 알아내야 할 것입니다. 힌트: 50k = 50 * 1000, 10M = 10 * 1000 * 1000. 오늘 수업에서는 축구 선수의 종합 능력치를 예측하기 위해 선형 회귀 모델을 훈련하는 방법을 배웠습니다. 이 과정을 즐겼고, 조금이라도 영감을 받았길 바랍니다.\n이제 Kaggle 웹사이트를 탐색하면서 다른 데이터셋을 찾아보고, 선형 회귀를 적용해 결과를 예측/추정해보세요. 여러분이 할 수 있는 일이 얼마나 많은지 놀라게 될 것입니다. 👏🏽👏🏽👏🏽\n"
},
{
	"uri": "/kr/chatbot/wildcards/",
	"title": "와일드카드(Wildcard)",
	"tags": [],
	"description": "",
	"content": "와일드카드 지금쯤이면 사용자가 질문하는 모든 방식에 대해 카테고리를 작성하는 것에 상당히 많은 작업이 필요하다는 것을 느꼈을 것입니다. 예를 들어, 현재 봇은 \u0026ldquo;Hello\u0026quot;에 \u0026ldquo;Hello, world\u0026quot;로 응답합니다. 하지만 사용자가 \u0026ldquo;Hello there\u0026rdquo; 또는 \u0026ldquo;Hello chatbot\u0026quot;이라고 말한다면 어떻게 될까요? 이런 경우마다 새로운 카테고리를 작성해야 합니다. 다행히도, 봇을 좀 더 유연하게 만들기 위해 사용할 수 있는 추가 도구들이 있습니다.\n그중 하나가 와일드카드입니다. 와일드카드는 어떤 단어나 구도에 맞출 수 있는 특별한 문자입니다. 어떻게 작동하는지 살펴봅시다.\n\u0026lt;category\u0026gt;\r\u0026lt;pattern\u0026gt;HELLO *\u0026lt;/pattern\u0026gt;\r\u0026lt;template\u0026gt;\rHi!\r\u0026lt;/template\u0026gt;\r\u0026lt;/category\u0026gt; * 기호는 사용자 입력에서 하나 이상의 단어를 캡처할 수 있습니다. 이 새로운 카테고리로 인해 챗봇은 이제 \u0026ldquo;Hello\u0026quot;로 시작하는 모든 입력에 대해 \u0026ldquo;Hi!\u0026ldquo;라고 응답할 것입니다. 따라서 \u0026ldquo;HELLO *\u0026rdquo; 패턴은 \u0026ldquo;HELLO THERE\u0026rdquo;, \u0026ldquo;HELLO CHATBOT\u0026rdquo;, \u0026ldquo;HELLO WORLD\u0026rdquo;, \u0026ldquo;HELLO EVERYONE\u0026rdquo; 등 다양한 입력에 대응합니다.\n"
},
{
	"uri": "/kr/secret-messages/activity-8/",
	"title": "결론",
	"tags": [],
	"description": "",
	"content": "축하합니다!\n정말 멋진 일을 해냈어요. 왕국을 구했고, 그 과정에서 C++ 프로그래밍도 배웠습니다! :)\n배운 내용을 복습해 보겠습니다:\n콘솔을 사용하여 암호화되거나 복호화된 메시지를 입력하고 전송했습니다. 발송될 메시지를 저장하기 위해 변수를 사용했습니다. 메시지의 각 글자를 분석하기 위해 루프를 사용했습니다. 조건를 사용하여 암호화 또는 복호화가 필요한지 확인했습니다. ASCII 코드는 메시지를 암호화하거나 복호화할 수 있도록 각 문자의 값을 알려주는 데 도움이 되었습니다. 왕께서 특별한 암호화된 감사 메시지를 보내주셨습니다. C++ 프로그램의 도움으로 해독하고 읽을 수 있습니다:\nsvox hrbguoecvg, zye wiquuee lgk iz a jgvpl rgfgqr. wvv fzggls ooxzu hvoj eazy pskirukk bqtzsvd lvk iuqeq ofs I sjz lhmnnh le qdbj hqls, iyt cwtx if nrl kpns. fgu mrh iyt kjvvr teudv ew inzs zawwgd. qdbj peojgrcesx kkuloh rhv osrzunj. o shzzrzazt ijlkjs goautv ngk, ovkje rou hmhv num wulo vrlv inv ocprglkfwzq tb hhzh crcf eoee ssgfds. fgue phgwejbgfcq wdh gklhzrnpiqu. lwv guqax fdbzbq otu axl rjj fvdvde mrh ujplslml rousntj lolh lox. qgdxggluxawwgdk. cuo ybu kont ld ivlqbuolt ssirufe eskxusy kaiiqu mi qdb yaie osrhfsj rn umsdjjrcz kkulo iypl lodl ne ysjo ysrhfhl lc qemg lmthrh, ngk yocv lqaucvs hguxrmmpwfv. I ydvv I cmn psvj qdb rgmiq wf jys lmthrh. Swfrvgody mng yzduzf, lhq klcx\r2\rprogramador Replit 실행하기\n중요: 콘솔에 붙여넣으려면 콘솔을 마우스 오른쪽 버튼으로 클릭하고 \u0026ldquo;붙여넣기\u0026quot;를 클릭합니다. 그렇지 않으면 붙여넣기 작업이 제대로 작동하지 않을 수 있습니다.\r"
},
{
	"uri": "/kr/chatbot/echoing-wildcards/",
	"title": "와일드카드 활용(Echoing Wildcards)",
	"tags": [],
	"description": "",
	"content": "\u0026lt;star /\u0026gt;태그 소개 이번에는 봇의 응답이 더 흥미로워지도록 할 수 있는 방법을 하나 더 배워보겠습니다. 이전에 배운 것처럼, 우리는 와일드카드 * 를 사용해 사용자의 다양한 입력을 대응할 수 있었습니다. 그런데, 만약 사용자가 입력한 단어나 구를 그대로 응답에 포함하고 싶다면 어떻게 해야 할까요? 예를 들어, 사용자가 좋아하는 색을 말했을 때, 그 색을 응답에 포함하도록 만들고 싶을 수 있습니다. 이 경우 \u0026lt;star /\u0026gt; 태그를 사용할 수 있습니다.\n\u0026lt;star /\u0026gt; 태그는 사용자가 입력한 단어나 구를 응답에 그대로 반영해 주는 특별한 태그입니다. 그 작동 방식을 살펴봅시다.\n\u0026lt;category\u0026gt;\r\u0026lt;pattern\u0026gt;MY FAVORITE COLOR IS *\u0026lt;/pattern\u0026gt;\r\u0026lt;template\u0026gt;\rYour favorite color is \u0026lt;star /\u0026gt;.\r\u0026lt;/template\u0026gt;\r\u0026lt;/category\u0026gt; 이 카테고리가 어떻게 작동하는지 살펴봅시다. \u0026ldquo;MY FAVORITE COLOR IS \u0026quot; 패턴은 \u0026ldquo;MY FAVORITE COLOR IS\u0026quot;로 시작하는 모든 입력에 매칭되며, 그 뒤에 오는 단어나 구는 무엇이든 캡처됩니다. 따라서 이 패턴은 \u0026ldquo;MY FAVORITE COLOR IS BLUE\u0026rdquo;, \u0026ldquo;MY FAVORITE COLOR IS RED\u0026rdquo;, \u0026ldquo;MY FAVORITE COLOR IS GREEN\u0026rdquo; 등과 같은 입력에 매칭됩니다. \u0026lt;star /\u0026gt; 태그는 사용자가 입력한 단어나 구를 캡처하여 응답에 사용합니다. 예를 들어, 사용자가 \u0026ldquo;MY FAVORITE COLOR IS BLUE\u0026quot;라고 입력하면, \u0026ldquo;blue\u0026quot;라는 단어가 와일드카드로 캡처되며, 봇은 \u0026ldquo;Your favorite color is blue\u0026quot;라고 응답합니다.\n다음은 이 카테고리의 입력과 출력 예시입니다:\n입력 출력 MY FAVORITE COLOR IS BLUE Your favorite color is blue. MY FAVORITE COLOR IS RED Your favorite color is red. MY FAVORITE COLOR IS GREEN Your favorite color is green. "
},
{
	"uri": "/kr/chatbot/activity-4/",
	"title": "활동 4: 와일드카드 사용하기",
	"tags": [],
	"description": "",
	"content": "와일드카드 사용하기 와일드카드를 사용하여 사용자가 질문하는 모든 방식에 대해 새로운 카테고리를 작성하지 않고도 봇이 더 많은 질문에 답변할 수 있도록 해봅시다. 현재의 카테고리들을 확장하여 챗봇이 \u0026ldquo;food\u0026rdquo;, \u0026ldquo;color\u0026rdquo;, \u0026ldquo;name\u0026quot;으로 끝나는 질문에 응답할 수 있도록 만들어 보겠습니다.\n패턴의 시작에 와일드카드를 사용하세요.\n사용자가 \u0026ldquo;food\u0026quot;로 끝나는 질문을 입력하면(예: \u0026ldquo;What is your favorite food?\u0026rdquo;, \u0026ldquo;Do you like food?\u0026rdquo;, \u0026ldquo;Do chatbots eat food?\u0026rdquo;), 봇은 \u0026ldquo;My favorite food is pizza\u0026quot;라고 응답해야 합니다..\n사용자가 \u0026ldquo;color\u0026quot;로 끝나는 질문을 입력하면(예: \u0026ldquo;What is your favorite color?\u0026rdquo;, \u0026ldquo;What’s your favorite color?\u0026rdquo;), 봇은 \u0026ldquo;My favorite color is blue\u0026quot;라고 응답해야 합니다.\n사용자가 \u0026ldquo;name\u0026quot;으로 끝나는 질문을 입력하면(예: \u0026ldquo;What is your name?\u0026rdquo;, \u0026ldquo;What’s your name?\u0026rdquo;, \u0026ldquo;Do you have a name?\u0026rdquo;), 봇은 \u0026ldquo;My name is Chatbot\u0026quot;이라고 응답해야 합니다.\n"
},
{
	"uri": "/kr/chatbot/activity-5/",
	"title": "활동 5: 와일드카드 활용(Echoing Wildcards)",
	"tags": [],
	"description": "",
	"content": "와일드카드 활용(Echoing Wildcards) 이제 와일드카드 *와 \u0026lt;star /\u0026gt;태그를 함께 사용하여 사용자의 입력을 응답에 포함시킬 수 있도록 해봅시다.\n사용자가 \u0026ldquo;My name is [name]\u0026ldquo;이라고 입력하면, 봇이 \u0026ldquo;Nice to meet you, [name]!\u0026ldquo;이라고 응답해야 합니다. 예시\n입력 출력 My name is John Nice to meet you, John! My name is Jane Nice to meet you, Jane! My name is Bob Nice to meet you, Bob! 사용자가 \u0026ldquo;My favorite color is [color]\u0026ldquo;라고 입력하면, 봇이 \u0026ldquo;I also like [color]!\u0026ldquo;라고 응답해야 합니다. 예시:\n입력 출력 My favorite color is blue I also like blue! My favorite color is red I also like red! My favorite color is green I also like green! 사용자가 \u0026ldquo;My favorite food is [food]\u0026ldquo;이라고 입력하면, 봇이 \u0026ldquo;[food]! Yum!\u0026ldquo;이라고 응답해야 합니다. 예시:\n입력 출력 My favorite food is pizza pizza! Yum! My favorite food is pasta pasta! Yum! My favorite food is sushi sushi! Yum! "
},
{
	"uri": "/kr/chatbot/conclusion/",
	"title": "결론",
	"tags": [],
	"description": "",
	"content": "\n마무리 지금까지 몇 가지 카테고리를 사용하여 간단한 챗봇을 만들어 보았습니다. 이제 여러분은 챗봇과 짧은 대화를 나눌 수 있을 것입니다! \u0026ldquo;hi\u0026quot;라고 인사해 보고, 좋아하는 음식이나 색, 이름에 대해 이야기해보세요. 그리고 봇에게 몇 가지 질문도 해보세요.\n더 탐구해 보고 싶다면, 봇이 더 많은 질문에 응답할 수 있도록 카테고리를 추가해보세요.\nALICE 기억하시나요? ALICE는 50,000개의 카테고리로 만들어졌습니다! 일부 대형 챗봇은 100만 개 이상의 카테고리를 가지고 있습니다. 카테고리를 추가하는 일이 얼마나 더 복잡해질 수 있는지 상상이 되시죠?\n"
},
{
	"uri": "/kr/java-tictactoe/answer-key/",
	"title": "Java: TicTacToe - Answer Key",
	"tags": [],
	"description": "",
	"content": "activity-1: 게임판 설정하기 public class TicTacToe_Nuevo { public static void main(String args[]){ // the board that stores moves String[] board = {\u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;}; // starting board that labeled position(only printed once) String[] startBoard = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;}; System.out.println(\u0026#34;\u0026lt;\u0026lt;\u0026lt;~ Tic Tac Toe ~\u0026gt;\u0026gt;\u0026gt;\\n* Choose number 1 - 9 to place your move\\n* Player: \u0026#39;X\u0026#39; Computer: \u0026#39;O\u0026#39;\\n\u0026#34; ); printBoard(startBoard); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); } // method that prints the board with the board input public static void printBoard(String[] curBoard){ System.out.println(\u0026#34; \u0026#34; + curBoard[0] + \u0026#34; | \u0026#34; + curBoard[1] + \u0026#34; | \u0026#34; + curBoard[2] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[3] + \u0026#34; | \u0026#34; + curBoard[4] + \u0026#34; | \u0026#34; + curBoard[5] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[6] + \u0026#34; | \u0026#34; + curBoard[7] + \u0026#34; | \u0026#34; + curBoard[8] + \u0026#34; \u0026#34;); } } activity-2: 읽기 및 처리 입력 import java.util.Scanner; public class TicTacToe_Nuevo { public static void main(String args[]){ Scanner sc = new Scanner(System.in); /*String[] board = {\u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;}; String[] startBoard = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;}; System.out.println(\u0026#34;\u0026lt;\u0026lt;\u0026lt;~ Tic Tac Toe ~\u0026gt;\u0026gt;\u0026gt;\\n* Choose number 1 - 9 to place your move\\n* Player: \u0026#39;X\u0026#39; Computer: \u0026#39;O\u0026#39;\\n\u0026#34;); printBoard(startBoard); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); */ while(true){ int move; if(sc.hasNextInt()) { // get integer input move = sc.nextInt(); // check if the integer is between 1, 9. check if the position is empty if (!(move \u0026gt; 0 \u0026amp;\u0026amp; move \u0026lt;= 9) || ! board[move -1].equals(\u0026#34; \u0026#34;)) { System.out.print(\u0026#34;Invalid Position; re-enter your move (1-9): \u0026#34;); continue; } } else { // clear the Scanner sc.next(); System.out.print(\u0026#34;Invalid Input; re-enter your move (1-9): \u0026#34;); continue; } // reprompt the board printBoard(board); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); } } /*public static void printBoard(String[] curBoard){ System.out.println(\u0026#34; \u0026#34; + curBoard[0] + \u0026#34; | \u0026#34; + curBoard[1] + \u0026#34; | \u0026#34; + curBoard[2] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[3] + \u0026#34; | \u0026#34; + curBoard[4] + \u0026#34; | \u0026#34; + curBoard[5] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[6] + \u0026#34; | \u0026#34; + curBoard[7] + \u0026#34; | \u0026#34; + curBoard[8] + \u0026#34; \u0026#34;); }*/ } activity-3: 게임판 업데이트하기 // import java.util.Scanner; import java.util.Random; public class TicTacToe_Nuevo { public static void main(String args[]){ /*Scanner sc = new Scanner(System.in); String[] board = {\u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;}; String[] startBoard = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;}; System.out.println(\u0026#34;\u0026lt;\u0026lt;\u0026lt;~ Tic Tac Toe ~\u0026gt;\u0026gt;\u0026gt;\\n* Choose number 1 - 9 to place your move\\n* Player: \u0026#39;X\u0026#39; Computer: \u0026#39;O\u0026#39;\\n\u0026#34;); printBoard(startBoard); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); */ while(true){ /*int move; if (sc.hasNextInt()) { move = sc.nextInt(); if (!(move \u0026gt; 0 \u0026amp;\u0026amp; move \u0026lt;= 9) || ! board[move -1].equals(\u0026#34; \u0026#34;)) { System.out.print(\u0026#34;Invalid Position; re-enter your move (1-9): \u0026#34;); continue; } } else { sc.next(); System.out.print(\u0026#34;Invalid Input; re-enter your move (1-9): \u0026#34;); continue; } */ // update the board with user\u0026#39;s move board[move - 1] = \u0026#34;X\u0026#34;; // update the board with a random move for computer board[getComputerMove(board) - 1] = \u0026#34;O\u0026#34;; /*printBoard(board); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); */s } } /*public static void printBoard(String[] curBoard){ System.out.println(\u0026#34; \u0026#34; + curBoard[0] + \u0026#34; | \u0026#34; + curBoard[1] + \u0026#34; | \u0026#34; + curBoard[2] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[3] + \u0026#34; | \u0026#34; + curBoard[4] + \u0026#34; | \u0026#34; + curBoard[5] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[6] + \u0026#34; | \u0026#34; + curBoard[7] + \u0026#34; | \u0026#34; + curBoard[8] + \u0026#34; \u0026#34;); }*/ // method that generate a valid random move public static int getComputerMove(String[] curBoard){ Random rand = new Random(); int pos = rand.nextInt(9) + 1; while(! curBoard[pos - 1].equals(\u0026#34; \u0026#34;)){ pos = rand.nextInt(9) + 1; } return pos; } } activity-4: 승자 확인 // import java.util.Scanner; // import java.util.Random; public class TicTacToe_Nuevo { public static void main(String args[]){ /*Scanner sc = new Scanner(System.in); String[] board = {\u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;}; String[] startBoard = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;}; System.out.println(\u0026#34;\u0026lt;\u0026lt;\u0026lt;~ Tic Tac Toe ~\u0026gt;\u0026gt;\u0026gt;\\n* Choose number 1 - 9 to place your move\\n* Player: \u0026#39;X\u0026#39; Computer: \u0026#39;O\u0026#39;\\n\u0026#34;); printBoard(startBoard); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); */ while(true){ /*int move; if (sc.hasNextInt()) { move = sc.nextInt(); if (!(move \u0026gt; 0 \u0026amp;\u0026amp; move \u0026lt;= 9) || ! board[move -1].equals(\u0026#34; \u0026#34;)) { System.out.print(\u0026#34;Invalid Position; re-enter your move (1-9): \u0026#34;); continue; } } else { sc.next(); System.out.print(\u0026#34;Invalid Input; re-enter your move (1-9): \u0026#34;); continue; }*/ // board[move - 1] = \u0026#34;X\u0026#34;; String winner = getWinner(board); if(winner.length() \u0026gt; 0){ // if there is a winner or a tie printBoard(board); System.out.println(\u0026#34;\\n\u0026#34; + winner + \u0026#34;\\n\u0026#34;); break; } // board[getComputerMove(board) - 1] = \u0026#34;O\u0026#34;; winner = getWinner(board); if(winner.length() \u0026gt; 0){ printBoard(board); System.out.println(\u0026#34;\\n\u0026#34; + winner + \u0026#34;\\n\u0026#34;); break; } /*printBoard(board); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); */s } sc.close(); } /*public static void printBoard(String[] curBoard){ System.out.println(\u0026#34; \u0026#34; + curBoard[0] + \u0026#34; | \u0026#34; + curBoard[1] + \u0026#34; | \u0026#34; + curBoard[2] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[3] + \u0026#34; | \u0026#34; + curBoard[4] + \u0026#34; | \u0026#34; + curBoard[5] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[6] + \u0026#34; | \u0026#34; + curBoard[7] + \u0026#34; | \u0026#34; + curBoard[8] + \u0026#34; \u0026#34;); } public static int getComputerMove(String[] curBoard){ Random rand = new Random(); int pos = rand.nextInt(9) + 1; while(! curBoard[pos - 1].equals(\u0026#34; \u0026#34;)){ pos = rand.nextInt(9) + 1; } return pos; }*/ // NOTE: this is one possible way to write this method. public static String getWinner(String[] curBoard){ for(int i = 0; i \u0026lt; 8; i++){ String checkWin = \u0026#34;\u0026#34;; switch(i){ // conactenate all possible winning positions case 0: checkWin = curBoard[0] + curBoard[1] + curBoard[2]; break; case 1: checkWin = curBoard[3] + curBoard[4] + curBoard[5]; break; case 2: checkWin = curBoard[6] + curBoard[7] + curBoard[8]; break; case 3: checkWin = curBoard[0] + curBoard[3] + curBoard[6]; break; case 4: checkWin = curBoard[1] + curBoard[4] + curBoard[7]; break; case 5: checkWin = curBoard[2] + curBoard[5] + curBoard[8]; break; case 6: checkWin = curBoard[0] + curBoard[4] + curBoard[8]; break; case 7: checkWin = curBoard[2] + curBoard[4] + curBoard[6]; break; } // check if any player wins if(checkWin.equals(\u0026#34;XXX\u0026#34;)){ return \u0026#34;Congratulations! \\nYou won the Game :)\u0026#34;; }else if(checkWin.equals(\u0026#34;OOO\u0026#34;)){ return \u0026#34;Game Over! \\nYou lost the Game :(\u0026#34;; } } for(String move: curBoard){ if(move.equals(\u0026#34; \u0026#34;)){ return \u0026#34;\u0026#34;; } } return \u0026#34;It\u0026#39;s a TIE! Try again\u0026#34;; } } activity-5: AI 컴퓨터 이동 public static int getComputerMoveAI(String[] curBoard){ int pos = 0; int bestScore = Integer.MIN_VALUE; for(int i = 0; i \u0026lt; 9; i++){ if(curBoard[i].equals(\u0026#34; \u0026#34;)){ // go through all empty slots // put computer\u0026#39;s move there curBoard[i] = \u0026#34;O\u0026#34;; // get the score int score = minimax(curBoard, false); // change it back curBoard[i] = \u0026#34; \u0026#34;; // keep track of the position that gives the best score if(score \u0026gt; bestScore){ bestScore = score; pos = i; } } } return pos; } public static int minimax(String[] curBoard, boolean isMaximizing){ // check if the board has a winner or a tie yet String result = getWinner(curBoard); // factor = number of empty slots + 1 int factor = getFactor(curBoard); // terminating state return score if(result.contains(\u0026#34;TIE\u0026#34;)) return 0; if(result.contains(\u0026#34;won\u0026#34;)) return -1 * factor; if(result.contains(\u0026#34;lost\u0026#34;)) return 1 * factor; // the follow code is similiar as getComputerMoveAI() but it swaps based on `isMaximizing` input int bestScore = (isMaximizing)? Integer.MIN_VALUE : Integer.MAX_VALUE; String symbol = (isMaximizing)? \u0026#34;O\u0026#34; : \u0026#34;X\u0026#34;; for(int i = 0; i \u0026lt;9; i++){ if(curBoard[i].equals(\u0026#34; \u0026#34;)){ curBoard[i] = symbol; int score = minimax(curBoard, !isMaximizing); curBoard[i] = \u0026#34; \u0026#34;; if(isMaximizing) { bestScore = Math.max(score, bestScore); }else{ bestScore = Math.min(score, bestScore); } } } return bestScore; } // return number of spots available + 1 public static int getFactor(String[] curBoard){ int counter = 1; for(int i = 0; i \u0026lt; 9; i++){ if(curBoard[i].equals(\u0026#34; \u0026#34;)){ counter++; } } return counter; } Full Code import java.util.Random; import java.util.Scanner; public class TicTacToe_Nuevo { public static void main(String args[]){ String[] board = {\u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;, \u0026#34; \u0026#34;}; String[] startBoard = {\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;}; Scanner sc = new Scanner(System.in); System.out.println(\u0026#34;\u0026lt;\u0026lt;\u0026lt;~ Tic Tac Toe ~\u0026gt;\u0026gt;\u0026gt;\\n* Choose number 1 - 9 to place your move\\n* Player: \u0026#39;X\u0026#39; Computer: \u0026#39;O\u0026#39;\\n\u0026#34;); printBoard(startBoard); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); while(true){ int move; if (sc.hasNextInt()) { move = sc.nextInt(); if (!(move \u0026gt; 0 \u0026amp;\u0026amp; move \u0026lt;= 9) || ! board[move -1].equals(\u0026#34; \u0026#34;)) { System.out.print(\u0026#34;Invalid Position; re-enter your move (1-9): \u0026#34;); continue; } } else { sc.next(); System.out.print(\u0026#34;Invalid Input; re-enter your move (1-9): \u0026#34;); continue; } board[move - 1] = \u0026#34;X\u0026#34;; String winner = getWinner(board); if(winner.length() \u0026gt; 0){ printBoard(board); System.out.println(\u0026#34;\\n\u0026#34; + winner + \u0026#34;\\n\u0026#34;); break; } double ran = Math.random(); /*if(ran \u0026lt; 0.2){ board[getComputerMove(board) - 1] = \u0026#34;O\u0026#34;; }else{*/ board[getComputerMoveAI(board) - 1] = \u0026#34;O\u0026#34;; //} winner = getWinner(board); if(winner.length() \u0026gt; 0){ printBoard(board); System.out.println(\u0026#34;\\n\u0026#34; + winner + \u0026#34;\\n\u0026#34;); break; } printBoard(board); System.out.print(\u0026#34;Enter your move (1-9): \u0026#34;); } sc.close(); } public static void printBoard(String[] curBoard){ System.out.println(\u0026#34; \u0026#34; + curBoard[0] + \u0026#34; | \u0026#34; + curBoard[1] + \u0026#34; | \u0026#34; + curBoard[2] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[3] + \u0026#34; | \u0026#34; + curBoard[4] + \u0026#34; | \u0026#34; + curBoard[5] + \u0026#34; \u0026#34;); System.out.println(\u0026#34;---+---+---\u0026#34;); System.out.println(\u0026#34; \u0026#34; + curBoard[6] + \u0026#34; | \u0026#34; + curBoard[7] + \u0026#34; | \u0026#34; + curBoard[8] + \u0026#34; \u0026#34;); } public static String getWinner(String[] curBoard){ for(int i = 0; i \u0026lt; 8; i++){ String checkWin = \u0026#34;\u0026#34;; switch(i){ case 0: checkWin = curBoard[0] + curBoard[1] + curBoard[2]; break; case 1: checkWin = curBoard[3] + curBoard[4] + curBoard[5]; break; case 2: checkWin = curBoard[6] + curBoard[7] + curBoard[8]; break; case 3: checkWin = curBoard[0] + curBoard[3] + curBoard[6]; break; case 4: checkWin = curBoard[1] + curBoard[4] + curBoard[7]; break; case 5: checkWin = curBoard[2] + curBoard[5] + curBoard[8]; break; case 6: checkWin = curBoard[0] + curBoard[4] + curBoard[8]; break; case 7: checkWin = curBoard[2] + curBoard[4] + curBoard[6]; break; } if(checkWin.equals(\u0026#34;XXX\u0026#34;)){ return \u0026#34;Congratulations! \\nYou won the Game :)\u0026#34;; }else if(checkWin.equals(\u0026#34;OOO\u0026#34;)){ return \u0026#34;Game Over! \\nYou lost the Game :(\u0026#34;; } } for(String move: curBoard){ if(move.equals(\u0026#34; \u0026#34;)){ return \u0026#34;\u0026#34;; } } return \u0026#34;It\u0026#39;s a TIE! Try it again\u0026#34;; } public static int getComputerMove(String[] curBoard){ Random rand = new Random(); int pos = rand.nextInt(9) + 1; while(! curBoard[pos - 1].equals(\u0026#34; \u0026#34;)){ pos = rand.nextInt(9) + 1; } return pos; } // AI: computer move public static int getComputerMoveAI(String[] curBoard){ int pos = 0; int bestScore = Integer.MIN_VALUE; for(int i = 0; i \u0026lt; 9; i++){ if(curBoard[i].equals(\u0026#34; \u0026#34;)){ curBoard[i] = \u0026#34;O\u0026#34;; int score = minimax(curBoard, false); curBoard[i] = \u0026#34; \u0026#34;; if(score \u0026gt; bestScore){ bestScore = score; pos = i; } } } return pos; } public static int minimax(String[] curBoard, boolean isMaximizing){ String result = getWinner(curBoard); int factor = getFactor(curBoard); // terminating state return score if(result.contains(\u0026#34;TIE\u0026#34;)) return 0; if(result.contains(\u0026#34;won\u0026#34;)) return -1 * factor; if(result.contains(\u0026#34;lost\u0026#34;)) return 1 * factor; // recurrence case int bestScore = (isMaximizing)? Integer.MIN_VALUE : Integer.MAX_VALUE; String symbol = (isMaximizing)? \u0026#34;O\u0026#34; : \u0026#34;X\u0026#34;; for(int i = 0; i \u0026lt;9; i++){ if(curBoard[i].equals(\u0026#34; \u0026#34;)){ curBoard[i] = symbol; int score = minimax(curBoard, !isMaximizing); curBoard[i] = \u0026#34; \u0026#34;; if(isMaximizing) { bestScore = Math.max(score, bestScore); }else{ bestScore = Math.min(score, bestScore); } } } return bestScore; } // return number of spots available + 1 public static int getFactor(String[] curBoard){ int counter = 1; for(int i = 0; i \u0026lt; 9; i++){ if(curBoard[i].equals(\u0026#34; \u0026#34;)){ counter++; } } return counter; } } "
},
{
	"uri": "/kr/secret-messages/answer-key/",
	"title": "C++ Secret Messages - Answer Key",
	"tags": [],
	"description": "",
	"content": "The following 5 lines are needed for all the activities.\n#include \u0026lt;iostream\u0026gt;\rusing namespace std;\rint main() {\rreturn 0;\r} Activity 1 cout \u0026lt;\u0026lt; \u0026#34;Hello programmer!\u0026#34; \u0026lt;\u0026lt; endl; Activity 2 string name;\rcin \u0026gt;\u0026gt; name;\rcout \u0026lt;\u0026lt; \u0026#34;Hello \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; Activity 3 string name;\rcin \u0026gt;\u0026gt; name;\rfor(int i=0; i\u0026lt;name.size(); i++){\rcout \u0026lt;\u0026lt; name[i] \u0026lt;\u0026lt; endl;\r} Activity 4 int number;\rcin \u0026gt;\u0026gt; number;\rif(number == 1){\rcout \u0026lt;\u0026lt; \u0026#34;Encrypt a message\u0026#34; \u0026lt;\u0026lt; endl;\r}else{\rcout \u0026lt;\u0026lt; \u0026#34;Decrypt a message\u0026#34; \u0026lt;\u0026lt; endl;\r} Activity 5 #include \u0026lt;iostream\u0026gt;\rusing namespace std;\rint main() {\rstring code;\rstring name;\rcin \u0026gt;\u0026gt; code;\rcin \u0026gt;\u0026gt; name;\rint counter = 0;\rfor(int i=0; i\u0026lt;name.size(); i++){\rint sum = name[i]+code[counter]-\u0026#39;a\u0026#39;;\rif(sum \u0026gt; \u0026#39;z\u0026#39;){\rsum-=25;\r}\rname[i]=sum;\rcounter+=1;\rif(counter \u0026gt;= code.size()){\rcounter=0;\r}\r}\rcout \u0026lt;\u0026lt; \u0026#34;Encrypted message: \u0026#34; \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\rreturn 0;\r} Activity 6 #include \u0026lt;iostream\u0026gt;\rusing namespace std;\rvoid encrypt (string \u0026amp;name, string code){\rint counter = 0;\rfor(int i=0; i\u0026lt;name.size(); i++){\rint sum = name[i]+code[counter]-\u0026#39;a\u0026#39;;\rif(sum \u0026gt; \u0026#39;z\u0026#39;){\rsum-=25;\r}\rname[i]=sum;\rcounter+=1;\rif(counter \u0026gt;= code.size()){\rcounter=0;\r}\r}\r}\rvoid decrypt (string \u0026amp;name, string code){\rint counter = 0;\rfor(int i=0; i\u0026lt;name.size(); i++){\rint sum = name[i]-code[counter]+\u0026#39;a\u0026#39;;\rif(sum \u0026lt; \u0026#39;a\u0026#39;){\rsum+=25;\r}\rname[i]=sum;\rcounter+=1;\rif(counter \u0026gt;= code.size()){\rcounter=0;\r}\r}\r}\rint main() {\rstring code;\rstring name;\rint number;\rcin \u0026gt;\u0026gt; number;\rcin \u0026gt;\u0026gt; code;\rcin \u0026gt;\u0026gt; name;\rif(number == 1){\rcout \u0026lt;\u0026lt; \u0026#34;Encrypted message: \u0026#34; \u0026lt;\u0026lt; endl;\rencrypt(name, code);\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\r}else{\rcout \u0026lt;\u0026lt; \u0026#34;Decrypted message: \u0026#34; \u0026lt;\u0026lt; endl;\rdecrypt(name, code);\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r} Activity 7 #include \u0026lt;iostream\u0026gt;\rusing namespace std;\rvoid encrypt (string \u0026amp;name, string code){\rint counter = 0;\rfor(int i=0; i\u0026lt;name.size(); i++){\rif(name[i]!=\u0026#39; \u0026#39;){\rint sum = name[i]+code[counter]-\u0026#39;a\u0026#39;;\rif(sum \u0026gt; \u0026#39;z\u0026#39;){\rsum-=25;\r}\rname[i]=sum;\rcounter+=1;\rif(counter \u0026gt;= code.size()){\rcounter=0;\r}\r}\r}\r}\rvoid decrypt (string \u0026amp;name, string code){\rint counter = 0;\rfor(int i=0; i\u0026lt;name.size(); i++){\rif(name[i]!=\u0026#39; \u0026#39;){\rint sum = name[i]-code[counter]+\u0026#39;a\u0026#39;;\rif(sum \u0026lt; \u0026#39;a\u0026#39;){\rsum+=25;\r}\rname[i]=sum;\rcounter+=1;\rif(counter \u0026gt;= code.size()){\rcounter=0;\r}\r}\r}\r}\rint main() {\rstring code;\rstring name;\rint number;\rcin \u0026gt;\u0026gt; number;\rcin \u0026gt;\u0026gt; code;\rgetline(cin, name);\rif(number == 1){\rcout \u0026lt;\u0026lt; \u0026#34;Encrypted message: \u0026#34; \u0026lt;\u0026lt; endl;\rencrypt(name, code);\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\r}else{\rcout \u0026lt;\u0026lt; \u0026#34;Decrypted message: \u0026#34; \u0026lt;\u0026lt; endl;\rdecrypt(name, code);\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\r}\rreturn 0;\r} "
},
{
	"uri": "/kr/razor/answer-key/",
	"title": "답안 - C#: Razor를 사용한 웹 사이트 만들기",
	"tags": [],
	"description": "",
	"content": "활동 1: 코딩 없이 VS Code 알아보기\n활동 2: 코딩 없이, 시작할 준비하기 - 확장자 설치하기\n활동 3: Pages/index.razor @page \u0026#34;/\u0026#34; @code { TimeSpan timeInBusiness = DateTime.Now - new DateTime(2010, 01, 17); } \u0026lt;PageTitle\u0026gt;Welcome to my first web app\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Welcome to my first Razor web app\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;lead\u0026#34;\u0026gt;The best website in town for @Convert.ToInt32(timeInBusiness.TotalDays) days!\u0026lt;/p\u0026gt; 활동 4: ToDoItems.cs\nnamespace MyNewTodoListApp; public class TodoItem { public string? Title { get; set; } public bool IsDone { get; set; } } 공유하기/NavMenu.razor\n\u0026lt;div class=\u0026#34;top-row ps-3 navbar navbar-dark\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;navbar-brand\u0026#34; href=\u0026#34;\u0026#34;\u0026gt;MyNewTodoListApp\u0026lt;/a\u0026gt; \u0026lt;button title=\u0026#34;Navigation menu\u0026#34; class=\u0026#34;navbar-toggler\u0026#34; @onclick=\u0026#34;ToggleNavMenu\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;navbar-toggler-icon\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;@NavMenuCssClass nav-scrollable\u0026#34; @onclick=\u0026#34;ToggleNavMenu\u0026#34;\u0026gt; \u0026lt;nav class=\u0026#34;flex-column\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;\u0026#34; Match=\u0026#34;NavLinkMatch.All\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-home\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Home \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;counter\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-plus\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Counter \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;todo\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; To do List \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;fetchdata\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Fetch data \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/div\u0026gt; @code { private bool collapseNavMenu = true; private string? NavMenuCssClass =\u0026gt; collapseNavMenu ? \u0026#34;collapse\u0026#34; : null; private void ToggleNavMenu() { collapseNavMenu = !collapseNavMenu; } } #3\n@page \u0026#34;/todo\u0026#34; \u0026lt;PageTitle\u0026gt;Todo\u0026lt;/PageTitle\u0026gt; \u0026lt;h3\u0026gt;Todo\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; @foreach (var todo in todos) { \u0026lt;li\u0026gt;@todo.Title\u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; \u0026lt;input placeholder=\u0026#34;Something todo\u0026#34; /\u0026gt; \u0026lt;button\u0026gt;Add todo\u0026lt;/button\u0026gt; @code { private List\u0026lt;TodoItem\u0026gt; todos = new(); } #4\n\u0026lt;input placeholder=\u0026#34;Something todo\u0026#34; @bind=\u0026#34;newTodo\u0026#34; /\u0026gt; \u0026lt;button @onclick=\u0026#34;AddTodo\u0026#34;\u0026gt;Add todo\u0026lt;/button\u0026gt; @code { private List\u0026lt;TodoItem\u0026gt; todos = new(); private string? newTodo; private void AddTodo() { if (!string.IsNullOrWhiteSpace(newTodo)) { todos.Add(new TodoItem { Title = newTodo }); newTodo = string.Empty; } } } #5\n\u0026lt;ul\u0026gt; @foreach (var todo in todos) { \u0026lt;li\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; @bind=\u0026#34;todo.IsDone\u0026#34; /\u0026gt; \u0026lt;input @bind=\u0026#34;todo.Title\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; #6\n\u0026lt;h3\u0026gt;Todo (@todos.Count(todo =\u0026gt; !todo.IsDone))\u0026lt;/h3\u0026gt; 완성된 페이지/Todo.razor\n@page \u0026#34;/todo\u0026#34; \u0026lt;PageTitle\u0026gt;Todo\u0026lt;/PageTitle\u0026gt; \u0026lt;h3\u0026gt;Todo (@todos.Count(todo =\u0026gt; !todo.IsDone))\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; @foreach (var todo in todos) { \u0026lt;li\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; @bind=\u0026#34;todo.IsDone\u0026#34; /\u0026gt; \u0026lt;input @bind=\u0026#34;todo.Title\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; \u0026lt;input placeholder=\u0026#34;Something todo\u0026#34; @bind=\u0026#34;newTodo\u0026#34; /\u0026gt; \u0026lt;button @onclick=\u0026#34;AddTodo\u0026#34;\u0026gt;Add todo\u0026lt;/button\u0026gt; @code { private List\u0026lt;TodoItem\u0026gt; todos = new(); private string? newTodo; private void AddTodo() { if (!string.IsNullOrWhiteSpace(newTodo)) { todos.Add(new TodoItem { Title = newTodo }); newTodo = string.Empty; } } } "
},
{
	"uri": "/kr/razor/",
	"title": "C#: Razor를 사용한 웹 사이트 만들기",
	"tags": [],
	"description": "C#/Razor를 사용하여 간단한 웹사이트를 만드는 방법에 대한 소개 가이드",
	"content": "환영합니다 오늘의 활동 목표는 웹과 C# 기술을 배우고, 새롭게 익힌 지식을 활용하여 웹 사이트를 만드는 것입니다!\n시작하기 이번의 활동 목표는 웹과 C# 기술을 배우고, 새롭게 익힌 지식을 활용하여 웹 사이트를 만드는 것입니다! 먼저 환경 설정을 시작해 봅시다.\nC# 애플리케이션 개발을 시작하기 전에, 가장 먼저 해야 할 일은 프로그래밍 환경을 선택하는 것입니다. C# 개발자들 사이에서 가장 인기 있는 IDE (Integrated Development Environment, 통합 개발 환경) 중 하나인 Visual Studio Code를 사용합니다.\nVisual Studio Code 다운로드 브라우저를 열고 다음 주소로 이동합니다: https://code.visualstudio.com\r.\n브라우저 창에서 Download 버튼을 클릭합니다.\nNote\rVisual Studio Code의 다운로드 페이지는 자동으로 사용자의 운영 체제를 감지하여 해당 운영 체제에 맞는 버전을 표시합니다. 예: Linux, macOS, Windows 등.\r설치 파일 다운로드가 완료될 때까지 기다립니다. Windows PC의 경우 설치 파일 이름은 다음과 비슷할 수 있습니다: VSCodeUserSetup-x64-1.81.0.exe\nNote\r설치 파일 이름은 현재 Visual Studio Code 버전과 사용자의 운영 체제에 따라 달라질 수 있습니다.\r다운로드가 완료되면 브라우저 창을 닫습니다. Visual Studio Code 설치 PC에서 파일 탐색기(File Explorer)를 열고, 컴퓨터의 다운로드 폴더로 이동합니다.\n파일 탐색기에서 Visual Studio Code 설치 파일을 선택한 뒤 실행합니다.\nWindows PC의 경우, 설치 파일을 더블 클릭하여 설치를 시작할 수 있습니다. ( VSCodeUserSetup-x64-1.81.0.exe )\nNote\rVisual Studio Code는 사용자 설치(User Installer) 또는 시스템 설치(System Installer) 중 선택하여 설치할 수 있습니다. 사용자 설치(User Installer): 현재 사용자만을 위해 Visual Studio Code를 설치합니다. 시스템 설치(System Installer): 모든 사용자 계정에서 Visual Studio Code를 사용할 수 있도록 설치합니다. 일반적으로 사용자 설치(User Installer) 옵션을 권장합니다.\r잠시후 Microsoft Visual Studio Code 설정 대화 창이 나타납니다.\n설치 창에서 라이선스 동의(I accept the license agreement)를 선택한 후, 화면에 표시되는 지침을 따라 설치를 완료합니다.\n설치 과정 중 나오는 옵션은 기본값(Default Options)을 선택합니다.\n자세한 설치 지침은 Visual Studio Code 공식 문서를 참고해주세요: https://code.visualstudio.com/docs/setup/windows\r.\n.NET SDK 설치 How to check if you have .NET installed\r**.NET이 설치되어 있는지 확인하기**\r터미널 창을 열고, 아래 명령어를 입력한 뒤 Enter 키를 누릅니다: dotnet \u0026ndash;version\n결과로 버전 번호가 표시되면 .NET이 설치되어 있는 것입니다.\n인터넷 브라우저를 열고 아래 URL로 이동합니다:\nhttps://dotnet.microsoft.com/download\rDownload .NET 페이지에서 권장 버전의 .NET SDK를 선택합니다.\n설치 파일 다운로드가 완료될 때까지 기다립니다.\n다운로드한 설치 파일을 실행합니다.\nWindows PC의 경우, 파일 탐색기를 열어 다운로드 폴더에서 설치 파일을 찾고, 더블 클릭하여 설치를 시작합니다.\n.NET SDK 설치 관리자(.NET SDK Installer) 창이 열리면 Install(설치)을 선택합니다.\n설치가 완료될 때까지 잠깐 기다립니다.\n설치가 완료될 때까지 몇 분이 걸릴 수 있습니다. 설치가 성공적으로 완료되면 확인 메시지가 표시됩니다.\n설치가 완료되면 Close(닫기)를 선택하여 설치 관리자 창을 닫습니다.\n목차 목차\rVisual Studio Code 알아보기 활동 1 - Visual Studio Code 탐색하기 활동 2 - Visual Studio Code 확장 프로그램 추가 Razor 기초1 Razor 기초2 Razor 지시문 활동 3 - 웹 애플리케이션 만들기 활동 4 - 새로운 Razor 페이지 추가 "
},
{
	"uri": "/kr/jsappybird/",
	"title": "JS: JSappyBird",
	"tags": [],
	"description": "나만의 JSappyBird 게임 만들기",
	"content": "소개 여러분은 아마도 플래피 버드(Flappy Bird) 게임에 익숙할 것 입니다. 이 워크숍에서는 JavaScript 언어를 사용하여 여러분만의 플래피 버드 게임을 만드는 방법을 배울 것입니다! 도전할 준비가 되셨나요?\n이미 익숙한 플래피 버드 게임을 직접 만들어보고, 친구들에게도 보여줄 수 있습니다! 이번 튜토리얼에서는 여러분이 만든 세계에서 새가 움직일 수 있도록 JavaScript 언어를 배우게 됩니다.\n시작하기 활동의 목표는 JavaScript 기술을 배우고, 배운 지식을 활용해 플래피 버드 게임을 만드는 것입니다. 이제 게임을 만들어 봅시다.\n오늘 우리는 “Replit”을 사용할 것입니다. 시작하기 전에, 아직 계정이 없다면 “Replit”계정을 만들어 주세요.\n아래 버튼을 클릭하여 “Replit”계정에 가입할 수 있습니다. 가입에는 이메일 계정이 필요합니다. 이미 “Replit”계정이 있다면 아래 버튼을 통해 로그인할 수 있습니다.\nReplit 가입하기\n이제 오늘 사용할 “Replit” 콘솔을 실행하려면 아래 버튼을 클릭하세요. 다음과 같은 화면이 나와야 합니다.\nReplit 실행하기\n다음으로, Repl을 포크(fork)하여 프로그램의 복사본을 만들어 나만의 수정 작업을 할 수 있습니다. 오른쪽 상단의 “Fork Repl” 버튼을 클릭한 후, 다시 “Fork Repl” 버튼을 클릭하세요.\nReplit을 포크하면 다음과 같은 화면이 나타날 것입니다:\n이 화면에서 일부 세부사항은 넘어가도 되지만, 화면에 표시된 기본 사항 몇 가지를 확인해 보겠습니다. index.html 파일과 .js 파일에는 컴퓨터가 실행할 명령어(코드)가 들어 있습니다.run 버튼을 누르면 컴퓨터가 코드의 명령을 실행하고, 실행 결과는 오른쪽의 console에 표시됩니다.\n지금 run을 눌러 보면 아직 아무것도 나타나지 않을 것입니다! 여러분의 역할은 Nuvi를 도와 이 게임의 코드를 완성하는 것입니다.\nActivity 섹션에 나오는 모든 활동은 이 브라우저 탭에서 진행합니다. 여러분이 직접 활동을 수행하게 되지만, 어려울 때는 도움을 받을 수 있습니다.\n목차 목차\r새 이미지 로드 및 화면 텍스트 변경 새가 점프하도록 만들고 중력 적용하기 새가 힘차게 점프하고 회전하면서 떨어지도록 만들기 새가 점프할 때 소리 추가하기 \u0026amp; 보너스 "
},
{
	"uri": "/kr/supply-chain-analytics/",
	"title": "공급망 분석",
	"tags": [],
	"description": "STEM 개념인 최적화를 활용해 쿠키 가게를 효율적으로 운영하는 방법을 배워보세요!",
	"content": "공급망이란 무엇일까? 공급망은 제품이나 서비스를 공급자에서 소비자에게 이동시키는 과정을 말해요. 이는 제품을 이동시키는 데 필요한 사람들, 활동, 정보, 자원을 포함합니다.\nhttps://newsela.com/read/supply-chain-shortages-holidays/id/2001025129/\r예시: 부모님이 내일 점심으로 학교에 가져갈 맛있는 샌드위치를 준비해 주셨어요. 이 과정에서 어떤 일들이 필요한지 알아볼까요?\n농장에서 밀을 재배해요. 공장에서 그 밀을 가루로 만들어요. 빵 공장에서 공장에서 만든 밀가루로 빵을 구워요. 배달 트럭이 공장에서 샌드위치 가게로 빵을 실어 나릅니다. 셰프가 그 빵으로 샌드위치를 만들어줘요. 마지막으로, 소비자인 당신이 가게에서 샌드위치를 사는 거예요! 이 모든 과정은 간단해 보일 수 있어요. 샌드위치가 먹고 싶을 때, 가게에 가서 그냥 하나를 고르면 되니까요. 하지만 그 뒤에는 많은 과정들이 있다는 사실을 잊기 쉽죠. 다음은 그 과정에 포함되는 몇 가지 역할의 예입니다:\n\u003c\u003e\r직업 종류: 예측, 제조, 조달, 협상, 창고 관리, 배달 https://creativemarket.com/falara/\r최근에는 기술이 공급망 운영에 큰 역할을 하고 있어요. 오늘은 여러분이 기술과 수학을 어떻게 사용하여 공급망을 운영할 수 있는지 보여줄게요!\n목차 목차\r상황 설정하기 선형 최적화 - 기초 문제 해결하기 추가 도전 과제 "
},
{
	"uri": "/kr/java-tictactoe/",
	"title": "자바: 틱택토 (Tic-Tac-Toe)",
	"tags": [],
	"description": "Java에서 콘솔 기반 TicTacToe 게임을 만드는 방법 알아보기",
	"content": "\rPrerequisites (from Java: Basics) activity-1: 출력문과 주석(Print Statements and Comments) activity-2: 변수와 유형(Variables and Types) activity-3: : 연산자(Operators) activity-5: 메서드(Methods) activity-6: 객체와 클래스(Object and Classes) activity-7: 데이터 구조: 배열 \u0026amp; 배열 목록(Data Structures: Array \u0026amp; ArrayList) 이 활동에서는 자바 기본(Java: Basics) 워크숍에서 다룬 개념들을 사용합니다. 학습을 진행하기 전에 이 개념들을 복습하거나 처음 배워야 한다면 해당 활동을 참고하세요!\n개요 이 워크숍에서는 자바를 사용하여 틱택토(Tic-Tac-Toe) 프로그램을 처음부터 끝까지 만드는 방법을 배웁니다!\n자바 기본 워크숍에서 배운 자바의 기초 지식이 필요합니다. 변수, 연산자, 클래스, 배열 등의 개념을 알고 있다는 가정하에 진행됩니다.\n각 페이지에는 관련 자바 개념에 대한 링크도 포함되어 있으니, 특정 개념을 복습하고 싶다면 링크를 참고하세요!\n(image created by ParkerPup: giphy.com/parkerpup)\n목차 목차\rIntroduction 1. 게임판 설정하기! 2. 입력을 읽고 처리하기 3. 게임판 업데이트하기 4. 승자를 확인하기 5. (선택 사항) AI 움직임 미리보기 아래 GIF는 이 워크숍을 완료했을 때 여러분이 만들 프로그램을 보여줍니다! 확인해보세요!\n"
},
{
	"uri": "/kr/secret-messages/",
	"title": "C++: 비밀 메시지",
	"tags": [],
	"description": "C++ 배우고 나만의 비밀 메시지 만들기",
	"content": "소개 왕궁에 오신 것을 환영합니다!\n아주 가까운 왕국에서, 왕은 매일 다른 땅에서 대관식을 참관하고 있는 왕비에게 메시지를 보냅니다. 왕비는 국가를 위해 중요한 협상을 진행하고 있어 그곳에 머물러야만 합니다. 그러나 이들의 메시지가 누군가에 의해 도청되고 있다는 사실을 알게 되었습니다! 왕과 왕비는 가장 악랄한 적인 해적들이 자신들이 주고받은 모든 메시지를 읽고 있다는 사실을 깨달았습니다. 다행히도, 왕과 왕비는 해적들이 대화를 엿보지 못하도록 새로운 시스템을 만들기로 했습니다. 하지만 이 시스템을 만드는 데 도움을 줄 사람이 필요합니다. 당신이 왕의 새로운 궁정 개발자로 선정되었습니다! 이제 왕과 왕비가 안전하게 통신할 수 있는 암호화 시스템을 만들어야 합니다. 왕국의 미래는 당신의 손에 달려 있습니다. 도와주시겠습니까?\n목차 목차\rRepl.It 사용하기 Activity 1 - 출력하기t Activity 2 - 변수와 입력 Activity 3 - 반복문 (Loops) Activity 4 - 조건문 (Conditions) Activity 5 - ASCII 코드 Activity 6 - 함수 (Functions) Activity 7 - 입력 줄 (Input Line) 결론 "
},
{
	"uri": "/kr/microbit-distance-checker/",
	"title": "블록: 마이크로빗을 활용한 무선 거리두기",
	"tags": [],
	"description": "블루투스를 사용하여 최소 2m 거리 유지 가이드",
	"content": "이 워크숍에서는 마이크로빗의 무선 블루투스 라디오를 사용하여 두 사람 또는 그 이상의 사람들이 얼마나 서로 떨어져 있는지 측정합니다. 마이크로빗은 서로 최소 6피트(약 2미터) 이상 떨어지면 웃는 표정을 지으며, 그보다 가까워지면 찡그린 표정을 짓습니다.\n목차 목차\r마이크로빗이란? 신호 방송하기 메시지 수신하기 신호 강도 해석하기 시각적 표시 코드 다운로드 및 테스트 "
},
{
	"uri": "/kr/chatbot/",
	"title": "나만의 챗봇 만들기",
	"tags": [],
	"description": "챗봇 입문 가이드",
	"content": "소개 이 워크숍에서는 자신만의 챗봇을 만드는 방법을 배우게 됩니다. 본 워크숍을 수료하면 사용자와 간단한 대화를 나눌 수 있는 챗봇을 만들게 될 것입니다. 또한 챗봇을 만들기 위한 언어인 AIML을 사용하는 방법을 배우고, Pandorabots라는 플랫폼을 사용하여 챗봇을 호스팅하는 방법도 익히게 됩니다.\n워크숍을 수료하려면 Pandorabots 계정 가입을 위한 이메일 주소가 필요합니다.\n챗봇의 정의 챗봇은 질문에 답변하기 위해 인간의 대화를 모방하는 컴퓨터 프로그램입니다.\n챗봇의 예시 여러분은 일상생활에서 이미 챗봇과 대화해본 경험이 있을 것 입니다.\n예를 들어, 스마트 비서(virtual assistant)를 사용해 휴대전화에서 알람을 설정하거나 스마트 스피커에서 음악을 재생한 적이 있을 것입니다.\n또는 제품이나 서비스와 관련된 도움을 받기 위해 챗봇과 대화를 나눈 적도 있을 것 입니다.\n최근에는 ChatGPT와 같은 기술 덕분에 챗봇이 더욱 알려지게 되었습니다.\n챗봇의 역사 챗봇은 오랜 역사를 가지고 있습니다. 최초의 챗봇은 1966년에 만들어졌으며, 그 이름은 ELIZA입니다. 1995년에는 AIML로 작성된 새로운 챗봇인 ALICE가 개발되었습니다. 이번 워크숍에서는 AIML을 사용하여 챗봇을 만들게 됩니다.\n목차 목차\r활동 1: ALICE 만나기 활동 2: PandoraBots 설정 카테고리 활동 3: 나만의 카테고리 추가 와일드카드(Wildcard) 와일드카드 활용(Echoing Wildcards) 활동 4: 와일드카드 사용하기 활동 5: 와일드카드 활용(Echoing Wildcards) 결론 "
},
{
	"uri": "/kr/security-fundamentals/",
	"title": "보안 기초",
	"tags": [],
	"description": "보안의 기초를 배우기 위한 입문 가이드입니다!",
	"content": "목차 보안이란 무엇일까요? 일상생활에서 어떻게 안전한 보안을 유지할 수 있을까요? 보안 vs 개인정보 보호 사이버 보안의 원인과 결과 "
},
{
	"uri": "/kr/security/",
	"title": "보안: 스파이 게임",
	"tags": [],
	"description": "비밀번호에 대한 입문 가이드: 강력한 비밀번호를 만드는 방법",
	"content": "목차 앨리스, 밥, 이브 만나기 비밀번호 기초 활동 스파이 게임 요약 "
},
{
	"uri": "/kr/security-phishing/",
	"title": "보안: 피싱에 대처하기",
	"tags": [],
	"description": "피싱에 대해 배우기 위한 입문 가이드입니다!",
	"content": "목차 밥의 낚시 이야기 피싱의 기본 더 깊이 알아보기 피싱에 대해 더 배우기 어떤 게 피싱일까? 요약 "
},
{
	"uri": "/kr/adafruit/",
	"title": "블록: 아다프루트(Adafruit) 뮤지컬 프루트(Musical Fruit) 프로그래밍",
	"tags": [],
	"description": "하드웨어를 학습하기 위한 아다프루트(Adafruit)를 이용한 사운드 생성 입문 가이드",
	"content": "준비물 다음 프로젝트에 사용할 준비물은 아래에 나열되어 있습니다. 시작하기 전에 모든 준비물을 준비하세요.\n아다프루트(Adafruit) 보드 1개 Micro USB-USB 케이블 1개 아무 색상의 악어 클립 와이어 2개 오렌지 2개 목차 목차\rDJ 스테이션 만들기 프로그램 작성하기 프로그램 다운로드하기 "
},
{
	"uri": "/kr/javascript-blocks-earsketch/",
	"title": "블록: EarSketch로 음악 만들기",
	"tags": [],
	"description": "JavaScript 블록과 EarSketch를 사용하여 음악 만들기",
	"content": "음악을 만들어 봅시다! EarSketch\r를 사용해 음악을 만드는 방법에 대한 입문자 가이드에 오신 것을 환영합니다.\nDJ 누비(DJ Nuvi)를 만나보세요 누비가 새 헤드폰을 받았어요! 여러분의 헤드폰도 찾으셨나요? 여러분은 누비의 다음 히트 믹스테이프를 제작하라는 연락을 받았습니다. 그러나 스튜디오에 도착했을 때, 누비가 이번 프로젝트는 코드로 제작된다고 말합니다. 코드로 음악을 만드는 것은 전에 해본 적 없는 새로운 시도입니다. 도전할 준비가 되셨나요? 주위를 둘러보고 당신의 헤드폰을 찾아서 누비와 함께 할 준비를 하세요!\n시작하기 전에 먼저 헤드폰이 제대로 작동하는지 확인하세요. 아래 오디오를 재생해 보세요. 어떤 소리가 들리나요?\nTest audio to see if your browser supports the audio element. If you cannot play the audio, it likely means your browser does not support this. audio element.\rEarSketch 미리보기 창 목차 목차\r음악의 기본 요소 EarSketch 시작하기 활동 1 - 템포 설정 및 사운드 추가 활동 2 - 곡 만들기! 활동 3 - 곡에 효과 추가하기 활동 4 - 페이드 인 효과 사용하기 "
},
{
	"uri": "/kr/guidelines/",
	"title": "워크숍 참여 기여자 가이드 라인",
	"tags": [],
	"description": "여러분의 참여를 환영합니다. 협업 참여 방법에는 아이디어를 제시하고, 버그 발생시 이를 신고하며, 새로운 워크숍을 생성하고 추가하는 것이 포함됩니다.",
	"content": "여러분의 참여를 환영합니다. 협업 참여 방법에는 아이디어를 제시하고, 버그 발생시 이를 신고하며, 새로운 워크숍을 생성하고 추가하는 것이 포함됩니다.\n시작하기 오타나 버그만 신고하려면, GitHub issues로 등록해 주세요.\n좀 더 적극적으로 협력하고 싶으신가요? help wanted issues 에 나와있는 해당 이슈 항목을 참고해 기여할 수 있는 부분을 찾아보세요. 기여 활동을 시작하려면 다음 가이드를 참고해 주세요:\nHow the site is built\rGetting Started\r콘텐츠 제작자용 워크숍을 새로 만들거나 수정하고 싶으신가요? 위의 ‘시작하기’ 가이드를 먼저 확인하고, 다음을 참고해 주세요:\n포맷팅(Formatting)\r새로운 워크숍 가이드라인\r웹 개발자용 이 웹사이트 개선에 관심이 있으신가요? 위의 ‘시작하기’ 가이드를 참고하고, 다음 가이드를 활용해 주세요:\n웹 개발자 가이드라인\r"
},
{
	"uri": "/kr/",
	"title": "Nuevo Foundation 워크샵",
	"tags": [],
	"description": "",
	"content": "워크숍 프로젝트 C#: Razor를 사용한 웹 사이트 만들기\rC#/Razor를 사용하여 간단한 웹사이트를 만드는 방법에 대한 소개 가이드\nC\u0026#43;\u0026#43;: 비밀 메시지\rC\u0026#43;\u0026#43; 배우고 나만의 비밀 메시지 만들기\nJS: JSappyBird\r나만의 JSappyBird 게임 만들기\n공급망 분석\rSTEM 개념인 최적화를 활용해 쿠키 가게를 효율적으로 운영하는 방법을 배워보세요!\n나만의 챗봇 만들기\r챗봇 입문 가이드\n머신 러닝: 선형 회귀\r다양한 현상을 어떻게 예측하는지 알아보기.\n보안 기초\r보안의 기초를 배우기 위한 입문 가이드입니다!\n보안: 스파이 게임\r비밀번호에 대한 입문 가이드: 강력한 비밀번호를 만드는 방법\n보안: 피싱에 대처하기\r피싱에 대해 배우기 위한 입문 가이드입니다!\n블록: EarSketch로 음악 만들기\rJavaScript 블록과 EarSketch를 사용하여 음악 만들기\n블록: 마이크로빗을 활용한 무선 거리두기\r블루투스를 사용하여 최소 2m 거리 유지 가이드\n블록: 아다프루트(Adafruit) 뮤지컬 프루트(Musical Fruit) 프로그래밍\r하드웨어를 학습하기 위한 아다프루트(Adafruit)를 이용한 사운드 생성 입문 가이드\n워크숍 참여 기여자 가이드 라인\r여러분의 참여를 환영합니다. 협업 참여 방법에는 아이디어를 제시하고, 버그 발생시 이를 신고하며, 새로운 워크숍을 생성하고 추가하는 것이 포함됩니다.\n자바: 틱택토 (Tic-Tac-Toe)\rJava에서 콘솔 기반 TicTacToe 게임을 만드는 방법 알아보기\n파이썬: 머신러닝\r머신러닝에 관한 기초 내용\n기여하다 웹사이트에서 워크숍을 개선하는 데 도움을 주고 싶으신가요? 여기를 클릭하세요: 워크숍 참여 기여자 가이드 라인\r!\n"
},
{
	"uri": "/kr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/kr/ml-machine-learning/",
	"title": "머신 러닝: 선형 회귀",
	"tags": [],
	"description": "다양한 현상을 어떻게 예측하는지 알아보기.",
	"content": "이렇게 어려운 내용을 배우고자 하다니 대단해요! 하지만 걱정 말아요. 이해하기 쉽게 친절히 알려 줄게요. 이 워크숍에서는 머신 러닝에 대한 기초를 소개하고 머신 러닝이 가진 잠재력을 이해할 수 있도록 도와줍니다.\n머신 러닝\r이란 인공지능의 한 분야로, 수천, 수백만, 수십억 개의 데이터 포인트와 특수한 알고리즘을 사용하여 결과를 예측하는 과정을 말합니다. 이 특수한 알고리즘은 인간이 학습하는 방식과 유사하게 학습하도록 설계되어 있습니다. 머신 러닝을 통해 점차적으로 정확도를 높이고, 이 과정이 끝나갈 때쯤에는 높은 정밀도로 결과를 예측할 수 있습니다. (예를 들어 이미지와 텍스트 생성, 텍스트 인식, 행동 예측 등이 가능합니다.)\n단순 선형 회귀(simple linear regression) 을 공부하면 머신 러닝을 공부하고 이해하는 데 큰 도움이 될 것입니다. 본격적으로 머신 러닝을 배워보기 전에 아래 질문을 생각해볼까요?\n특정한 기술을 향상시키기 위해서는 무엇을 해야 할까요? 🤔 \u0026lsquo;반복\u0026rsquo;\n항상 기억하세요, \u0026ldquo;연습이 완벽을 만듭니다.\u0026rdquo; 사람이 그렇듯, 기계도 마찬가지입니다.\n우리는 어떻게 어떤 일이 다시 일어날 수 있다는 것을 알 수 있을까요? 🤔 답변 보기\r우리 두뇌는 패턴을 인식하는 것\r에 탁월합니다. 가령, 주변 환경에서 특정 요인을 조합하여 어떤 일이 다시 일어날 수 있다는 것을 알 수 있습니다.\n무작정 아주 빠르게 달린다면, 실수로 넘어질 가능성이 있을까요?\n\u0026lsquo;2 * 2\u0026rsquo;라는 계산을 여러 번 본다면, 그 답이 4라는 것을 알 수 있을까요?\n두통이 시작되고 몸에서 열이 난다면, 아프다고 추측할 수 있을까요?\n우리 두뇌는 사건들을 관찰하고 특정 결과로 이어질 수 있는 패턴을 기억하는 데 익숙합니다. (예를 들어 \u0026lsquo;2 * 2\u0026rsquo;가 칠판에 적혀 있다면 답이 4라는 것을 쉽게 알 수 있습니다.) 인간처럼, 기계도 정보를 수집하고, 결과를 예측하며, 과거 데이터를 바탕으로 예측하는 능력을 개선할 수 있습니다.\n목차 ‘회귀’란 무엇인가요? 단순 선형 회귀 신뢰 구간(Confidence Interval) 모델 적합도 예측하기 "
},
{
	"uri": "/kr/machine-learning/",
	"title": "파이썬: 머신러닝",
	"tags": [],
	"description": "머신러닝에 관한 기초 내용",
	"content": "FIFA 비디오 게임에서 선수의 종합 능력치를 평가해보자. 머신러닝은 컴퓨터가 명확한 지시 없이도 사물을 인식하고, 결정을 내리며, 심지어 결과를 예측할 수 있도록 해주는 알고리즘과 모델을 연구하는 기술입니다. 예를 들어, 여러분이 시리(Siri)나 코타나(Cortana)와 같은 휴대폰 음성 비서에게 말할 때, 머신러닝은 음성을 텍스트로 변환하고, 요청한 내용을 이해하는 데 도움을 줍니다. 놀랍지 않나요?\n오늘 우리는 축구 선수의 종합 능력치(overall ratings)를 선수의 속성에 따라 평가하는 방법을 단계별로 배워볼 것입니다.\n배경 설명 EA 스포츠(피파 2019의 개발사)에 축구 선수의 종합 능력치를 계산하는 공식이 있다고 가정해봅시다. 이 공식을 알면 게임에 등장하는 선수 든 등장하지 않는 선수 든, 모든 선수의 종합 능력치를 쉽게 계산할 수 있습니다. 문제는 이 공식이 정확히 어떤 식으로 구성됐는지 모른다는 것입니다. 이때 선수의 속성(입력 데이터)과 종합 능력치(출력 데이터)만을 알고 있다고 합시다. 이를 바탕으로, 우리는 회귀(regression)라는 방법을 사용하여 이 공식을 추정할 수 있습니다.\n오늘은 선형 회귀(Linear Regression)라는 간단한 모델을 사용할 것입니다. 예를 들어 축구 선수의 종합 능력치 ( y = f(x)) 를 계산하는 공식이 [ f(x) = ax + b ] 와 같다고 가정해봅시다. 형 회귀의 목적은 이 식에서 a와 b를 찾아내는 것입니다. 이 공식( f(x) )을 머신러닝에서는 모델(model)이라고 부르며, 모델을 해결하거나 추정하는 과정을 모델 훈련이라고 합니다. 모델을 훈련한 후에는 새로운 데이터에 대해 목표값(y)을 예측할 수 있습니다.\n다시 선수의 종합 능력치를 계산하는 공식에 관한 이야기로 넘어가 봅시다. 만일 변수가 하나일 경우(x가 하나일 때)에는 공식을 추정하기는 쉽습니다. 종이와 펜만 있으면 누구나 만들 수 있죠. 하지만 축구 선수의 속성들이 속도, 힘, 패스, 태클처럼 여러 개일 때는 상황이 복잡해집니다. 이 경우 공식은 다음과 같이 바뀌어야 합니다. [ f(x_1, x_2, \u0026hellip;, x_n) = a_1 * x_1 + a_2 * x_2 + \u0026hellip; + a_n * x_n + b ] 이 공식을 게임 회사에서 실제로 사용하고 있는 공식에 최대한 가깝게 만들기 위해서는 고품질의 수많은 데이터를 입력해야 합니다.\n자, 시작해봅시다!\n목차 목차\rStep 1: 데이터셋 가져오기 Step 2: 프로젝트 시작하기 Step 3: 데이터셋 불러오기 Step 4: 데이터 전처리하기 Step 5: 특징 선택하기(Feature selection) Step 6: 모델 훈련하기(Train the model) Step 7: 테스트 데이터로 모델 평가하기 마무리하기 "
}]